##Java 基础知识点概述

### 1、什么是注释?注释分为几种?注释有什么作用?

注释就是对代码的解释说明性文字，

分为三种：单行注释、多行注释、文档注释。

注释可以对程序进行说明，给人看，还可以对程序进行排错。



### 2、什么是关键字?有什么特点?

关键字就是被java语言赋予了特殊含义的单词。

(goto和const作为保留字,在以后的JDK版本中可能会被提升为关键字)

特点就是所有的关键字都是小写。



### 3、什么是标识符?由哪些部分组成?常见的命名规则有哪些?

标识符就是用来给类、接口、方法、变量等起名字的字符。

组成：由数字、字母、`_` 以及 `$` 符号组成，不能以数字开头，不能是 java 中的关键字。

规则:  

- 包     --------全部小写,多级包用 `.` 隔开
- 类或接口 --------每个单词的首字母大写
- 方法或变量--------单个单词首字母小写,多个单词时从第二个单词起每个单词首字母大小
- 常量	  --------全部字母大写,多个单词用下划线”_”相连

### 4、什么是常量?常量的分类?字面值常量表现形式有哪些?

在程序的运行过程中其值不发生改变的量。

字面值常量： 1 14 

自定义常量： int MAX = 100;



### 5、什么是变量?变量的定义格式?要使用变量需要注意什么?

在程序运行过程中，**值可以在某个范围内**发生改变的量。

变量其实就是内存中一小块区域。
	
由3部分组成：

- 数据类型: 限定变量的取值
- 变量名：方便使用。
- 值： 如果没有值就没有意义。

注意:

- 作用域，变量定义在哪个大括号内,他就在最近的大括号内有效
- 初始化:
	- 局部变量在使用前必须先赋值;
	- 成员变量有默认初始值: int 0、double 0.0 、boolean false 、char \u0000、引用类型 null
	
被final修饰的变量属于常量


### 6、Java中的数据类型分几类?基本数据类型有哪些?

数据类型分为两大类：基本数据类型，引用数据类型

基本类型：4类8种。

- 整数(byte,short,int,long)、
- 浮点数(float,double)、
- 字符(char)、
- 布尔(boolean)。


### 7、算术运算有哪些，各自的作用?

有：`+，-，*，/，%，++，--`

- `+` 正号、加法、字符串连接符
- `%` 取得余数
- `++，--`
	- 单独使用：在操作数据的前后效果一致。
	- 参与操作使用：
		- 在操作数据的前面，是先++或者--，然后参与操作。
		- 在操作数据的后面，是先参与操作，后++或者--

`++ , --` 其实像扩展运算符一样，也默认隐含了强制类型转换
	

### 8、`+` 运算符需要注意的问题?

当把+号作为加法和字符串连接符一起使用的时候，注意把运算的地方（）起来。


### 9、赋值运算符常见的有哪些，各自的作用?
* 基本赋值运算符:
`=`:把右边的内容赋值给左边
* 扩展赋值运算符:
`+=，-=，*=，/=，%=`：把左边的和右边的操作后赋值给左边。

注意：
	
`+=`隐含了强制类型转换。

`x+=y;` 等价与：`x = (x的数据类型)(x + y);`

`char x+=y;` 实际等价于 `char x=char(x+y);`


### 10、逻辑运算符有哪些?都有什么作用？

逻辑运算符用来连接 boolean 类型的表达式,输出结果为 true 或 false

运算符|含义
---|---
&|有false则false
\||有true则true
^|相同为false，不同为true。通过情侣关系来理解。
!|非false则true,非true则false。偶数次不改变以前的真假。
&&|和&的结果一样,但是具有短路效果。左边有false,右边不执行。
\|\||和 \| 的结果一样,但是具有短路效果。左边有true,右边不执行。

### 11、位移运算符有什么不同？

位运算操作的是补码,要想操作数据，就必须把所有的数据转换为二进制,并通过源码获取补码。然后操作。

位运算包括: 

运算符|名称|特点
---|---|---
 & | 位与运算 | 有0则0
 \||位或运算  |  有1则1
^ |位亦或运算 | 相同为0  不同为1
 ~ |按位取反    |0变1,1变0
<< | 把数据向左移动，|左边最高位丢弃,右边补0。其实相当与乘以2的移动位数次幂。
>> |把数据向右移动，|右边丢弃,左边补是最高位的值。其实相当与除以2的移动位数次幂。
>>> |把数据向右移动，|左边一律补0。其实相当于除以2的移动位数次幂。


### 12、什么是函数重载？

同一个类中,出现函数名相同，参数列表不同,与返回值类型无关的方法，就叫重载 OverLoad.

特点:

* 1) 参数类型不同,参数个数不同,参数顺序不同,都叫参数列表不同
* 2) 跟返回值类型无关，就是函数重载。


### 13、类是什么?类的组成是哪些?

类是一组相关属性和行为的集合   (抽取了同类对象的共同属性和行为形成的对象或实体的"模版".)

类是由成员变量,成员方法,构造函数组成


### 14、对象是什么?什么时候需要使用对象?

对象是现实世界中实体的描述,是其自身所具有的状态特征及可以对这些状态施加的操作结合在一起所
构成的独立实体.

需要描绘具体事物的时候要使用对象.

>什么是面向对象?
>
>面向对象是一种编程思想。以对象为基础完成各种操作，强调的是对象。它是基于面向过程的。


### 15、封装是什么?自己概述

隐藏对象的属性和具体的实现细节,仅对外提供公共的访问方式.

类、方法其实也是封装的体现。


### 16、继承是什么?自己概述

把多个类中相同的内容提取出来，定义到一个类中。然后让这多个类和这个类产生一个关系，这多个类就具备该类的数据了。这种关系叫：继承。

继承的好处是：提高代码的复用性 ; 提高了代码的维护性 ; 让类与类之间产生了一个关系，是多态的前提。

继承的特点是：Java中类只能够单继承，不支持多继承.但是可以多层继承。


### 17、匿名对象是什么?应用场景是什么?

匿名对象就是没有名字的对象，由于没有指向，所以效率较高一些。

应用场景：

- A：调用方法。但是仅仅只限调用一次而已。
- B：匿名对象用作实际参数传递。


### 18、构造方法的作用是什么?构造方法的特点是什么?构造方法的注意事项是什么?

构造方法的作用是创建类的对象,并可以初始化数据。

* 特点：名称和类名一致，并且没有返回值类型的修饰和返回值。

* 注意：如果我们没有给构造方法，系统将给出一个无参构造方法。如果我们给出了构造方法，系统将不再提供构造方法。


### 19、给成员变量赋值有几种方式?

通过set/get方法。通过带参构造方法。

### 20、方法重写和方法重载的区别?重载可以改变返回值类型吗?（*面试题）  

方法重写：子类中出现和父类中一模一样的方法声明的方法。

方法重载：同一个类中，出现方法名相同，参数列表不同的方法。跟返回值无关。

重载可以改变返回值类型，因为他跟返回值无关。


### 21、static关键字是什么?有什么特点?什么时候用呢?

static关键字：是静态的意思，可以修饰类中成员变量和成员方法。

特点：随着类的加载而加载、优先与对象而存在、被所有对象所共享、可以通过 `类名.静态的内容` 调用。


### 22、this和super的区别,以及应用场景? (*面试题)    
	
this:当前类的引用对象。谁调用代表谁。
super:父类的存储空间标识。可以理解为父类对象，谁调用代表谁父亲。

应用场景：

- A:成员变量
	- this.成员变量	本类的成员变量
	- super.成员变量  父类的成员变量
- B:构造方法
	- this(...)	本类的构造方法
	- super(...)	父类的构造方法
- C:成员方法
	- this.成员方法()	本类的成员方法
	- super.成员方法() 父类的成员方法

### 23、代码块是什么?代码块的分类有哪些及每种代码块的作用是什么?

用{}括起来的代码，就叫代码快。

分为：

- A：局部代码快： 

	就是在方法中用{}括起来的代码。作用是限定变量的生命周期，提高效率。
- B：构造代码快：

	在类中，方法外。用{}括起来的代码。作用是把所有构造方法中相同的内容抽取出来。
	定义到构造代码块中，将来在调用构造方法的时候，会去自动调用构造代码块。构造代码快优先于构造方法执行,而且每执行一次构造方法都要执行一次构造代码块

- C：静态代码快：

	在类中、方法外。用{}括起来的代码。只不过加了static修饰。
	作用是：随着类的加载而加载，而且只加载一次的代码。


### 24、一个类的实例化过程有哪些步骤？（*面试题）

`Student s = new Student();` 在内存中到底执行了哪些步骤。

- 加载 Sutdent.class 文件进内存(类加载器)
- 在栈内存为 s 变量申请一个空间
- 在堆内存为 Student 对象申请空间
- 对类中的成员变量进行默认初始化
- 对类中的成员变量进行显示初始化
- 有构造代码块就先执行构造代码块，如果没有，则省略
- 执行构造方法，通过构造方法对对对象数据进行初始化
- 堆内存中的数据初始化完毕，把内存值复制给 s 变量


### 26、子父类中构造方法的执行有什么特点?为什么要这样?
	
子类的构造方法在执行时，默认都会先去执行父类的空参构造方法,(也就是说第一条语句都是super( )) 。

因为子类继承父类 , 可能直接访问了父类的数据，所以父类的数据要优先于子类的数据进行初始化。


### 27、静态代码块，构造代码块，构造方法的执行顺序是什么?

静态代码块 -- 构造代码块 -- 构造方法

- 静态代码块  在类中方法外  随着类的加载而加载,只执行一次 ;
- 构造代码块  在类中方法外 优先于构造方法执行,且每执行一次构造方法都执行一次构造代码块,>


### 28、final关键字是什么，可以修饰什么，有什么特点?

final关键字：是最终意思，可以修饰类、方法、变量。

- 修饰类：类不可以被继承。
- 修饰方法：方法不可被重写
- 修饰变量：变量为常量。


### 29、多态是什么，前提是什么?

多态：对象在不同时刻表现出来的多种状态。是一种编译时期状态和运行时期状态不一致的现象。

- 成员变量：编译看左边，运行看左边。
- 成员方法：编译看左边，运行看右边。因为，普通成员方法可以重写，变量不可以。
- 静态方法：编译看左边，运行看左边。
	
一句话总结多态的访问特点:除了父类引用指向的是子类重写的方法之外,其他的一律是编译看父类,运行看父类

前提：要有继承或实现关系。要有方法的重写。父类引用指向子类对象。


### 30、多态的好处及弊端？如何解决多态的弊端。

- 好处：提高了程序的可维护性(前提要有继承保证)，和扩展性。
- 弊端：不能使用子类的特有功能。使用向下转型来解决这个问题

### 31、什么是抽象类？抽象类的特点和好处是什么?

含义: 用 abstract 修饰的类就叫做抽象类

//相同的方法，有相同方法的声明，但是方法体不一样，只抽取方法声明的方法，叫做抽象方法，有抽象方法的类，叫做抽象类。

特点：

- A：类或者方法必须用abstract修饰。抽象类不一定有抽象方法,但是有抽象方法的类一定是抽象类
- B：具体类在继承抽象类的时候，要么本身也是抽象类，要么重写抽象类中的所有抽象方法。
- C：抽象类不能被实例化。要想使用，必须按照多态的方式使用。
- D：成员特点:
	- a：成员变量——可以是变量，也可以是常量。
	- b：构造方法——有构造方法，但是不能实例化。用于子类访问父类数据的初始化。
	- c：成员方法——可以是抽象方法,也可以是非抽象方法。

好处：
	
- A：限定子类必须实现某些功能。
- B：提高代码的复用性。


### 32、抽象类的其他几个问题：

* A:抽象类不能实例化，构造方法有什么用?
	
用于子类访问父类数据的初始化。

* B:抽象类没有抽象方法，有什么意义？

限制创建对象。
	
### 33、abstract 不能和哪些关键字共存?

final: 冲突 、private: 冲突 、static: 无意义
	
* private：

private修饰的方法是不能被继承的，所以不能被重写，而abstract强制要求子类重写，矛盾

* final: 

final表示最终的意思，修饰方法，不能被重写，而abstract强制要求子类重写，矛盾

* static: 

static是为了让所有对象共享，为了让类名调用，来执行一些方法里面的内容的，而abstract修饰方法是抽象方法 没有方法体， 那让对象共享一个没有方法体的方法 有啥意义？


### 34、什么是接口? 接口的特点?

如果一个抽象类中的方法全部是抽象方法，那么 java 就针对这种类型的抽象类，给出了一个更抽象的表达式：接口。

特点：

- A：所有的方法，都是抽象方法。
- B：类实现接口，要么本身是抽象类，要么重写接口中的抽象方法。
- C：接口不能被实例化，要想使用，用多态。
- D：成员特点
	- a:成员变量——只有常量，并且是静态常量。默认修饰符：public static final,必须显示初始化
	- b:构造方法——没有构造方法，子类数据的初始化默认走的是 Ojbect 类的构造方法
	- c:成员方法——全部是抽象的，有默认修饰符：public abstract


其他相关：

- A、instanceof 是关键字，判断前边的引用是否是后边的类的实例
- B、当一个方法的参数是父类类型时，调用该方法可以传子类匿名对象
- C、如果一个类没有抽象方法，却声明为抽象类，那这样做的唯一目的就是不让其它类创建本类对象。


### 35、抽象类和接口的区别? （*面试题）

A：成员区别

	抽象类：
		成员变量:可以是变量，也可以是常量。
		构造方法:有。
		成员方法:有，可以是抽象的，也可以是非抽象的。

	接口：
		成员变量:只能是常量。默认修饰符：publci static final
		构造方法:没有，子类数据的初始化默认走的是Ojbect类的构造方法。
		成员方法:只能是抽象的，默认修饰符是:public abstract

B：类与接口的关系区别
	
	类与类：
		继承关系，单继承。
	
	类与接口：
		实现关系，单实现、多实现。

	接口与接口：
		继承关系，单继承、多继承。

C：设计理念的区别
	
	抽象类被继承体现的是：is a 的关系。抽象类中一般定义的是整个继承结构的共性功能。
	接口被实现体现的是：like a 的关系。接口中一般定义的是整个继承结构的扩展功能。


### 36、什么是内部类？有什么特点？

把类定义在其他类的内部，就被称为内部类。

内部类的访问特点：

	A：内部类可以直接访问外部类的成员，包括私有。
	B：外部类要访问内部类的成员，必须创建对象。


### 37、为什么内部类访问局部变量必须加final修饰？(*面试题)

A: 防止在使用后数据发生改变。

B: 延长变量的生命周期。

### 38、什么是匿名内部类？本质是什么？

定义:匿名内部类就是没有名字的内部类。

前提：有一个接口或者抽象类 或者 普通的类

格式：
	
	new 类名或者接口名( ) {
		重写方法;
	};

本质：是继承类或者实现接口的子类匿名对象。


### 39、== 和 equals()的区别? (*面试题)
	
	A:==
		a:基本类型 比较的是基本类型的值
		b:引用类型 比较的是引用类型的地址值
	B:equals()
		只能比较引用类型。
		默认比较地址值。
		
`==` 是一个比较运算符号,既可以比较基本数据类型,也可以比较引用数据类型,基本数据类型比较的是值,引用数据类型比较的是地址值

`equals()`是一个方法,只能比较引用数据类型,所有的对象都会继承 Object 类中的方法, 如果没有重写 Object 类中的 equals方法, equals方法和 == 号比较引用数据类型无区别,重写后的 equals 方法比较的是对象中的属性


### 40、什么是字符串？字符串的特点是什么？

字符串：由多个字符组成的一串数据。

特点：一旦被赋值就不能被改变。（*面试题）

注意：这里指的是字符串的内容不能发生改变。而字符串的引用是可以再次赋值的。


### 41、String s1 = new String("hello");和String s2 = "hello";的区别？（*面试题）

有区别，区别是：前者创建了两个对象，后者创建了一个对象。


### 42、String、StringBuffer、StringBuilder的区别？（*面试题）

答案1:	
	
	String:字符长度是固定的。()

	StringBuffer/StringBuilder:字符长度是可变的。

	StringBuffer:安全的，但效率较低一些。

	StringBuilder:不安全的，但效率较高一些。

	StringBuffer 和 StringBuilder 兼容。

答案2:

	1) StringBuffer 是字符串缓冲区类，是 jdk1.0 出现的 是线程安全的长度可变的字符序列 ，效率低
	2) StringBuilder 是 jdk1.5 出现的 和 StringBuffer 里面的所有方法一模一样 也是字符串缓冲区类，线程不安全的长度可变字符序列，效率高( StringBuffer 与 StringBuilder 兼容)
	3) String 的值是长度不可变的字符序列， 而 StringBUffer 和 StringBuilder 是可变的字符序列


其他相关: 

* String类的valueOf方法可以把任意类型的数据转成字符串。
* String类是被final修饰的类,不能被继承


### 43：什么是基本数据包装类？

为了对基本类型的数据进行更多的操作的，java就针对每种基本类型的数据提供了对应的包装类类型。

类型|包装类
---|---
byte	|	Byte
short	|	Short
int	 	|	Integer
long	|	Long
float	|	Float
double	|	Double
char	|	Character
boolean	|	Boolean

相关:包装类用于基本数据类型与字符串之间的转换。

### 44、什么是正则表达式？

正则表达式就是符合一定规则的字符串。


### 45、集合和数组有什么区别？（*面试题）

	集合: 
		长度可以发生改变。
		只能存储对象类型，引用类型。
		可以存储任意类型的对象。
	数组:
		长度固定。
		可以存储基本类型，也可以存储引用数据类型。
		只能存储同一种类型的元素。

### 46、集合有多少种？ 各自的特点是什么？

Collection：单列集合顶层接口	遍历方式：增强for      Iterator     集合转数组

- List：
	- ArrayList：不安全 效率高 数组结构 增删慢 查询快
	- LinkedList：不安全 效率高 链表结构 增删快 查询慢
	- Vector：数组结构 安全 效率低 增删慢 查询快
			
	特点：存取有序、元素可以重复 、有索引、可以通过索引操作元素。

	遍历方式：普通for、 增强for、Iterator、 ListIterator、集合转数组
			
- Set：		
	- HashSet：哈希结构 存取无序 元素唯一
		- LinkedHashSet(是set集合中唯一一个存取有序的)
	- TreeSet：二叉树结构 可以排序(自然排序,比较器排序)
	
	特点：存取无序、元素唯一。	
	
	遍历方式：增强for、Iterator、集合转数组

Map：双列集合  键唯一、值可以重复	遍历方式：根据键找值、根据键值对找键和值

- HashMap：底层的哈希结构 保证键的唯一
	- LinkedHashMap：存入和取出的顺序相同，同时键也是通过哈希算法保证元素唯一性的
- TreeMap：底层的二叉树结构 保证键的排序和唯一


### 47、泛型是什么?有什么用?在哪里用?泛型有什么好处和弊端？

泛型是一种泛泛的类型，泛指某种类型，是在创建对象或者调用方法或者实现接口时才明确的数据类型

泛型是一种把明确数据类型的工作推迟到创建对象或者调用方法的时候才去明确的特殊的数据类型。

	好处：
		优化了程序的设计，解决了黄色警告线的问题。
		把运行时期的问题提前到了编译时期间解决了。
		避免了强制类型转换。

	弊端：
		类型固定了,只能存储单一的数据类型。

泛型使用注意事项(☆☆☆)

- <>中放的必须是引用数据类型
- 前后的泛型必须一致,或者后面的泛型可以省略不写(1.7的新特性菱形泛型) (建议后面的也写全)
- 在创建对象或者调用方法或者实现接口明确泛型的时候，尽量不要明确成 Object，因为这样做没有意义（泛型的由来就是由 Object 的转型的问题得到的）
- 泛型是JDK1.5出现的


### 48、用迭代器遍历集合的时候，用集合修改集合有没有问题？如果有，怎么解决？（*面试题）

有问题，因为会出现并发修改异常。

解决方法 

* 使用普通 for 循环倒序遍历并修改元素(普通for配合get()方法)
* 使用 ListIterator 迭代器

### 49、HashSet如何保证元素唯一性的呢?

底层数据结构是哈希表(散列表)。具体的是由一个元素是单向链表的数组组成。

它依赖于两个方法：`hashCode()`和`equals()`方法。

先判断 hashCode() 是否相同，
	
* 如果不同——存储。
* 如果相同——继续执行equals()方法，看其返回值：
	- true:元素重复，不存储。
	- false:元素不重复，存储。
			
		
```java
记住：
	在 HashXxx结构的集合中，存储的元素需要重写 hashCode()和equals()方法。
	而且，是自动生成的。
```


### 50、TreeSet底层数据结构是什么？如何保证元素的唯一性的呢?

底层数据结构是二叉树(也叫红黑树)。

根据比较的返回值是否是 0 来决定。
	
	如何保证元素的排序的呢?
		A: 自然排序 元素具备比较性
			让集合中被存储的元素所属的类实现Comparable接口(要给comparable加泛型)。
		B: 比较器排序 集合具备比较性
			在创建集合对象的时候，让构造方法接收一个Comparator接口的子类对象。

	自然排序和比较器排序的区别:
		A: TreeSet构造函数什么都不传, 默认按照Comparable(接口,compareTo(T))的顺序(没有实现Comparable就报错ClassCastException)
		B: TreeSet如果传入Comparator(接口compare(T1,T2)), 就优先按照Comparator

### 51、LinkedHashSet底层数据结构是什么？如何保证元素的唯一性的呢?

底层由链表和哈希表组成。
	
	- 由链表保证有序。
	- 由哈希表保证唯一。



### 52、什么是可变参数？

针对在写一个方法的时候，不知道具体要有多少个形式参数的时候。  java提供了可变参数的用法。

注意：
	
	A:可变参数其实是该数据类型的一个数组。
	B:形式参数如果有多个的话，可变参数只能是最后一个。
	C:数据类型要一致。JDK1.5之后出现的

格式：`修饰符   返回值类型   方法名  ( 数据类型 ... 变量名 ){  }`


### 53、Map 和 Collection 集合的区别？(*面试题)
		
	A:Map集合存储的是键值对形式的元素。
	  Collection集合存储的是单个的元素。
	
	B:Map集合的键是唯一的。
	  Collection的子接口Set集合元素是唯一的。
	
	C:Map集合的值是可以重复的。
	  Collection的子接口List集合的元素是可以重复的。

	D:Map集合的数据结构仅对键有效,对值无效.
	  Collection的数据结构是针对元素有效的
	

### 54、Hashtable 和 HashMap 的区别?(面试题)
	
	A:HashMap 线程不安全，效率高。允许 null 键和 null 值。
	
	B:Hashtable 线程安全，效率低。不允许 null 键和 null 值。


### 55、Collection 和 Collections 有什么区别？

	Collection:是集合的顶层接口，定义了集合的通用方法。

	Collections:是一个工具类，里面定义了对集合进行操作的一些常见方法。


### 56、什么是异常？异常有哪几种？各有什么特点？

程序出现了不正常的情况，就是异常。

异常的继承体系结构：

	Throwable  (类)
		|--Error (类)  严重的问题，一般我们解决不了。
		|--Exception
			|--RuntimeException	运行时期异常，这种问题一般要修正代码。
			|--非RuntimeException	编译时期异常，必须进行处理，否则代码不能够通过。


### 57、throws和throw的区别? （*面试题）

答案1:

	a:throws
		* 用在方法声明后面，跟的是异常类名
		* 可以跟多个异常类名，用逗号隔开
		* 表示抛出异常，由该方法的调用者来处理
	* b:throw
		* 用在方法体内，跟的是异常对象名
		* 只能抛出一个异常对象名
		* 表示抛出异常，由方法体内的语句处理

答案二:
	
	throws
	位置：在方法()后面，跟的是类名,后面可以跟多个异常类名,并且用逗号隔开
	表示抛出异常,交给调用者去处理
	如果后面根据的是RuntimeException及其子类，那么，该方法可以不用处理。
	如果后面根据的是Exception及其子类，那么，必须要编写代码进行处理，或者调用的时候抛出。
	
	throw
	位置：在方法中，跟的对象名称。后面只能跟一个异常对象
	表示抛出异常,由方法体内语句处理
	如果方法中，有throw抛出RuntimeException及其子类，那么，声明上可以没有throws。
	如果方法中，有throw抛出Exception及其子类，那么，声明上必须有throws。



### 58、final、finally、finalize的区别？（*面试题）

final：是最终的意思，用于修饰类、变量、和方法。修饰类的时候，类是最终类，不可以被继承。
	修饰变量的时候，变量为常量，不可以被改变。修饰方法的时候，方法不能被重写。

finally:是异常处理的一部分，它里面的代码永远会执行(前提:jvm没退出)，一般用于释放资源。

finalize:是object类的一个方法，用于垃圾处理。


> 退出虚拟机的语句 System.exit(0)

### 59、什么是递归？使用递归需要注意哪些？

递归就是方法定义中调用方法本身的现象。

	A:递归一定要有出口，否则就是死递归。
	B:递归的次数不能太多，否则内存溢出。
	C:构造方法不能递归使用。


### 60、基本的IO流有哪些？(*面试题)

字节流：InputStream、OutputStream、FileInputStream、FileOutputStream、

字符流：Writer、Reader、FileWriter、FileReader、

高效字节流：BufferedInputStream、BufferedOutputStream

高效字符流：BufferedWriter、BufferedReader

最开始的时候，只有字节流，但是后来由于中文字符或者其他字符的出现，用两个字节才能表示。

如果用字节流也是可以读写字符文件的数据的，但是比较麻烦。为了简化这种操作，就提供了字符流。

	BufferedReader 中有一个readLine()方法,一次可以读取一行文本,但不包括换行符
	BufferedWriter 中有一个newLine()方法,这是一个跨平台的换行符,


### 61、flush()和close()的区别？(*面试题）

flush():刷新缓冲区，流对象还可以继续使用。

close():释放流资源，但是会先刷新一次缓冲区，操作完毕后，流对象不可以再使用。



### 62、什么是多线程？进程和线程的区别是什么？

多线程就是应用程序的多条执行路径。线程就是程序的一条执行路径,

进程：正在运行的应用程序，每个进程都具备独立的运行空间。

线程：是进程的执行单元，执行路径。如果是多个线程，那么，这多个线程共享同一个进程资源。



### 63、启动线程调用的是run()还是start()方法？run()和start()的区别是什么？（*面试题）

	启动线程调用的是start()
	run()封装了被线程执行的代码，start()是启动线程并调用run()方法。


### 64、多线程有几种实现方案？分别是什么？如何操作？（*面试题）

	多线程有两种实现，分别是：

	1，继承Thread类
		自定义类继承Thread类，在类中重写run()方法，测试类中创建自定义类对象，并调用start()方法

	2，实现Runnable接口
		自定义类实现Runnable接口，重写run(）方法，测试类中创建自定义对象，
		创建Thread对象，把自定义对象作为构造参数传递。调用Thread类的start()方法。


### 65、线程的生命周期？ （*面试题）

	新建：	创建线程对象
	就绪：	具备cpu执行资格，没有执行权，随时准备执行
	运行：	具备执行资格，执行权，执行run()中的代码
	堵塞：	是当线程运行到符合某个我们定义的条件时，它会停止下来等待唤醒
	死亡：	run()结束了



### 66、多线程为什么会出现安全问题？怎么解决呢？（*面试题）

如果满足以下条件，那么就会出现安全问题：

	A：是多线程程序。
	B：有共享的数据。
	C：针对共享数据有多条语句操作。
	
一句话: 多线程并发/共同操作同一个数据,就可能会出现安全问题

解决:只要我们在多线程环境中，把操作共享数据的操作，用同步变成单线程就没有问题了。

Java针对这种情况，就提供了同步技术：
	
	A：同步代码块
	B：同步方法
	C：JDK5 以后的Lock锁


### 67、同步的锁对象分别是？（*面试题）

	同步代码块：任意对象

	同步方法：this

	同步静态方法：类名.class


### 68、sleep()和wait()的区别？（*面试题）

	sleep():必须指定时间，到时间之后会自动唤醒   休眠时不释放锁对象。
	wait():可以指定时间，也可以不指定 进入等待状态之后必须手动使用 notify 或 notifyAll 唤醒 进入等待状态后释放锁对象。

### 69、线程死锁是什么，为什么有死锁，怎么解决死锁？（*面试题)

线程为了争抢执行权而进入(一直)循环等待的状态,就叫死锁
    
或者是为了解决程序因占用资源，出现资源争抢，而出现的程序进入等待的状态（死锁）。
        
举例：
> 有A和B两个线程，有CD 两把锁， A和B嵌套CD锁，A线程中有C，D锁，B线程中有D C两把锁，当两个线程运行时，就可能会出现死锁导致程序停滞的情况。
        
怎么解决：
>真正意义上来说，死锁是不能被解决的，死锁是多线程中的一个需要避免的重大的问题，当我们在编写程序时，可以给共享的资源加上另外一个把锁，控制资源的动态，同时可以设置线程的优先级使线程之间协调合理的利用CPU的时间。

解决方案:  
>给共享的资源加锁,控制资源动态; 同时设置线程的优先级



### 70、线程间的通信是什么？

不同种类的线程针对同一个资源的操作。

多个线程并发执行时, 在默认情况下CPU是随机切换线程的。如果我们希望他们有规律的执行, 就可以使用通信


### 71、什么是网络编程？

用编程语言来实现计算机的资源共享和信息传递，就叫做网络编程。


### 72、网络通信三要素是什么？ （*面试题）

	A:IP地址
		计算机在网络中的唯一标识。
		现在使用的是："点分十进制"
	B:端口
		应用程序的的标记。
	C:协议
		通信的规则。


### 73、UDP和TCP的区别？ （*面试题）

	UDP:不建立连接，数据打包传输，数据有限制，数据不可靠，速度快。
	TCP:建立连接，数据无限制，数据可靠，速度慢。

### 74、反射是什么？反射获取字节码文件的三种方式？反射的好处？（*面试题）

在运行状态下，通过class文件对象（Class的对象），去使用构造方法，成员变量，成员方法。就是反射。
        
获取字节码的3种方法：

* 用Object类的 getClass 方法得到。
* 用任意数据类型的静态 class 属性可以得到
* 用Class类的静态方法forName（String className）方法得到
        
好处：

* 只要有一个类或者一个类的对象，就可以得到这个类或对象的所有属性和方法。包括私有的。


### 75、单例设计模式

作用:保证一个类在内存中只有一个对象,而且不能被改变

- 饿汉式	先创建一个对象, 以空间换时间
- 懒汉式  随用随建    以时间换空间
- 简单式	一句话解决	<私有构造,然后为本类中创建的本类对象加final>

	1)为了保证只有一个对象,不能让其他类创建本类对象,需要私有构造方法,私有构造后本类中建一个本类对象

	2)为了保证对象不被改变,要把本类中创建的对象加私有,为了让公共方法方问到这个对象,还要加静态

	3)提供对外的公共访问方法


### 76、说出 ArrayList,Vector, LinkedList 的存储性能和特性？

- Arraylist  底层数组结构,查询快 增删慢,线程不安全 效率高
- Vector    底层数组结构,查询快,增删满,线程安全,效率低
- LinkedList  底层链表结构,查询慢,增删快,线程不安全,效率高


### 77、什么是java序列化，如何实现java序列化？

对象操作流(也叫做序列化流)，该流可以将一个对象写出到文件中(就是序列化), 或者从文件中读取一个对象到程序中(就是反序列化).

* ObjectOutputStream类 ：writeObject()方法(将对象序列化到硬盘上)
* ObjectInputStream类 ：readObject()方法(将对象从硬盘反序列化到程序中)


### 78、String 和 int 之间的转换(☆☆☆☆☆)	
* String --> int

```java
Integer.parseInt(str);
```

		
* int --> String 
	
```java		
Integer.toString(a);
String.valueOf(a);
a+"";
```

### 79、Integer面试题(☆☆)：

-128到127是byte的取值范围,如果在这个取值范围内,自动装箱就不会新创建对象,而是从常量池中获取

如果超过了byte取值范围就会再新创建对象

```java
		Integer i1 = new Integer(97);
		Integer i2 = new Integer(97);
		System.out.println(i1 == i2);		 //false
		System.out.println(i1.equals(i2)); //true
		System.out.println("-----------");

		Integer i7 = 128;
		Integer i8 = 128;
		System.out.println(i7 == i8);		//false
		System.out.println(i7.equals(i8));//true
		
		Integer i5 = 127;
		Integer i6 = 127;
		System.out.println(i5 == i6);		//true
		System.out.println(i5.equals(i6));//true
		System.out.println("-----------");
```


### 80、IO流中复制文件的方式:

#### (1)、普通字节流复制文件 

一次一个字节数据（效率太低了）(这是基本格式,要记住)

```java
FileInputStream fis = new FileInputStream("双元.jpg");
FileOutputStream fos = new FileOutputStream("copy.jpg");
//用来接收读取到的字节数据
int b;		                                    
while((b = fis.read()) != -1) {	
	//在不断的读取每一个字节,只要不是-1就继续读
	fos.write(b);				
}
//关流释放资源
fis.close();				
fos.close();
```

#### (2)、一次获取文件中的全部字节个数

普通字节流复制文件 一次性拷贝一整个文件（效率高，但是可能会有内存溢出的危险）

```java
FileInputStream fis = new FileInputStream("致青春.mp3");
FileOutputStream fos = new FileOutputStream("copy.mp3");

//创建与文件一样大小的字节数组	
byte[] arr = new byte[fis.available()];	
//将文件上的字节读取到数组(内存)中
fis.read(arr);	
//将字节数组中的字节数据写到文件上				
fos.write(arr);					
	
fis.close();
fos.close();
```

##### 1)、有几种获取文件大小的方式呢？

两种： 

- File 类的方法 length()
- FileInputStream 类的 available()

推荐用 length()，因为如果调用 available() 必须创建 FileInputStream 对象，使用完毕available() 后，还需要做关闭流的操作;     而 length() 的调用则不用关闭 File 对象

#### (3)、普通字节流复制文件 

一次一个字节数组（一次一个字节数组的读写，既提高了效率又不至于内存溢出 ）(重点,必须记住)

```java
FileInputStream fis = new FileInputStream("致青春.mp3");
FileOutputStream fos = new FileOutputStream("copy.mp3");

//一般就定义成8kb的大小,(长度也可以改成其他)	
byte[] arr = new byte[1024 * 8]; 

//len是读到的有效字节个数
int len;
				
while((len = fis.read(arr)) != -1) {	
	//参数中传入arr是将文件上的字节读取到字节数组中，
	//如果忘记加arr,返回的就不是读取的字节个数,而是字节的码表值
	//0表示是从数组的0索引开始 len表示写入数组的0-len长度的数据
	fos.write(arr,0,len);   
}
	
fis.close();
fos.close();

```

##### 1)、fis.read()

如果括号中不加参数,就是读取到的当前数据所对应的GBK码表值,后面没有数据了,就返回-1;

如果括号中加了参数,就代表读取到的有效字节个数,后面如果没有数据了,就返回-1


### 81、网络编程三要素  

网络编程 又叫 Socket编程  也叫 套接字编程。

三要素为：IP、端口、协议
	
	1）IP：网络中每一台计算机的唯一标识。
	2）端口：用于标识进程的逻辑地址
	3）协议：定义通信规则
		TCP
			建立连接通道
			数据无限制
			面向连接(三次握手)
			可靠
			速度慢
		举例：
			蓝牙，QQ单聊，打电话
	
		UDP
			把数据打包
			数据有限制
			面向无连接
			不可靠
			速度快
		举例：
			QQ聊天室(群聊)
