基于 [Kotlin 官方文档--Coroutines](https://kotlinlang.org/docs/reference/coroutines/coroutines-guide.html) 整理和总结



* 需要先了解的知识：协程和线程的区别
* 挂起和阻塞

---


## 十二、协程

### 1、协程基础

在开始编码前，先新建 Gradle 项目，然后引用 `kotlinx.coroutines` 包。

![](https://images.gitee.com/uploads/images/2019/0304/103537_373787f0_930142.png "屏幕截图.png")

![](https://images.gitee.com/uploads/images/2019/0304/103615_abe391fe_930142.png "屏幕截图.png")

![](https://images.gitee.com/uploads/images/2019/0304/103706_68c306b1_930142.png "屏幕截图.png")

![](https://images.gitee.com/uploads/images/2019/0304/103811_b3be5865_930142.png "屏幕截图.png")

![](https://images.gitee.com/uploads/images/2019/0304/104047_7d4e0e8a_930142.png "屏幕截图.png")

[点击查看官方关于 引入 kotlinx.coroutines 包的参考](https://github.com/hltj/kotlinx.coroutines-cn/blob/master/README.md#using-in-your-projects)

#### (1)、第一个协程程序

```kotlin
import kotlinx.coroutines.GlobalScope
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch

fun main() {
    // 开启协程
    GlobalScope.launch {
        delay(1000L)
        println("Kotlin")
    }

    println("Hello")
    //这个延时是为了保证协程中的程序一定能被执行，防止出现协程中的内容未执行，程序就退出的情况
    Thread.sleep(2000L)
}
```

运行结果：

```
Hello
Kotlin
```

上述代码会先打印 Hello, 然后 1秒 后打印 Kotlin，再过 1秒后程序结束。

* 协程本质上是一个轻量级的线程。
* ` GlobalScope.launch{ }` 用来启动一个新的协程
* `delay()` 是一个挂起协程的操作，不会造成对应线程的阻塞。只能在 协程 或 挂起函数 中使用
* ` Thread.sleep()` 是一个阻塞线程的操作

#### (2)、runBlocking{ }

```kotlin
fun main() {
    // 开启协程
    GlobalScope.launch {
        delay(1000L)
        println("Kotlin")
    }

    println("Hello")
    
    runBlocking {
        delay(2000L)
    }
}
```

运行结果和前面的结果一致。

* `runBlocking{ }` 表示在当前线程中开启一个新的协程并阻塞当前线程，直到协程中的内容执行完毕才会释放线程。
* `runBlocking{ }` 只能在协程外部使用。它是被挂起的代码块和主函数之间的桥梁


我们在 前面的两个示例中分别使用了 Thread.sleep() 和 runBlocking{ } ，他们的目的都是为了延长线程的生命周期，防止协程中的内容还没有执行程序就退出了——如果把这两个函数中的延时去除，那么，新建协程中的内容将不会执行，也就说，不会打印 Kotlin.

上述代码还可以简化为如下：

```kotlin
fun main()= runBlocking {
    GlobalScope.launch {
        delay(1000L)
        println("Kotlin")
    }

    println("Hello")
    delay(2000L)
}
```

#### (3)、协程中的 join()

实际应用中，我们无法准确获取到一段代码的执行时间，所以，前面使用 delay(2000) 延时的方式并不实用。此时就需要使用 Job 中的 join(), 它的作用是挂起协程，直到其中的内容执行完毕。

```kotlin
fun main() = runBlocking {

    val jobCoroutine = GlobalScope.launch {
        delay(1000L)
        println("Kotlin")
    }

    println("Hello")

    // join() 的作用是挂起协程，并保证其能完整执行。
    jobCoroutine.join()
}
```

上面的示例代码中，join() 把 runBlocking() 构建的主协程挂起，当主协程中的 jobCoroutine 子协程执行完毕之后才关闭主协程。

* join() 只能在协程内部使用


#### (4)、结构化并发--runBlocking{} 内嵌套协程

上一节中创建了 jobCoroutine 之后，我们手动调用了 join() 。但实际上我们在 runBlocking{ } 构建的协程中再创建协程时，我们完全可以省略 join。

```kotlin
fun main() = runBlocking {
    launch {
        delay(1000L)
        println("Kotlin")
    }

    println("Hello")
}
```

#### (5)、作用域构建器--coroutineScope{}

```kotlin
fun main() = runBlocking {

    launch {
        println("BBBBBBBBBB")
    }

    coroutineScope {
        launch {
            println("DDDDDDDDDd")
        }
			
		 // 此处不需要等待 协程执行完毕就可以直接执行
        println("CCCCCCCCCCCC")
    }

    println("AAAAAAAAAAA")
}
```

运行结果：

```
CCCCCCCCCCCC
BBBBBBBBBB
DDDDDDDDDd
AAAAAAAAAAA
```

* coroutineScope{ } 构建一个新的协程作用域，如果其中包含子协程，子协程不会阻塞所在线程。

#### (6)、挂起函数修饰符--suspend

```kotlin
fun main() = runBlocking {
    launch {
        delay(1000L)
        println("BBBBBBBBBB")
    }

    println("AAAAAAAAAAA")
}
```

当我们我们使用 IDEA 的快捷键把上面示例中 launch{} 内部的代码内容提取成方法时，会得到如下内容：

```kotlin
fun main() = runBlocking {
    launch {
        cusPrint()
    }

    println("AAAAAAAAAAA")
}

private suspend fun cusPrint() {
    delay(1000L)
    println("BBBBBBBBBB")
}
```

我们提取出来的函数被关键字 suspend 修饰，表示这是一个挂起函数。


#### (7)、协程是轻量的

```kotlin
fun main() = runBlocking {

    // 重复开启 100W 个线程时，不会爆出内存不足之类的错误
    repeat(100_0000) {
        launch {
            delay(100)
            println(".")
        }
    }

    // 如果重复开启 100W 个线程，可能会爆出内存不足之类的错误
    // repeat(100_0000) {
    //     Thread {
    //         Thread.sleep(100)
    //         println(".")
    //     }.start()
    // }
}
```

上述示例代码中我们分别创建了 100W 个协程和线程。在创建协程的时候计算机没有任何压力；但在创建线程的时候，CPU 风扇快速旋转，噪音增大——这是就内存和CPU消耗较大的表现。当前电脑配置为 MacPro I7 + 16G , 如果配置再低一些的话在创建线程时可能就会爆出内存不足或者卡死等现象了。


#### (8)、全局协程类似守护线程

```kotlin
fun main() = runBlocking<Unit> {

    GlobalScope.launch {
        repeat(1000) { i ->
            println("这是第 $i 次打印")
            delay(500)
        }
    }

    delay(1300)
}
```

上述代码中通过 delay(1300) 延长了 GlobalScope.launch 新建协程的生命周期，但这种方式并不能保证协程所在进程一直存活，它更像是守护线程。

### 2、取消与超时

#### (1)、取消协程的执行

launch{} 启动协程之后会返回一个 Job 对象，当我们在某些场景下需要手动的取消协程时，就可以调用 Job 的 cancel().

在两种情况下协程可以被取消：

- 主动调用 cancel()
- 遇见 CancellationException

```kotlin
fun main() = runBlocking<Unit> {

    val cusJob = launch {
        // 每 500 毫秒打印一次，总共打印 10 次
        repeat(5) { i ->
            delay(500)
            println("1、500 毫秒执行一次打印：$i")
        }
    }

    delay(1100)
    // 取消协程
    cusJob.cancel()
    println("2、取消协程的执行")

    // 加入 join() 后，就成了一个阻塞操作，只有对应协程中的内容执行完毕或取消后才会执行后面的内容
    cusJob.join()

    println("3、AAAAAA")
}
```

运行结果：

```
1、500 毫秒执行一次打印：0
1、500 毫秒执行一次打印：1
2、取消协程的执行
3、AAAAAA
```

如果把 cusJob.join() 注释掉，那么就会先打印 `3、AAAAAA`

#### (2)、取消是协作的

也就是说，只有当协程内部的所有操作都是可以取消的，协程才能被取消。

如果协程内部正在执行计算类或其他无法被取消的任务，这个协程是无法被取消的，如下：

```kotlin
fun main() = runBlocking<Unit> {

    val startTime = System.currentTimeMillis()

    val cusJob = launch(Dispatchers.Default) {
        var nextTime = startTime
        var i = 0
        while (i < 5) {
            if (System.currentTimeMillis() > nextTime) {
                println("1、正在睡觉。。。${i++}")
                nextTime += 500
            }
        }
    }

    delay(1300)
    println("2、等等等。。。将要执行取消操作")

    //等价于 { cancel() join() }
    cusJob.cancelAndJoin()

    println("3、程序结束")
}
```

运行结果：

```
1、正在睡觉。。。0
1、正在睡觉。。。1
1、正在睡觉。。。2
2、等等等。。。将要执行取消操作
1、正在睡觉。。。3
1、正在睡觉。。。4
3、程序结束
```

上述示例代码中，虽然触发了 cancelAndJoin() , 但由于协程代码块中有计算操作——结束条件是一个计算表达式 i<5 ，所以没有被 cancel , 而是继续执行直到程序正常结束。

而对于下面的这个代码，由于协程中并没有计算类型的代码块，所以，可以直接被取消。

```kotlin
fun main() = runBlocking<Unit> {

    val cusJob = launch(Dispatchers.Default) {
        repeat(5) { i ->
            delay(500)
            println("1、打印---$i")
        }
    }

    delay(1300)
    println("2、等等等。。。将要执行取消操作")

    //等价于 { cancel() join() }
    cusJob.cancelAndJoin()

    println("3、程序结束")
}
```

运行结果：

```
1、打印---0
1、打印---1
2、等等等。。。将要执行取消操作
3、程序结束
```


#### (3)、使包含计算代码的协程可以被取消

当协程代码块中包含计算类代码内容时，如果我们想要取消它有两种方案：

* 定期调用挂起函数检查是否可以被取消，可以通过 yield 实现
* 显式的判断协程是否可以被取消，可以通过 CoroutineScope 的 isActive 属性判断。


**使用 isActive :**

```kotlin
fun main() = runBlocking<Unit> {
    val startTime = System.currentTimeMillis()
    val cusJob = launch(Dispatchers.Default) {
        var nextTime = startTime
        var i = 0
        
        // 将 i<5 的条件修改为判断协程是否存活的 isActive
        while (isActive) {
            if (System.currentTimeMillis() >= nextTime) {
                println("1、执行打印---${i++}")
                nextTime += 500
            }
        }
    }

    delay(1300)
    println("2、等等等。。。将要执行取消操作")

    //等价于 { cancel() join() }
    cusJob.cancelAndJoin()

    println("3、程序结束")
}
```

运行结果：

```
1、执行打印---0
1、执行打印---1
1、执行打印---2
2、等等等。。。将要执行取消操作
3、程序结束
```

**使用 yield :** 

```kotlin
fun main() = runBlocking {

    var startTime = System.currentTimeMillis()
    val cusJob = launch {
        var nextTime = startTime
        var i = 0
        while (i < 5) {

            /*
              每执行一次循环先检查协程是否存活，其内部也是检查 isActive,
              如果 job != null && !job.isActive 就会抛出 CancellationException, 然后协程被取消
            */
            yield()

            if (System.currentTimeMillis() > nextTime) {
                println("打印---${i++}")
                nextTime += 500
            }
        }
    }


    delay(1300)

    println("程序将要被取消。。。。")
    
    cusJob.cancelAndJoin()

    println("程序结束")
}
```

运行结果：

```
打印---0
打印---1
打印---2
程序将要被取消。。。。
程序结束
```

#### (4)、在 finally 中释放资源

我们可以在 finally{} 或者 use 函数 中执行一些协程被取消时的操作。（CnPeng 大致等同于 Go 中在 defer 后面需要执行的内容 ）

```kotlin
fun main() = runBlocking<Unit> {
    val cusJob = launch(Dispatchers.Default) {
        try {
            repeat(1000) { i ->
                println("1、执行打印---$i")
                delay(500)
            }
        } finally {
            println("协程被取消了。。。。")
        }
    }

    delay(1300)
    println("2、等等等。。。将要执行取消操作")

    //等价于 { cancel() join() }
    cusJob.cancelAndJoin()

    println("3、程序结束")
}
```

运行结果：

```
1、执行打印---0
1、执行打印---1
1、执行打印---2
2、等等等。。。将要执行取消操作
协程被取消了。。。。
3、程序结束
```

#### (5)、运行不能被取消的代码块

默认情况下，结束协程时在对应的 finally 代码块中不能执行耗时(延时)操作，如：

```kotlin
fun main() = runBlocking<Unit> {
    val cusJob = launch(Dispatchers.Default) {
        try {
            repeat(1000) { i ->
                println("1、执行打印---$i")
                delay(500)
            }
        } finally {
            delay(500)
            println("协程被取消了。。。。")
        }
    }

    delay(1300)
    println("2、等等等。。。将要执行取消操作")

    //等价于 { cancel() join() }
    cusJob.cancelAndJoin()

    println("3、程序结束")
}
```

运行结果：

```
1、执行打印---0
1、执行打印---1
1、执行打印---2
2、等等等。。。将要执行取消操作
3、程序结束
```

上述代码中，在 finally 中模拟了一个耗时 500ms 的操作，然后后续的 println 函数就没有被执行。

那么，如果想让这个 println 函数执行的话该怎么做呢？—— 使用 `withContext(Noncancellable){}`, 示例如下：

```kotlin
fun main() = runBlocking<Unit> {
    val cusJob = launch(Dispatchers.Default) {
        try {
            repeat(1000) { i ->
                println("1、执行打印---$i")
                delay(500)
            }
        } finally {
            withContext(NonCancellable) {
                delay(500)
                println("协程被取消了。。。。")
            }
        }
    }

    delay(1300)
    println("2、等等等。。。将要执行取消操作")

    //等价于 { cancel() join() }
    cusJob.cancelAndJoin()

    println("3、程序结束")
}
```

运行结果：

```
1、执行打印---0
1、执行打印---1
1、执行打印---2
2、等等等。。。将要执行取消操作
协程被取消了。。。。
3、程序结束
```

#### (6)、超时

实际应用中，通常是因为协程的执行超时了才去取消它。在 Kotlin 中我们不需要手动的去计算协程是否执行超时，可以直接通过 `withTimeout(){}` 实现超时处理, 它会抛出 CancellationException 并主动取消协程。

```kotlin
fun main() = runBlocking<Unit> {
    withTimeout(1300) {
        repeat(1000) { i ->
            println("1、执行打印---$i")
            delay(500)
        }
    }
}
```

运行结果：

```
1、执行打印---0
1、执行打印---1
1、执行打印---2
Exception in thread "main" kotlinx.coroutines.TimeoutCancellationException: Timed out waiting for 1300 ms
```

如果我们需要在超时之后做一些额外的处理，则使用 try{} catch{} 将上述代码包裹，并在 catch{} 中做处理即可。

如果我们不想让代码抛出上面的错误，则可以直接使用 `withTimeoutOrNull(){}`

```kotlin
fun main() = runBlocking<Unit> {
    val result = withTimeoutOrNull(1300) {
        repeat(1000) { i ->
            println("1、执行打印---$i")
            delay(500)
        }
    }

    // withTimeoutOrNull(){} 会返回一个 null , 而不是抛出错误
    println(result)
}
```

运行结果：

```
1、执行打印---0
1、执行打印---1
1、执行打印---2
null
```
### 3、通道(实验性)

> 通道目前是实验性质的，后期可能会有变更

[通道](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-channel/index.html) 是数据发送者（SenderChannel）和数据接收者（ReceiveChannel）之间的一种非阻塞的通信方式。

从概念上来说 通道 有些类似于 [BlockingQueue](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/BlockingQueue.html), 但 通道 是非阻塞的并且是可以关闭的。

#### (1)、通道基础

通道中分别使用 send 和 receive 替代了 BlockingQueue 中的 put 和 take

```kotlin
fun main() = runBlocking<Unit> {
	 // 尖括号中的数据类型标识通道所传递的数据类型
    val cusChan = Channel<Int>()

    launch {
        for (x in 1..5) {
            cusChan.send(x)
        }
    }

    repeat(5) {
        println("第 ${cusChan.receive()} 次接收内容")
    }

    println("执行完毕")
}
```

运行结果：

```
第 1 次接收内容
第 2 次接收内容
第 3 次接收内容
第 4 次接收内容
第 5 次接收内容
执行完毕
```

#### (2)、关闭与迭代通道

* 可以通过 close() 关闭通道
* 可以通过 for..in 遍历通道接收到的数据 （CnPeng 这个遍历方式同 Go）

```kotlin
fun main() = runBlocking<Unit> {
    // 泛型的类型为通道中传输数据的类型
    val cusChan = Channel<Int>()

    launch {
        for (x in 1..5) {
            cusChan.send(x)

            //关闭通道
            if (4 == x) cusChan.close()
        }
    }

    //遍历通道接收到的数据
    for (y in cusChan)
        println("通道中的接收到的数据为：$y")

    println("执行完毕")
}
```

运行结果：

```
通道中的接收到的数据为：1
通道中的接收到的数据为：2
通道中的接收到的数据为：3
通道中的接收到的数据为：4
执行完毕
```

#### (3)、构建通道生产者

```kotlin
fun main() = runBlocking<Unit> {
    val squares = produceSquares()

    squares.consumeEach { println(it) }

    println("DONE")
}

// 通过 CoroutineScope 的 produce{} 为 CoroutineScope 扩展一个能够产生 "带有通道的协程" 的函数，并组织通道数据
fun CoroutineScope.produceSquares(): ReceiveChannel<Int> = produce {
    for (x in 1..5) send(x)
}
```

运行结果：

```
1
2
3
4
5
DONE
```

* **CoroutineScope.produce() 的说明信息如下：**

Launches new coroutine to produce a stream of values by sending them to a channel and returns a reference to the coroutine as a [ReceiveChannel]. 

This resulting object can be used to [receive][ReceiveChannel.receive] elements produced by this coroutine.

上述代码内容体现了 生产者--消费者 的模式。

#### (4)、管道

管道是一种能够让协程产生无限数据流的模式。（ A pipeline is a pattern where one coroutine is producing, possibly in􏰂nite, stream of values）。

其他的一个或多个协程去消费这些数据流——根据这些数据流做一些操作或者得到其他的结果。(And another coroutine or coroutines are consuming that stream, doing some processing, and producing some other results)

```kotlin
fun main() = runBlocking<Unit> {
    val numChan = produceNums()
    val squareChan = produceSquares(numChan)

    for (x in 1..5) println("squareChan: ${squareChan.receive()}")

    println("Done")

    // 取消当前协程所在上下文中的全部子协程。因为使用了管道——在协程中无限构建数据流，所以必须显式取消全部子协程
    coroutineContext.cancelChildren()
}


fun CoroutineScope.produceNums() = produce<Int> {
    var x = 1
    // 获取无限数据
    while (true) send(x++)
}

// 通过 CoroutineScope 的 produce{} 为 CoroutineScope 扩展一个能够产生 "带有通道的协程" 的函数，并组织通道数据
fun CoroutineScope.produceSquares(reciceChan: ReceiveChannel<Int>): ReceiveChannel<Int> = produce {
    for (x in reciceChan) send(x * x)
}
```

运行结果：

```
squareChan: 1
squareChan: 4
squareChan: 9
squareChan: 16
squareChan: 25
Done
```

#### (5)、使用管道获取素数

```kotlin
fun main() = runBlocking {
    var chan = getNums(2)

    for (x in 1..10) {
        val primeNum = chan.receive()

        println("$primeNum")

        // 为管道重新赋值
        chan = getPrimeNums(chan, primeNum)
    }

    coroutineContext.cancelChildren()
}

// 管道发送数据
fun CoroutineScope.getNums(start: Int) = produce {
    var i = start
    while (true) {
        send(i++)
    }
}

// 过滤素数——只能被自身除的数
fun CoroutineScope.getPrimeNums(chan: ReceiveChannel<Int>, baseNum: Int) = produce {
    for (x in chan) if (x % baseNum != 0) send(x)
}
```

运行结果：

```
2
3
5
7
11
13
17
19
23
29
```

#### (6)、扇出

扇出 表示一个模块调用其他的多个模块

![](https://images.gitee.com/uploads/images/2019/0305/085648_18b4685a_930142.png "屏幕截图.png")

```kotlin
fun main() = runBlocking {
    // 扇出——1个调多个
    val numChan = produceNums2()
    repeat(5) {
        // 构建五个新的协程
        launchCoroutine(it, numChan)
    }

    delay(1000)

    // 停止发送数据
    numChan.cancel()
}

fun CoroutineScope.produceNums2() = produce {
    var x = 1

    while (true) {
        // 每 100ms 向通道发送一次数据
        send(x++)
        delay(100)
    }
}

fun CoroutineScope.launchCoroutine(id: Int, chan: ReceiveChannel<Int>) = launch {
    for (msg in chan) println("Coroutine 的 id 为：$id, 内容为：$msg")
}
```

运行结果：

```
Coroutine 的 id 为：0, 内容为：1
Coroutine 的 id 为：0, 内容为：2
Coroutine 的 id 为：1, 内容为：3
Coroutine 的 id 为：2, 内容为：4
Coroutine 的 id 为：3, 内容为：5
Coroutine 的 id 为：4, 内容为：6
Coroutine 的 id 为：0, 内容为：7
Coroutine 的 id 为：1, 内容为：8
Coroutine 的 id 为：2, 内容为：9
Coroutine 的 id 为：3, 内容为：10
```

#### (7)、扇入

扇入 表示一个模块被多个模块所调用。扇入高表示复用度高。

> CnPeng 单纯的记扇出扇入的概念很绕，所以，只要记住扇入体现了复用机制就容易多了。

![](https://images.gitee.com/uploads/images/2019/0305/085400_3271203f_930142.png "屏幕截图.png")

```kotlin
fun main() = runBlocking {
    val chan = Channel<String>()

    // 扇入--多个调用一个，体现的是复用机制
    launch { sendStrToChan(chan, "AAAA", 300) }
    launch { sendStrToChan(chan, "BBBB", 500L) }

    repeat(6) {
        println("消息内容：${chan.receive()}--时间：${System.currentTimeMillis()}")
    }

    //关闭全部协程
    coroutineContext.cancelChildren()
}

// 定义挂起函数，延时向指定的通道中传递消息
suspend fun sendStrToChan(chan: SendChannel<String>, msg: String, time: Long) {
    while (true) {
        delay(time)
        chan.send(msg)
    }
}
```

运行结果：

```
消息内容：AAAA--时间：1551750795456
消息内容：BBBB--时间：1551750795654
消息内容：AAAA--时间：1551750795759
消息内容：AAAA--时间：1551750796059
消息内容：BBBB--时间：1551750796156
消息内容：AAAA--时间：1551750796359
```

#### (8)、带缓冲的通道

无缓冲的通道会阻塞读写。（也就是说在使用无缓冲通道时必须有发送方和接收方，只发不收会阻塞，只收不发也会阻塞）

有缓冲的通道只有当缓冲区被写满之后才会进入阻塞状态。

```kotlin
fun main() = runBlocking {
    // 定义容量为 5 数据类型为 Int 的通道
    val chan = Channel<Int>(5)

    repeat(10) {
    	 chan.send(it)
        println(it)
    }
    
    println("程序执行完毕")
}
```

运行结果：

```
0
1
2
3
4
```

因为上述示例中通道没有接收者，所以，当通道中的数据达到容量上限 5 时，就不再执行发送操作，一直处于阻塞状态，程序不会结束。

#### (9)、通道是公平的

当使用多个协程来接收通道中的数据时，通道会按照调用顺序把数据交替的传递给这些协程——这体现了通道的公平性。

Send and receive operations to channels are fair with respect to the order of their invocation from multiple coroutines. They are served in 􏰂first-in 􏰂first-out order, e.g. the 􏰂first coroutine to invoke receive gets the element. In the following example two coroutines "ping" and "pong" are receiving the "ball" object from the shared "table" channel.

```kotlin
data class Ball(var hints: Int)

fun main() = runBlocking {

    val tableChan = Channel<Ball>()

    launch { player(tableChan, "ping") }
    launch { player(tableChan, "pong") }

    //初始发送--发球
    tableChan.send(Ball(0))

    delay(2000)
    coroutineContext.cancelChildren()
}

suspend fun player(tableChan: Channel<Ball>, name: String) {
	 // 这里的遍历操作其实就是接收通道中的数据	
    for (ball in tableChan) {
        println("$name —— $ball")
        ball.hints++

        delay(300)
        tableChan.send(ball)
    }
}
```

运行结果：

```
ping —— Ball(hints=0)
pong —— Ball(hints=1)
ping —— Ball(hints=2)
pong —— Ball(hints=3)
ping —— Ball(hints=4)
pong —— Ball(hints=5)
ping —— Ball(hints=6)
```

上述示例中，名称为 ping 的协程首先启动，所以它会先接收到 ball 。虽然接收到之后直接在 for 循环时触发了 receive() 操作——也就是释放了通道数据，但是由于 pong 已经处于等待接收状态，所以，第二个 ball 会被 pong 接收到。


#### (10)、计时器通道

Ticker channel is a special rendezvous channel that produces Unit every time given delay passes since last consumption from this channel. 

Though it may seem to be useless standalone, it is a useful building block to create complex time-based produce pipelines and operators that do windowing and other time-dependent processing. 

Ticker channel can be used in select to perform "on tick" action.

To create such channel use a factory method `ticker`. To indicate that no further elements are needed use `ReceiveChannel.cancel` method on it.

```kotlin
fun main() = runBlocking<Unit> {

    val tickerChannel = ticker(delayMillis = 100, initialDelayMillis = 0)

    var startTime = System.currentTimeMillis()

    // ticker 会构建一个通道，然后定时发送一个 Kotlin.Unit； 如果 receive() 为null，表示新的数据还没有被发送
    var nextElement = withTimeoutOrNull(1) { tickerChannel.receive() }
    println("${System.currentTimeMillis() - startTime}_ticker 中的数据: $nextElement")


    nextElement = withTimeoutOrNull(50) { tickerChannel.receive() }
    println("${System.currentTimeMillis() - startTime}_ticker 中的数据: $nextElement")

    nextElement = withTimeoutOrNull(60) { tickerChannel.receive() }
    println("${System.currentTimeMillis() - startTime}_ticker 中的数据: $nextElement")

    tickerChannel.cancel()
}
```

运行结果：

```
16_ticker 中的数据: kotlin.Unit
73_ticker 中的数据: null
96_ticker 中的数据: kotlin.Unit
```

Note that ticker is aware of possible consumer pauses and, by default, adjusts next produced element delay if a pause occurs, trying to maintain a 􏰂xed rate of produced elements.

Optionally, a mode parameter equal to TickerMode.FIXED_DELAY can be speci􏰂ed to maintain a 􏰂xed delay between elements.

### 4、组合挂起函数

#### (1)、协程内函数的默认执行顺序

```kotlin
fun main() = runBlocking {

    val time = measureTimeMillis {

        // 默认执行顺序：自上而下
        val value1 = doSthUsefulOne()
        val value2 = doSthUsefulTwo()

        println("$value1+$value2=${value1 + value2}")
    }

    println("运行时间为：$time")
}

suspend fun doSthUsefulOne(): Int {
    delay(1000)
    return 10
}

suspend fun doSthUsefulTwo(): Int {
    delay(1500)
    return 15
}
```

运行结果：

```
10+15=25
运行时间为：2519
```

<h4 id= "使用async实现并发">(2)、使用 async 实现并发</h4>

在前一个示例代码中，如果 doSthUsefulOne() 和 doSthUsefulTwo() 之间没有依赖关系，我们可以使用 async 提升执行速度。

async 类似于 launch 。它启动了一个单独的协程，并与其它协程一起并发运行。

- **launch** : 返回一个不附带任何结果值的 Job ; 
- **async** : 会返回内部代码块的执行结果，这个结果被包装成了 Deferred接口 的一个实现。 Deferred 继承自 Job, 可以通过 Deferred 的 `await()` 获取代码块的执行结果。

```kotlin
fun main() = runBlocking {

    val time = measureTimeMillis {

        // async 异步并发执行
        val one = async { doSthUsefulOne() }
        val two = async { doSthUsefulTwo() }

        println("${one.await()}+${two.await()}=${one.await() + two.await()}")
    }

    println("运行时间为：$time")
}

private suspend fun doSthUsefulOne(): Int {
    delay(1000)
    return 10
}

private suspend fun doSthUsefulTwo(): Int {
    delay(1500)
    return 15
}
```

运行结果

```
10+15=25
运行时间为：1521
```

注意：**需要实现协程并发时，必须通过 async 显式声明**

#### (3)、惰性启动的 async

就是延时启动并发协程。

在使用 async 创建并发协程时为其传递一个 `start = CoroutineStart.LAZY` 参数，这样就可以实现延时启动 —— 当 Deferred 的 `start()` 或 `await()` 被调用时才去启动协程。

```kotlin
fun main() = runBlocking {

    val time = measureTimeMillis {
        val one = async(start = CoroutineStart.LAZY) { doSthUsefulOne() }
        val two = async(start = CoroutineStart.LAZY) { doSthUsefulTwo() }

        //此处可以做一些其他操作，等这些操作完成之后再启动并发协程

        /*
          如果我们注释掉这两个 start()，只保留后面 println 中对 await() 的调用，
          那么并发将会失效，得到的是顺序执行的结果
         */
        one.start()
        two.start()

        println("${two.await()} + ${one.await()} = ${two.await() + one.await()}")
    }
    println("执行时间：$time")
}

private suspend fun doSthUsefulOne(): Int {
    delay(1000)
    return 10
}

private suspend fun doSthUsefulTwo(): Int {
    delay(1500)
    return 15
}
```

运行结果：

```
15 + 10 = 25
执行时间：1522
```

注释掉 start() 之后的运行结果：

```
15 + 10 = 25
执行时间：2526
```

使用挂起函数计算结果时，`async(start=CoroutineStart.LAZY){}` 可以作为 lazy 函数的替代方案。


#### (4)、async 风格的函数

我们可以使用 `GlobalScope.async{}` 显示的构建异步的协程函数。这些函数会返回 Deferred ，并且通常使用 Async 作为函数名的后缀。

注意：

- 这种异步函数并不是 挂起函数（Suspending Functions）.
- 异步函数可以使用在任意位置。但是，在协程外部使用异步函数的时候，我们需要通过 runBlocking{} 等方式阻塞线程以确保 异步函数 执行完成之后才退出程序。

```kotlin
fun main() {

    val time = measureTimeMillis {
        
        // 异步函数可以使用在协程外部
        val one = doSthUsefulOneAsync()
        val two = doSthUsefulTwoAsync()
        
        // 在协程外部使用异步函数时，必须想法保证只有函数执行完毕之后才退出程序
        runBlocking {
            
            // await() 只能在协程内部使用
            println("${one.await()}+${two.await()}=${one.await() + two.await()}")
        }
    }

    println("执行时间：$time")
}


// 定义异步函数，函数名后缀 Async，返回 Deferred
private fun doSthUsefulOneAsync() = GlobalScope.async {
    doSthUsefulOne()
}

private fun doSthUsefulTwoAsync() = GlobalScope.async {
    doSthUsefulTwo()
}

private suspend fun doSthUsefulOne(): Int {
    delay(1000)
    return 10
}

private suspend fun doSthUsefulTwo(): Int {
    delay(1500)
    return 15
}
```

运行结果：

```
10+15=25
执行时间：1583
```

> 上面的示例代码只是为了举一个例子。实际应用中强烈不建议这么写！！（Using this style with Kotlin coroutines is strongly discouraged），原因如下：
> 
> 假设 `val one = somethingUsefulOneAsync()` 和 `one.await()` 在执行过程中发生了一些逻辑性错误，程序会抛出异常并结束。但 `somethingUsefulOneAsync()` 依旧在后台执行，它并没有随着程序的结束而销毁。
> 
> 下一节中 使用 Async 实现的结构化并发 则不会有这种问题。

#### (5)、使用 async 的结构化并发

##### A: 结构化并发

我们把 <a href="使用async实现并发"> (2)、使用async实现并发 </a> 一节中内部的并发代码提取为一个单独的函数。

由于 async 是 CoroutineScope 的一个扩展函数，所以，我们需要为  async 构建一个 CoroutineScope 上下文。而 CoroutineScope 中的 `coroutineScope{}` 就是构建这么一个上下文，并执行其中代码的函数。

```kotlin
suspend fun concurrentSum(): Int = coroutineScope {
    val one = async { doSthUsefulOne() }
    val two = async { doSthUsefulTwo() }

    //此处不需要 return 关键字
    one.await() + two.await()
}

fun main() = runBlocking {
    val time = measureTimeMillis {
        println("${concurrentSum()}")
    }

    println("运行时间：$time")
}

private suspend fun doSthUsefulOne(): Int {
    delay(1000)
    return 10
}

private suspend fun doSthUsefulTwo(): Int {
    delay(1500)
    return 15
}
```

运行结果：

```
25
运行时间：1519
```

在上述代码中，当 concurrentSum() 中发生异常时，异常会被抛出，作用域内部启动的协程也会被取消——cancelled.


##### B: 取消操作在协程中的传递

Cancellation is always propagated(传播) through coroutines hierarchy。

在结构化并发函数中，取消操作是可以被传播的。也就是说，只要取消了其中一个协程，其他协程也会被取消。

* 示例1：

```kotlin
// 由于 main 函数必须返回 Unit, 而 runBlocking 后面不跟泛型时返回的是Int，所以。。。
fun main() = runBlocking<Unit> {
    try {
        failedConcurrentSum()
    } catch (e: ArithmeticException) {
        println("触发 ArithmeticException , 程序结束")
    }
}

suspend fun failedConcurrentSum(): Int = coroutineScope {

    // 此处 async 后面没有跟泛型是因为 能够根据最后一句代码推导出类型
    val one = async {
        try {
            delay(Long.MAX_VALUE)
            10
        } finally {
            println("one 被取消了")
        }
    }

    // 此处我们显示的声明了 async 后面的泛型为 Int
    val two = async<Int> {
        println("Two 将要抛出异常")
        throw ArithmeticException()
    }

    one.await() + two.await()
}
```

运行结果：

```
Two 将要抛出异常
one 被取消了
触发 ArithmeticException , 程序结束
```

* 示例2：

```kotlin
// 由于 main 函数必须返回 Unit, 而 runBlocking 后面不跟泛型时返回的是Int，所以。。。
fun main() = runBlocking<Unit> {
    val time = measureTimeMillis {
        val result = concurrentSum()
        println("运行结果：$result")
    }
    println("程序运行时间：$time")
}

private suspend fun concurrentSum(): Int = coroutineScope {

    // 此处 async 后面没有跟泛型是因为 能够根据最后一句代码推导出类型
    val one = async {
        try {
            delay(2000)
            10
        } finally {
            withContext(NonCancellable) {
                println("one 被取消了")
            }
        }
    }

    // 此处我们显示的声明了 async 后面的泛型为 Int
    val two = async<Int> {
        try {
            delay(1000)
            15
        } finally {
            println("Two 被取消了")
        }
    }

    val result = one.await() + two.await()

    // 此处主动取消 one
    one.cancel()
    result
}
```

运行结果：

```
Two 被取消了
one 被取消了
运行结果：25
程序运行时间：2027
```
### 5、协程上下文与调度

协程运行在以 CoroutineContext 为代表的上下文中，这些上下文定义在 Kotlin 标准库中。

[协程的上下文是由不同元素组成的集合 ，这个集合是 set 和 map 的混合，其中的每个元素都有一个唯一的 key](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/-coroutine-context/)。主要元素的是 Job 和 Dispatcher。

#### (1)、调度器和线程

Dispatcher and Thread , 调度器和线程。

协程上下文中包含一个[协程调度器](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-dispatcher/index.html), 这个调度器决定了协程在执行时需要与哪些或哪个线程进行通信。

协程调度器可以限制协程在线程池中某个指定的线程中运行，也可以取消这种限制。

所有协程构造器（比如：launch 和 async）的 CortoutineContext 参数都是可选的，通过这些参数可以显式的为新协程和 其他上下文元素指定一个 dispatcher.

```kotlin
//此处需要为 runBlocking 指定泛型为 Unit ,否则不能运行
fun main() = runBlocking<Unit> {

    launch {
        println("runBlocking —— 线程名称：${Thread.currentThread().name}")
    }

    launch(Dispatchers.Default) {
        println("Dispatchers.Default —— 线程名称：${Thread.currentThread().name}")
    }


    launch (Dispatchers.Unconfined){
        println("Dispatchers.Unconfined —— 线程名称：${Thread.currentThread().name}")
    }

    launch (newSingleThreadContext("NewThread")){
        println("newSingleThreadContext —— 线程名称：${Thread.currentThread().name}")
    }
}
```

运行结果：

```
Dispatchers.Default —— 线程名称：DefaultDispatcher-worker-1
Dispatchers.Unconfined —— 线程名称：main
newSingleThreadContext —— 线程名称：NewThread
runBlocking —— 线程名称：main
```

- 使用无参的 `launch{}` 时，它使用的是所属协程作用域的上下文。也就是说，它继承并使用了runBlocking{ } 构造出来的协程的上下文，这个上下文位于主线程中。
- Dispatcher.Unconfined 是一个特殊的 dispatcher, 它看起来也是运行在主线程中，但在原理层面来看有一些不同。
- Dispatchers.Default 表示默认的 dispatcher , 在 GlobalScope 中启动协程时使用。它使用了共享的后台线程池。也就说，`launch(Dispatchers.Default){}` 和 `GlobalScope.launch{}` 使用了相同的 dispatcher
- newSingleThreadContext 为协程创建了一个新的线程。专用线程非常消耗资源。实际应用中，这个线程使用完毕后，必须通过 close 释放 ; 或者把它存储在一个在应用中被重复调用的顶级变量中。

#### (2)、受限和非受限调度器

Unconfined vs confined dispatcher

当程序运行到第一个挂起点时（即 触发第一个挂起函数时），Dispatchers.Unconfined 才会在当前线程中启动一个协程。挂起函数开始执行时，dispatcher 会切换到挂起函数所在的线程中。

非受限调度器适用于 不耗时 也 不更新线程中共享数据 的场景。（Uncon􏰂ned dispatcher is appropriate when coroutine does not consume CPU time nor updates any shared data (like UI) that is con􏰂ned to a speci􏰂c thread.）

On the other side, by default, a dispatcher for the outer CoroutineScope is inherited. The default dispatcher for runBlocking coroutine, in particular, is confi􏰂ned to the invoker thread, so inheriting it has the e􏰃ffect of con􏰂fining execution to this thread with a predictable FIFO scheduling.（这一段的大意是说，外层的协程上下文可以被内层协程继承。在哪个线程中调用 runBlocking , runBlocking 默认的 dispatcher 就在哪个线程中。继承 runBlocking 的上下文时也就限定了对应的线程。 )

```kotlin
fun main() = runBlocking<Unit> {

    launch {
        println("—————— ${Thread.currentThread().name}")
        delay(1000)
        println("—————— ${Thread.currentThread().name}")
    }

    launch(Dispatchers.Unconfined) {
        // 初始化在 main 线程
        println("Unconfined—————— ${Thread.currentThread().name}")
        delay(1000)
        // 执行挂起函数后，就切换到了挂起函数运行时所在的线程
        println("Unconfined—————— ${Thread.currentThread().name}")
    }
}
```

运行结果：

```
Unconfined—————— main
—————— main
Unconfined—————— kotlinx.coroutines.DefaultExecutor
—————— main
```

Unconfi􏰂ned dispatcher is an advanced mechanism that can be helpful in certain corner cases where dispatching of coroutine for its execution later is not needed or produces undesirable side-eff􏰃ects, because some operation in a coroutine must be performed right away. Unconfi􏰂ned dispatcher should not be used in general code.(大意是说，在某些特殊场景中 Unconfined dispatcher 很有用，能确保协程正确运行，但是——一般的代码中不要使用 Unconfined dispatcher)


#### (3)、调试协程和线程

> 通过 [官方在线文档](https://kotlinlang.org/docs/reference/coroutines/coroutine-context-and-dispatchers.html) 中的运行按钮可以得到示例中的效果，但是自己通过IDEA 或者 终端时没弄明白该怎么运行才能得到对应的结果。

协程可以在 A 线程中被挂起，然后在 B 线程中被唤醒。即便是拥有专用线程的 dispatcher 也很难确定哪些协程正在运行，也不知道这些协程在什么地方什么时间运行。

在调试应用时，通过 log 把线程信息打印出来是一个比较通用的方法。

在使用协程时，线程的名称并不能提供更多的上下文信息，但是 ，通过`kotlinx.coroutines` 中提供的一些内容可以获知更多的信息。

注意：文档中说，Run the following code with -Dkotlinx.coroutines.debug JVM option ，但是我不知道怎么执行这个命令啊。。。。

```kotlin
fun main() = runBlocking<Unit> {
    val a = async {
        log("I'm computing a piece of the answer") 6
    }
    val b = async {
        log("I'm computing another piece of the answer")
        7
    }
    log("The answer is ${a.await() * b.await()}")
}

fun log(msg: String) = println("[${Thread.currentThread().name}] $msg")
```

文档中说，在 jvm 中通过上述命令运行上面代码后，会得到下面的结果：

```
[main @coroutine#2] I'm computing a piece of the answer
[main @coroutine#3] I'm computing another piece of the answer 
[main @coroutine#1] The answer is 42
```
我都不知道怎么运行的，更不知道怎么得到的结果啊。。。。

算了，调试协程时还是参考一下：[https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-debug/](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-debug/) 吧 

#### (4)、线程间切换

> 这一节 如果使用在线文档中的运行按钮会获取到包含报错信息的运行结果。
> 如果直接使用 IDEA 的中的运行按钮，可以得到不包含报错信息的、没有协程名字的结果。

```kotlin
import kotlinx.coroutines.*

fun log(msg: String) = println("[${Thread.currentThread().name}] $msg")

fun main() {
    newSingleThreadContext("Ctx1").use { ctx1 ->
        newSingleThreadContext("Ctx2").use { ctx2 ->
            runBlocking(ctx1) {
                log("Started in ctx1")
                withContext(ctx2) {
                    log("Working in ctx2")
                }
                log("Back to ctx1")
            }
        }
    }
}
```

使用 `-Dkotlinx.coroutines.debug` JVM option 的运行结果：

```
[Ctx1 @coroutine#1] Started in ctx1
[Ctx2 @coroutine#1] Working in ctx2
[Ctx1 @coroutine#1] Back to ctx1
Exception in thread "main" java.security.AccessControlException: Access control exception due to security reasons in web playground: 
 access denied ("java.lang.RuntimePermission" "modifyThread")
 at FileKt.main (File.kt:-1) 
```

上面的代码中示范了几个新技术：

- 为 runBlocking 显式的指定一个 context
- 使用 withContext 函数改变协程的上下文  （using withContext function to change a context of a coroutine while still staying in the same coroutine ）

注意，上述示例中，当 newSingleThreadContext 新建的线程使用完毕之后，依旧使用了 use 函数去释放线程。

IDEA 中的运行结果：

```
[Ctx1] Started in ctx1
[Ctx2] Working in ctx2
[Ctx1] Back to ctx1
```

#### (5)、上下文中的 Job

协程的 Job 是其上下文的一部分。协程可以通过 `coroutineContext[Job]` 获取其上下文信息

```kotlin
fun main() = runBlocking {
    println("协程上下文的 Job : coroutineContext[Job] =  ${coroutineContext[Job]}")
}
```

运行结果：

```
协程上下文的 Job : coroutineContext[Job] =  BlockingCoroutine{Active}@77a567e1
```

CoroutineScope 的 isActive 属性只是 `coroutineContext[Job]?.isActive == true` 的简写。

#### (6)、子协程

假设在协程 A 的内部通过 CoroutineScope 的 launch 又启动了协程 B ，那么协程 B 会继承协程 A 的上下文（CoroutineScope.coroutineContext），并且协程 B 的 Job 就成了协程 A 的 Job的 子Job (即 B 成了 A 的子协程)。当父协程被取消时，内部子协程也会被取消。

但如果是通过 GlobalScope.launch 在协程 A 中启动新协程 B ，协程 B 不会继承协程 A 的上下文，而是独立的启动和运行。（it is not tied to the scope it was launched from and operates independently.)

```kotlin
fun main() = runBlocking {

    val request = launch {

        launch {
            println("Job1 :——CoroutineScope.launch 子协程")
            delay(1000)
            println("Job1 :——父协程在 1000ms 以内被取消此处将不会被执行")
        }

        GlobalScope.launch {
            println("Job2 :——GlobalScope.launch")
            delay(1000)
            println("Job2 :——当 request 被取消后，此处依旧会被执行 ")
        }
    }

    delay(500)
    println("request : 执行 request.cancel()")
    request.cancel()
    delay(1000)

    println("\n ----------------------- \n")

    val globalJob = GlobalScope.launch {

        launch {
            println("JobA : CoroutineScope.launch")

            delay(1000)
            println("JobA: globalJob 被取消后这里还会执行么？")
        }

        GlobalScope.launch {
            println("JobB : GlobalScope.launch")
            delay(1000)
            println("JobB : globalJob 被取消后，此处依旧会执行")
        }
    }

    delay(500)
    globalJob.cancel()
    println("globalJob : 执行了 globalJob.cancel()")
    delay(1000)
}
```

运行结果：

```
Job2 :——GlobalScope.launch
Job1 :——CoroutineScope.launch 子协程
request : 执行 request.cancel()
Job2 :——当 request 被取消后，此处依旧会被执行 

 ----------------------- 

JobB : GlobalScope.launch
JobA : CoroutineScope.launch
globalJob : 执行了 globalJob.cancel()
JobB : globalJob 被取消后，此处依旧会执行
```

#### (7)、父协程的职责

父协程会等待所有子协程执行结束。并且父协程不需要显示的检查子协程也不需要显示的使用 Job.join() 去等待子协程执行完毕。

(原文：A parent coroutine always waits for completion of all its children. Parent does not have to explicitly track all the children it launches and it does not have to use Job.join to wait for them at the end)

```kotlin
fun main() = runBlocking {
    val parent = launch {

        println("parent: 我内部的子协程不需要显示的 join()")

        repeat(3) { i ->
            launch {
                delay((i + 1) * 1000L)
                println("子协程 $i ：执行完毕")
            }
        }
    }

    parent.join()

    println("parent.join() 的作用是，等待 parent 及其子协程执行完毕后才打印这句话")
}
```

运行结果：

```
parent: 我内部的子协程不需要显示的 join()
子协程 0 ：执行完毕
子协程 1 ：执行完毕
子协程 2 ：执行完毕
parent.join() 的作用是，等待 parent 及其子协程执行完毕后才打印这句话
```


#### (8)、调试时为协程命名

> 运行结果是使用 `-Dkotlinx.coroutines.debug` JVM option 时得到的————我依旧不会用

```kotlin
private fun log(msg: String) = println("[${Thread.currentThread().name}] $msg")

fun main() = runBlocking(CoroutineName("main")) {
    log("Started main coroutine")
    // run two background value computations
    val v1 = async(CoroutineName("v1coroutine")) {
        delay(500)
        log("Computing v1")
        252
    }
    val v2 = async(CoroutineName("v2coroutine")) {
        delay(1000)
        log("Computing v2")
        6
    }
    log("The answer for v1 / v2 = ${v1.await() / v2.await()}")
}
```

文档中的运行结果：

```
[main @main#1] Started main coroutine
[main @v1coroutine#2] Computing v1
[main @v2coroutine#3] Computing v2
[main @main#1] The answer for v1 / v2 = 42
```

#### (9)、上下文中多个元素的组合

有时候我们需要为 coroutine context 定义多个元素，多个元素之间使用 `+` 链接。

比如，我们在启动一个协程时，为它显示的指明 CoroutineName  和 dispatcher

```kotlin
fun main() = runBlocking<Unit> {
    launch(Dispatchers.Default + CoroutineName("FUCK KOTLIN")) {
        println("${Thread.currentThread().name} ")
    }
}
```

在 IDEA 中的运行结果：（不知道怎么启动 调试，所以也就不知道怎么获取协程名字了。。。）

```
DefaultDispatcher-worker-1
```

#### (10)、显示取消

Cancellation via explicit job。

我们把 上下文、子协程、Job 的知识整合一下。

假设我们的应用会有一个生命周期对象，但这个对象不是协程。比如，我们写了一个　Android 程序，并在 Activity 上下文中启动了多个协程，使用这些协程执行诸如 获取和更新数据、执行动画 等异步操作。当 Activity 被销毁的时候为了避免内存溢出，这些协程也需要 cancel().

为了方便管理协程，我们可以把 Job 实例与 Activity 的生命周期关联，这样我们也就能管理协程的生命周期了。也就是说，我们在 Activity 创建的时候创建 Job 实例，在 Activity 销毁的时候销毁 Job实例。示例如下：

```kotlin
class Activity : CoroutineScope {
    lateinit var job: Job

    override val coroutineContext: CoroutineContext
        get() = Dispatchers.Default + job

    fun onCreate() {
        job = Job()
    }

    fun onDestroy() {
        job.cancel()
    }
}
```

上述代码中，我们让 Activity 实现了 CoroutineScope 接口，然后重写 CoroutineScope.coroutineContext 属性，把协程运行时所处的上下文环境作为该属性的值。

接下来，我们就可以在 Activity 中启动协程了——此时，我们不需要再为协程指定上下文了。

```kotlin
fun doSth() {
    repeat(10) { i ->
        launch {
            delay((i + 1) * 200L)
            println("Activity 中的协程执行完毕：$i")
        }
    }
}
```

接下来，我们在 main 函数中创建 activity , 调用 doSth()方法, 500ms 后销毁 activtiy，销毁 activity 后也会取消它内部的所有协程。

完整代码：

```kotlin
class Activity : CoroutineScope {
    lateinit var job: Job

    override val coroutineContext: CoroutineContext
        get() = Dispatchers.Default + job

    fun onCreate() {
        job = Job()
    }

    fun onDestroy() {
        job.cancel()
    }

    fun doSth() {
        repeat(10) { i ->
            launch {
                delay((i + 1) * 200L)
                println("Activity 中的协程：$i")
            }
        }
    }
}

fun main() = runBlocking<Unit> {
    val activity = Activity()
    activity.onCreate()
    activity.doSth()
    delay(500)
    activity.onDestroy()

    // 加这个延时是为了看一下 activity 中是否协程在执行
    delay(1500)
}
```

运行结果：

```
Activity 中的协程：0
Activity 中的协程：1
```

#### (11)、局部线程数据 (Thread-local data)

> 没看明白这东西到底有啥用啊

有时候，可以很方便的传递 thread-local 数据，但对于协程来说，它并没有被局限于某个线程中，所以，如果使用协程实现这种数据传递会比较麻烦。

ThreadLocal 的扩展函数 asContextElement 可以解决上述问题。它创建了一个额外的上下文元素，该元素持有指定的 ThreadLocal 的值，并且每当协程切换上下文时都会存储这个值。

（Sometimes it is convenient to have an ability to pass some thread-local data, but, for coroutines, which are not bound to any particular thread, it is hard to achieve it manually without writing a lot of boilerplate.

For ThreadLocal, asContextElement extension function is here for the rescue. It creates an additional context element, which keeps the value of the given ThreadLocal and restores it every time the coroutine switches its context.）

```koltlin
fun main() = runBlocking<Unit> {
    threadLocal.set("main")

    println("Pre-main    ,  current thread: ${Thread.currentThread()}, thread local value: '${threadLocal.get()}'")

    val job = launch(Dispatchers.Default + threadLocal.asContextElement(value = "launch")) {
        println("Launch start, current thread: ${Thread.currentThread()}, thread local value: '${threadLocal.get()}'")
        yield()
        println("After yield, current thread: ${Thread.currentThread()}, thread local value: '${threadLocal.get()}'")
    }
    job.join()
    println("Post-main  , current thread: ${Thread.currentThread()}, thread local value: '${threadLocal.get()}'")
}
```

IDEA 中的运行结果：

```
Pre-main    , current thread: Thread[main,5,main], thread local value: 'main'
Launch start, current thread: Thread[DefaultDispatcher-worker-1,5,main], thread local value: 'launch'
After yield, current thread: Thread[DefaultDispatcher-worker-1,5,main], thread local value: 'launch'
Post-main  , current thread: Thread[main,5,main], thread local value: 'main'
```

In this example we launch new coroutine in a background thread pool using Dispatchers.Default, so it works on a different threads from a thread pool, but it still has the value of thread local variable, that we've specified using threadLocal.asContextElement(value = "launch"), no matter on what thread the coroutine is executed. 

ThreadLocal has first-class support and can be used with any primitive kotlinx.coroutines provides. It has one key limitation: when thread-local is mutated, a new value is not propagated to the coroutine caller (as context element cannot track all ThreadLocal object accesses) and updated value is lost on the next suspension. Use withContext to update the value of the thread-local in a coroutine, see asContextElement for more details.

Alternatively, a value can be stored in a mutable box like class Counter(var i: Int), which is, in turn, stored in a thread-local variable. However, in this case you are fully responsible to synchronize potentially concurrent modifications to the variable in this mutable box.

For advanced usage, for example for integration with logging MDC, transactional contexts or any other libraries which internally use thread-locals for passing data, see documentation for ThreadContextElement interface that should be implemented.

### 6、异常处理


#### (1)、异常的传播

Exception propagation。

按照对异常的处理方式，协程构建器分为两种：

- `launch` 和 `actor` : 自动处理异常——也就是把异常信息打印到控制台
- `async` 和 `produce` : 可以被用户捕获——捕获之后用户可以自己处理异常

The former treat exceptions as unhandled, similar to Java's `Thread.uncaughtExceptionHandler`, while the latter are relying on the user to consume the final exception, for example via `await` or `receive` (`produce` and `receive` are covered later in Channels section).

##### A: 只构建协程：

- 不论 launch 还是 async 只抛出异常时，异常不会被捕获，不会被处理

```kotlin
fun main() = runBlocking<Unit> {
    val job = GlobalScope.launch {
        println("launch:--------将要抛出异常")
        throw RuntimeException()
    }
    
    val deferred = GlobalScope.async {
        println("async:---------抛出异常")
        throw RuntimeException()
    }
}
```

运行结果：

```
launch:--------将要抛出异常
async:---------抛出异常
```

##### B: 调用 join()

- launch 创建的协程只要调用了 join() 就会获取异常，并打印到控制台
- async 创建的协程单独的调用 join() 并不会获取异常

```kotlin
fun main() = runBlocking<Unit> {
    val job = GlobalScope.launch {
        println("launch:--------将要抛出异常")
        throw RuntimeException()
    }
    job.join()


    val deferred = GlobalScope.async {
        println("async:---------抛出异常")
        throw RuntimeException()
    }
    deferred.join()
}
```

运行结果：

```kotlin
launch:--------将要抛出异常
Exception in thread "DefaultDispatcher-worker-1" java.lang.RuntimeException
	at coroutine.exception.PropagetionKt$main$1$job$1.invokeSuspend(propagetion.kt:19)
	at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:32)
	at kotlinx.coroutines.DispatchedTask.run(Dispatched.kt:233)
	at kotlinx.coroutines.scheduling.CoroutineScheduler.runSafely(CoroutineScheduler.kt:594)
	at kotlinx.coroutines.scheduling.CoroutineScheduler.access$runSafely(CoroutineScheduler.kt:60)
	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.run(CoroutineScheduler.kt:742)
async:---------抛出异常
```  
  
##### C: Deferred 调用 await()  

- launch 创建的协程调用了 join() 后，异常会被打印到控制台
- async 创建的协程调用 await() 后，才会获取异常——默认也是打印到控制台

```kotlin
fun main() = runBlocking<Unit> {
    val job = GlobalScope.launch {
        println("launch:--------将要抛出异常")
        throw RuntimeException()
    }
    job.join()


    val deferred = GlobalScope.async {
        println("async:---------抛出异常")
        throw RuntimeException()
    }
    
    // 只要调用了 await(), 不论是否调用 join 都会获取异常
    // deferred.join()
    deferred.await()
}
```

运行结果：

```kotlin
launch:--------将要抛出异常
Exception in thread "DefaultDispatcher-worker-2" java.lang.RuntimeException
	at coroutine.exception.PropagetionKt$main$1$job$1.invokeSuspend(propagetion.kt:19)
	at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:32)
	at kotlinx.coroutines.DispatchedTask.run(Dispatched.kt:233)
	at kotlinx.coroutines.scheduling.CoroutineScheduler.runSafely(CoroutineScheduler.kt:594)
	at kotlinx.coroutines.scheduling.CoroutineScheduler.access$runSafely(CoroutineScheduler.kt:60)
	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.run(CoroutineScheduler.kt:742)
async:---------抛出异常
Exception in thread "main" java.lang.RuntimeException
	at coroutine.exception.PropagetionKt$main$1$deferred$1.invokeSuspend(propagetion.kt:26)
	at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:32)
	at kotlinx.coroutines.DispatchedTask.run(Dispatched.kt:233)
	at kotlinx.coroutines.scheduling.CoroutineScheduler.runSafely(CoroutineScheduler.kt:594)
	at kotlinx.coroutines.scheduling.CoroutineScheduler.access$runSafely(CoroutineScheduler.kt:60)
	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.run(CoroutineScheduler.kt:742)
```

##### D: try/catch 捕获异常

- launch 中抛出的异常只能打印到控制台，无法被用户捕获。
- async 中抛出的异常只有调用了 await() 才能被捕获

```kotlin
fun main() = runBlocking<Unit> {

    try {
        val job = GlobalScope.launch {
            println("launch:--------将要抛出异常")
            throw RuntimeException()
        }
        job.join()
    } catch (e: Exception) {
        println("launch:---------- 捕捉到异常")
    }


    try {
        val deferred = GlobalScope.async {
            println("async:---------抛出异常")
            throw RuntimeException()
        }

        // 只要调用了 await(), 不论是否调用 join 都会获取异常
        // deferred.join()
        deferred.await()
    } catch (e: Exception) {
        println("async:---------捕获到异常")
    }
}
```

运行结果：

```kotlin
launch:--------将要抛出异常
Exception in thread "DefaultDispatcher-worker-1" java.lang.RuntimeException
	at coroutine.exception.PropagetionKt$main$1$job$1.invokeSuspend(propagetion.kt:21)
	at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:32)
	at kotlinx.coroutines.DispatchedTask.run(Dispatched.kt:233)
	at kotlinx.coroutines.scheduling.CoroutineScheduler.runSafely(CoroutineScheduler.kt:594)
	at kotlinx.coroutines.scheduling.CoroutineScheduler.access$runSafely(CoroutineScheduler.kt:60)
	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.run(CoroutineScheduler.kt:742)
async:---------抛出异常
async:---------捕获到异常
```

上述代码也可以改成下面这个样子，运行结果一样：

```kotlin
fun main() = runBlocking<Unit> {

    try {
        val job = GlobalScope.launch {
            println("launch:--------将要抛出异常")
            throw ArithmeticException()
        }
        job.join()
    } catch (e: Exception) {
        println("launch:---------- 捕捉到异常")
    }

    //---------launch 的异常不能被捕获; async 的异常可以被捕获 --------------

    val deferred = GlobalScope.async {
        println("async:---------抛出异常")
        throw RuntimeException()
    }

    try {
        // 只要调用了 await(), 不论是否调用 join 都会获取异常
        // deferred.join()
        deferred.await()
    } catch (e: Exception) {
        println("async:---------捕获到异常")
    }
}
```

##### E : produce 的异常处理

对于下面 produce 的异常处理代码中，

- 只有调用了 receive(), catch 中才能捕获异常；
- 不论是否调用 receive() , 异常信息都会被打印到控制台。


```kotlin
fun main() = runBlocking<Unit> {

    try {
       val xxx= produce<Unit> {
            println("produce:----------抛出异常")
            throw RuntimeException()
        }

        xxx.receive()
    } catch (e: Exception) {
        println("produce:----------捕获异常")
    }
}
```

运行结果：

```kotlin
produce:----------抛出异常
produce:----------捕获异常
Exception in thread "main" java.lang.RuntimeException
	at coroutine.exception.PropagetionKt$main$1$xxx$1.invokeSuspend(propagetion.kt:47)
	at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:32)
	at kotlinx.coroutines.DispatchedTask.run(Dispatched.kt:233)
	at kotlinx.coroutines.EventLoopImplBase.processNextEvent(EventLoop.kt:116)
	at kotlinx.coroutines.BlockingCoroutine.joinBlocking(Builders.kt:76)
	at kotlinx.coroutines.BuildersKt__BuildersKt.runBlocking(Builders.kt:53)
	at kotlinx.coroutines.BuildersKt.runBlocking(Unknown Source)
	at kotlinx.coroutines.BuildersKt__BuildersKt.runBlocking$default(Builders.kt:35)
	at kotlinx.coroutines.BuildersKt.runBlocking$default(Unknown Source)
	at coroutine.exception.PropagetionKt.main(propagetion.kt:17)
	at coroutine.exception.PropagetionKt.main(propagetion.kt)
```

#### (2)、CoroutineExceptionHandler

`CoroutineExceptionHandler` 是 CoroutineContext.Element 的子接口，可以用来接收协程中异常的处理权限。

只能处理会被协程自动处理的异常 —— 也就是说，只能处理 launch 或 actor 创建的协程中发生的异常。不能处理 async 或者 produce 中的异常

```kotlin
fun main() = runBlocking<Unit> {

    val handler = CoroutineExceptionHandler { _, exception ->
        println("handler : 捕获异常——————$exception")
    }

    GlobalScope.launch(handler) {
        println("launch  : ---------抛出异常")
        throw IndexOutOfBoundsException()
    }

    GlobalScope.actor<Unit>(handler) {
        println("actor   : ---------抛出异常")
        throw NullPointerException()
    }


    // 对 produce 无效
    GlobalScope.produce<Unit>(handler) {
        println("produce : ---------抛出异常")
        throw RuntimeException()
    }

    // CoroutineExceptionHandler 对 async 无效
    GlobalScope.async(handler) {
        println("async   : ---------抛出异常")
        throw ArithmeticException()
    }

    joinAll()
}
```

运行结果：

```
launch  : ---------抛出异常
handler : 捕获异常——————java.lang.IndexOutOfBoundsException
actor   : ---------抛出异常
produce : ---------抛出异常
handler : 捕获异常——————java.lang.NullPointerException
async   : ---------抛出异常
```

#### (3)、取消和异常

Cancellation and exceptions

协程内部通过 `CancellationException` 实现取消。该异常不会被 handler 捕获。

子协程取消时不会影响它的父协程

```kotlin
fun main() = runBlocking<Unit> {

    val job = launch {
        val child = launch {
            try {
                delay(Long.MAX_VALUE)
            } finally {
                println("子协程被取消了")
            }
        }

        yield()
        child.cancel()
        println("取消子协程")

        child.join()

        yield()
        println("父协程中的内容——父协程并没有被取消")
    }

    job.join()
}
```

运行结果：

```
取消子协程
子协程被取消了
父协程中的内容——父协程并没有被取消
```

如果协程中发生了非 `CancellationException` 异常，那么它就会触发父协程的 cancel().

（If a coroutine encounters exception other than CancellationException, it cancels its parent with that exception. This behaviour cannot be overridden and is used to provide stable coroutines hierarchies for structured concurrency which do not depend on CoroutineExceptionHandler implementation. The original exception is handled by the parent when all its children terminate.

This also a reason why, in these examples, CoroutineExceptionHandler is always installed to a coroutine that is created in GlobalScope. It does not make sense to install an exception handler to a coroutine that is launched in the scope of the main runBlocking, since the main coroutine is going to be always cancelled when its child completes with exception despite the installed handler.）

如果协程中包含多个子协程，当其中一个子协程遇到异常时，会触发父协程的 cancle(), 只有当所有子协程都被取消之后，父协程中的 handler 才会接收到异常处理的权限。示例如下： 

```kotlin
fun main() = runBlocking<Unit> {
    val handler = CoroutineExceptionHandler { _, exception ->
        println("Caught $exception")
    }

    val job = GlobalScope.launch(handler) {

        launch {
            // the first child
            try {
                delay(Long.MAX_VALUE)
            } finally {
                withContext(NonCancellable) {
                    println("Children are cancelled, but exception is not handled until all children terminate")
                    delay(100)
                    println("The first child finished its non cancellable block")
                }
            }
        }

        launch {
            // the second child
            delay(10)
            println("Second child throws an exception")
            throw ArithmeticException()
        }
    }

    job.join()
}
```

运行结果：

```
Second child throws an exception
Children are cancelled, but exception is not handled until all children terminate
The first child finished its non cancellable block
Caught java.lang.ArithmeticException
```


#### (4)、异常集合

Exceptions aggregation

如果多个子协程都抛出了异常，通常是先发生的异常会先抛给父协程的 handler。但这样可能会导致丢失异常，比如，协程在它的 `finally` 中抛出了异常。所以，除了第一个异常以外，其他的异常信息被包裹到了 `exception.suppressed` 中。suppressed 是一个异常数组。

One of the solutions would have been to report each exception separately, but then Deferred.await should have had the same mechanism to avoid behavioural inconsistency and this would cause implementation details of a coroutines (whether it had delegated parts of its work to its children or not) to leak to its exception handler.


注意，下列代码只能在支持  suppressed exceptions 的 JDK7+ 版本中生效

```java
fun main() = runBlocking<Unit> {
    val handler = CoroutineExceptionHandler { _, exception ->

        // exception 为第一个被抛出的异常，suppressed 为其他被抛出的异常的数组
        println("第一个异常： $exception ；其他异常的数组： ${exception.suppressed.contentToString()}")

        // 获取其他异常
        val additionalExcep = exception.suppressed
        if (additionalExcep.isNotEmpty()) {
            println("其他异常：${additionalExcep[0]}")
        }
    }

    val job = GlobalScope.launch(handler) {

        launch {
            try {
                delay(Long.MAX_VALUE)
            } finally {
                throw ArithmeticException()
            }
        }

        launch {
            delay(100)
            throw IOException()
        }

        delay(Long.MAX_VALUE)
    }
    job.join()
}
```

运行结果：

```java
第一个异常： java.io.IOException ；其他异常的数组： [java.lang.ArithmeticException]
其他异常：java.lang.ArithmeticException
```

子协程的 CancellationException 不会被传递给父协程的 handler。示例如下：

```kotlin
fun main() = runBlocking<Unit> {
    val handler = CoroutineExceptionHandler { _, exception ->
        println("捕获第一个异常： $exception ; 其他附加异常： ${exception.suppressed.contentToString()}")
    }

    val job = GlobalScope.launch(handler) {

        val inner = launch {
            launch {
                launch {
                    println("抛出第一个异常——IOException")
                    throw IOException()
                }
            }
        }

        try {
            inner.join()
        } catch (e: CancellationException) {
            println("CancellationException 不会被交给 handler")
            throw e
        }
    }
    job.join()
}
```

运行结果：

```
抛出第一个异常——IOException
CancellationException 不会被交给 handler
捕获第一个异常： java.io.IOException ; 其他附加异常： []
```


### 7、监督

Supervision 监督、管理、监管

正如我们前面所学，在协程的层级（父子协程）内部，取消操作是双向的 (bidirectional)。如果需要单向的 (unidirectional) 取消该怎么操作呢？ 

Good example of such requirement can be a UI component with the job defined in its scope. If any of UI's child task has failed, it is not always necessary to cancel (effectively kill) the whole UI component, but if UI component is destroyed (and its job is cancelled), then it is necessary to fail all children jobs as their result is no longer required.

Another example is a server process that spawns several children jobs and needs to supervise their execution, tracking their failures and restarting just those children jobs that had failed.

#### (1)、SupervisionJob

通过 SupervisionJob 可以实现单向取消。

SupervisionJob 和普通的 Job 很相似。但它的取消操作只能向下传播。

```kotlin
fun main() = runBlocking<Unit> {

    val supervisor = SupervisorJob()

    with(CoroutineScope(coroutineContext + supervisor)) {
        // launch the first child -- its exception is ignored for this example (don't do this in practice!)
        val firstChild = launch(CoroutineExceptionHandler { _, _ ->  }) {
            println("firstChild  :-------抛出异常")
            throw AssertionError("First child is cancelled")
        }

        val secondChild = launch {
            firstChild.join()
            // firstChild 的异常没有触发父协程的 cancel()， 所以，secondChild 也不会被取消。
            println("secondChild :-------firstChild 被取消了？: ${firstChild.isCancelled},------- secondChild 依旧在运行")
            try {
                delay(Long.MAX_VALUE)
            } finally {
                // But cancellation of the supervisor is propagated
                println("secondChild :-------Surpervision 被取消，取消事件向下传递，所以 secondChild 也被取消了")
            }
        }

        // wait until the first child fails & completes
        firstChild.join()
        println("父协程       :-------Cancelling supervisor")

        // firstChild 抛出的异常没有触发父协程的 cancel(), 所以此处手动触发
        supervisor.cancel()
        secondChild.join()
    }
}
```

运行结果：

```
firstChild  :-----抛出异常
secondChild :-----firstChild 被取消了？: true,----- secondChild 依旧在运行
父协程       :-----Cancelling supervisor
secondChild :-----Surpervision 被取消，取消事件向下传递，所以 secondChild 也被取消了
```

#### (2)、supervisorScope

`supervisorScope` 可以替代 `coroutineScope` 实现作用域内的协程并发. 

- `supervisorScope` 中取消事件是单向、向下传播的
- `supervisorScope` 本身发生异常时会取消所有的子协程
- 也会等待所有子协程执行完毕

##### A: 取消事件单向传递

```kotlin
fun main() = runBlocking<Unit> {
    try {
        supervisorScope {

            val child = launch {
                try {
                    println("Child is sleeping")
                    delay(Long.MAX_VALUE)
                } finally {
                    println("Child is cancelled")
                }
            }

            // Give our child a chance to execute and print using yield
            yield()
            
            println("Throwing exception from scope")
            throw AssertionError()
        }
    } catch (e: AssertionError) {
        println("Caught assertion error")
    }
}
```

运行结果：

```
Child is sleeping
Throwing exception from scope
Child is cancelled
Caught assertion error
```

##### B: 内部的并发

```kotlin
fun main() = runBlocking<Unit> {
    supervisorScope {

        val time = measureTimeMillis {
            val first = async {
                delay(500)
                5
            }

            val second = async {
                delay(1000)
                10
            }
            // Give our child a chance to execute and print using yield
            println("${first.await()} +${first.await()} = ${first.await() + second.await()}")
        }

        println("执行时间：$time")
    }
}
```

运行结果：

```
5 +5 = 15
执行时间：1016
```

#### (3)、Exceptions in supervised coroutines

Every child should handle its exceptions by itself via exception handling mechanisms. This difference comes from the fact that child's failure is not propagated to the parent.

SurpervisionJob 和普通 Job 的另一个重大区别是对于异常的处理。

- SurpervisionJob 的子协程的异常需要由子协程自己处理。之所以这样是因为 surpervisroScope 中子协程的异常无法传播给父协程——surpervisorJob


```kotlin
fun main() = runBlocking {
    val handler = CoroutineExceptionHandler { _, exception ->
        println("异常被捕获：$exception")
    }

    supervisorScope {
        val child = launch(handler) {
            println("child:----抛出异常")
            throw RuntimeException()
        }

        yield()
        println("supervisorScope: ---- 内部的代码执行完毕")
    }

    println("runBlocking:---- supervisorScope 执行完毕")
}
```

运行结果：

```
child:----抛出异常
异常被捕获：java.lang.RuntimeException
supervisorScope: ---- 内部的代码执行完毕
runBlocking:---- supervisorScope 执行完毕
```

### 8、select 表达式(实验性的)
#### (1)、
#### (2)、
#### (3)、
#### (4)、
#### (5)、
#### (6)、
#### (7)、
#### (8)、
#### (9)、
#### (10)、

### 9、Shared mutable state and concurrency

使用 multi-threaded dispatcher (如 Dispatchers.Default) 可以实现协程的并发，并发就必然会存在数据同步的问题。

#### (1)、问题

下面的示例代码中，我们将创建 100个 协程，每个协程重复执行单一的事件1000次。并且获取最终的执行时长和执行结果。

```kotlin

```

#### (2)、
#### (3)、
#### (4)、
#### (5)、
#### (6)、
#### (7)、
#### (8)、
#### (9)、
#### (10)、
