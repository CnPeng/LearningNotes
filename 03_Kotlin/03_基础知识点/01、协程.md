基于 Kotlin 官方文档整理和总结

* 需要先了解的知识：协程和线程的区别
* 挂起和阻塞

---


## 十二、协程

### 1、协程基础

在开始编码前，先新建 Gradle 项目，然后引用 `kotlinx.coroutines` 包。

![](https://images.gitee.com/uploads/images/2019/0304/103537_373787f0_930142.png "屏幕截图.png")

![](https://images.gitee.com/uploads/images/2019/0304/103615_abe391fe_930142.png "屏幕截图.png")

![](https://images.gitee.com/uploads/images/2019/0304/103706_68c306b1_930142.png "屏幕截图.png")

![](https://images.gitee.com/uploads/images/2019/0304/103811_b3be5865_930142.png "屏幕截图.png")

![](https://images.gitee.com/uploads/images/2019/0304/104047_7d4e0e8a_930142.png "屏幕截图.png")

[点击查看官方关于 引入 kotlinx.coroutines 包的参考](https://github.com/hltj/kotlinx.coroutines-cn/blob/master/README.md#using-in-your-projects)

#### (1)、第一个协程程序

```kotlin
import kotlinx.coroutines.GlobalScope
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch

fun main() {
    // 开启协程
    GlobalScope.launch {
        delay(1000L)
        println("Kotlin")
    }

    println("Hello")
    //这个延时是为了保证协程中的程序一定能被执行，防止出现协程中的内容未执行，程序就退出的情况
    Thread.sleep(2000L)
}
```

运行结果：

```
Hello
Kotlin
```

上述代码会先打印 Hello, 然后 1秒 后打印 Kotlin，再过 1秒后程序结束。

* 协程本质上是一个轻量级的线程。
* ` GlobalScope.launch{ }` 用来启动一个新的协程
* `delay()` 是一个挂起协程的操作，不会造成对应线程的阻塞。只能在 协程 或 挂起函数 中使用
* ` Thread.sleep()` 是一个阻塞线程的操作

#### (2)、runBlocking{ }

```kotlin
fun main() {
    // 开启协程
    GlobalScope.launch {
        delay(1000L)
        println("Kotlin")
    }

    println("Hello")
    
    runBlocking {
        delay(2000L)
    }
}
```

运行结果和前面的结果一致。

* `runBlocking{ }` 表示在当前线程中开启一个新的协程并阻塞当前线程，直到协程中的内容执行完毕才会释放线程。
* `runBlocking{ }` 只能在协程外部使用。它是被挂起的代码块和主函数之间的桥梁


我们在 前面的两个示例中分别使用了 Thread.sleep() 和 runBlocking{ } ，他们的目的都是为了延长线程的生命周期，防止协程中的内容还没有执行程序就退出了——如果把这两个函数中的延时去除，那么，新建协程中的内容将不会执行，也就说，不会打印 Kotlin.

上述代码还可以简化为如下：

```kotlin
fun main()= runBlocking {
    GlobalScope.launch {
        delay(1000L)
        println("Kotlin")
    }

    println("Hello")
    delay(2000L)
}
```

#### (3)、协程中的 join()

实际应用中，我们无法准确获取到一段代码的执行时间，所以，前面使用 delay(2000) 延时的方式并不实用。此时就需要使用 Job 中的 join(), 它的作用是挂起协程，直到其中的内容执行完毕。

```kotlin
fun main() = runBlocking {

    val jobCoroutine = GlobalScope.launch {
        delay(1000L)
        println("Kotlin")
    }

    println("Hello")

    // join() 的作用是挂起协程，并保证其能完整执行。
    jobCoroutine.join()
}
```

上面的示例代码中，join() 把 runBlocking() 构建的主协程挂起，当主协程中的 jobCoroutine 子协程执行完毕之后才关闭主协程。

* join() 只能在协程内部使用


#### (4)、结构化并发--runBlocking{} 内嵌套协程

上一节中创建了 jobCoroutine 之后，我们手动调用了 join() 。但实际上我们在 runBlocking{ } 构建的协程中再创建协程时，我们完全可以省略 join。

```kotlin
fun main() = runBlocking {
    launch {
        delay(1000L)
        println("Kotlin")
    }

    println("Hello")
}
```

#### (5)、作用域构建器--coroutineScope{}

```kotlin
fun main() = runBlocking {
    // GlobalScope.launch 和 join() 的简写形式
    launch {
        println("BBBBBBBBBB")
    }

    coroutineScope {
        launch {
            println("DDDDDDDDDd")
        }
			
		 // 此处不需要等待 协程执行完毕就可以直接执行
        println("CCCCCCCCCCCC")
    }

	// 等待前两个协程执行完毕后才执行这里
    println("AAAAAAAAAAA")
}
```

运行结果：

```
CCCCCCCCCCCC
BBBBBBBBBB
DDDDDDDDDd
AAAAAAAAAAA
```

* coroutineScope{ } 构建一个新的协程作用域，如果其中包含子协程，子协程不会阻塞所在线程。

#### (6)、挂起函数修饰符--suspend

```kotlin
fun main() = runBlocking {
    launch {
        delay(1000L)
        println("BBBBBBBBBB")
    }

    println("AAAAAAAAAAA")
}
```

当我们我们使用 IDEA 的快捷键把上面示例中 launch{} 内部的代码内容提取成方法时，会得到如下内容：

```kotlin
fun main() = runBlocking {
    launch {
        cusPrint()
    }

    println("AAAAAAAAAAA")
}

private suspend fun cusPrint() {
    delay(1000L)
    println("BBBBBBBBBB")
}
```

我们提取出来的函数被关键字 suspend 修饰，表示这是一个挂起函数。


#### (7)、协程是轻量的

```kotlin
fun main() = runBlocking {

    // 重复开启 100W 个线程时，不会爆出内存不足之类的错误
    repeat(100_0000) {
        launch {
            delay(100)
            println(".")
        }
    }

    // 如果重复开启 100W 个线程，可能会爆出内存不足之类的错误
    // repeat(100_0000) {
    //     Thread {
    //         Thread.sleep(100)
    //         println(".")
    //     }.start()
    // }
}
```

上述示例代码中我们分别创建了 100W 个协程和线程。在创建协程的时候计算机没有任何压力；但在创建线程的时候，CPU 风扇快速旋转，噪音增大——这是就内存和CPU消耗较大的表现。当前电脑配置为 MacPro I7 + 16G , 如果配置再低一些的话在创建线程时可能就会爆出内存不足或者卡死等现象了。


#### (8)、全局协程类似守护线程

```kotlin
fun main() = runBlocking<Unit> {

    GlobalScope.launch {
        repeat(1000) { i ->
            println("这是第 $i 次打印")
            delay(500)
        }
    }

    delay(1300)
}
```

上述代码中通过 delay(1300) 延长了 GlobalScope.launch 新建协程的生命周期，但这种方式并不能保证协程所在进程一直存活，它更像是守护线程。

### 2、取消与超时

#### (1)、取消协程的执行

launch{} 启动协程之后会返回一个 Job 对象，当我们在某些场景下需要手动的取消协程时，就可以调用 Job 的 cancel().

在两种情况下协程可以被取消：

- 主动调用 cancel()
- 遇见 CancellationException

```kotlin
fun main() = runBlocking<Unit> {

    val cusJob = launch {
        // 每 500 毫秒打印一次，总共打印 10 次
        repeat(5) { i ->
            delay(500)
            println("1、500 毫秒执行一次打印：$i")
        }
    }

    delay(1100)
    // 取消协程
    cusJob.cancel()
    println("2、取消协程的执行")

    // 加入 join() 后，就成了一个阻塞操作，只有对应协程中的内容执行完毕或取消后才会执行后面的内容
    cusJob.join()

    println("3、AAAAAA")
}
```

运行结果：

```
1、500 毫秒执行一次打印：0
1、500 毫秒执行一次打印：1
2、取消协程的执行
3、AAAAAA
```

如果把 cusJob.join() 注释掉，那么就会先打印 `3、AAAAAA`

#### (2)、取消是协作的

也就是说，只有当协程内部的所有操作都是可以取消的，协程才能被取消。

如果协程内部正在执行计算类或其他无法被取消的任务，这个协程是无法被取消的，如下：

```kotlin
fun main() = runBlocking<Unit> {

    val startTime = System.currentTimeMillis()

    val cusJob = launch(Dispatchers.Default) {
        var nextTime = startTime
        var i = 0
        while (i < 5) {
            if (System.currentTimeMillis() > nextTime) {
                println("1、正在睡觉。。。${i++}")
                nextTime += 500
            }
        }
    }

    delay(1300)
    println("2、等等等。。。将要执行取消操作")

    //等价于 { cancel() join() }
    cusJob.cancelAndJoin()

    println("3、程序结束")
}
```

运行结果：

```
1、正在睡觉。。。0
1、正在睡觉。。。1
1、正在睡觉。。。2
2、等等等。。。将要执行取消操作
1、正在睡觉。。。3
1、正在睡觉。。。4
3、程序结束
```

上述示例代码中，虽然触发了 cancelAndJoin() , 但由于协程代码块中有计算操作——结束条件是一个计算表达式 i<5 ，所以没有被 cancel , 而是继续执行直到程序正常结束。

而对于下面的这个代码，由于协程中并没有计算类型的代码块，所以，可以直接被取消。

```kotlin
fun main() = runBlocking<Unit> {

    val cusJob = launch(Dispatchers.Default) {
        repeat(5) { i ->
            delay(500)
            println("1、打印---$i")
        }
    }

    delay(1300)
    println("2、等等等。。。将要执行取消操作")

    //等价于 { cancel() join() }
    cusJob.cancelAndJoin()

    println("3、程序结束")
}
```

运行结果：

```
1、打印---0
1、打印---1
2、等等等。。。将要执行取消操作
3、程序结束
```


#### (3)、使包含计算代码的协程可以被取消

当协程代码块中包含计算类代码内容时，如果我们想要取消它有两种方案：

* 定期调用挂起函数检查是否可以被取消，可以通过 yield 实现
* 显式的判断协程是否可以被取消，可以通过 CoroutineScope 的 isActive 属性判断。


**使用 isActive :**

```kotlin
fun main() = runBlocking<Unit> {
    val startTime = System.currentTimeMillis()
    val cusJob = launch(Dispatchers.Default) {
        var nextTime = startTime
        var i = 0
        
        // 将 i<5 的条件修改为判断协程是否存活的 isActive
        while (isActive) {
            if (System.currentTimeMillis() >= nextTime) {
                println("1、执行打印---${i++}")
                nextTime += 500
            }
        }
    }

    delay(1300)
    println("2、等等等。。。将要执行取消操作")

    //等价于 { cancel() join() }
    cusJob.cancelAndJoin()

    println("3、程序结束")
}
```

运行结果：

```
1、执行打印---0
1、执行打印---1
1、执行打印---2
2、等等等。。。将要执行取消操作
3、程序结束
```

**使用 yield :** 

```kotlin
fun main() = runBlocking {

    var startTime = System.currentTimeMillis()
    val cusJob = launch {
        var nextTime = startTime
        var i = 0
        while (i < 5) {

            /*
              每执行一次循环先检查协程是否存活，其内部也是检查 isActive,
              如果 job != null && !job.isActive 就会抛出 CancellationException, 然后协程被取消
            */
            yield()

            if (System.currentTimeMillis() > nextTime) {
                println("打印---${i++}")
                nextTime += 500
            }
        }
    }


    delay(1300)

    println("程序将要被取消。。。。")
    
    cusJob.cancelAndJoin()

    println("程序结束")
}
```

运行结果：

```
打印---0
打印---1
打印---2
程序将要被取消。。。。
程序结束
```

#### (4)、在 finally 中释放资源

我们可以在 finally{} 或者 use 函数 中执行一些协程被取消时的操作。（CnPeng 大致等同于 Go 中在 defer 后面需要执行的内容 ）

```kotlin
fun main() = runBlocking<Unit> {
    val cusJob = launch(Dispatchers.Default) {
        try {
            repeat(1000) { i ->
                println("1、执行打印---$i")
                delay(500)
            }
        } finally {
            println("协程被取消了。。。。")
        }
    }

    delay(1300)
    println("2、等等等。。。将要执行取消操作")

    //等价于 { cancel() join() }
    cusJob.cancelAndJoin()

    println("3、程序结束")
}
```

运行结果：

```
1、执行打印---0
1、执行打印---1
1、执行打印---2
2、等等等。。。将要执行取消操作
协程被取消了。。。。
3、程序结束
```

#### (5)、运行不能被取消的代码块

默认情况下，结束协程时在对应的 finally 代码块中不能执行耗时(延时)操作，如：

```kotlin
fun main() = runBlocking<Unit> {
    val cusJob = launch(Dispatchers.Default) {
        try {
            repeat(1000) { i ->
                println("1、执行打印---$i")
                delay(500)
            }
        } finally {
            delay(500)
            println("协程被取消了。。。。")
        }
    }

    delay(1300)
    println("2、等等等。。。将要执行取消操作")

    //等价于 { cancel() join() }
    cusJob.cancelAndJoin()

    println("3、程序结束")
}
```

运行结果：

```
1、执行打印---0
1、执行打印---1
1、执行打印---2
2、等等等。。。将要执行取消操作
3、程序结束
```

上述代码中，在 finally 中模拟了一个耗时 500ms 的操作，然后后续的 println 函数就没有被执行。

那么，如果想让这个 println 函数执行的话该怎么做呢？—— 使用 `withContext(Noncancellable){}`, 示例如下：

```kotlin
fun main() = runBlocking<Unit> {
    val cusJob = launch(Dispatchers.Default) {
        try {
            repeat(1000) { i ->
                println("1、执行打印---$i")
                delay(500)
            }
        } finally {
            withContext(NonCancellable) {
                delay(500)
                println("协程被取消了。。。。")
            }
        }
    }

    delay(1300)
    println("2、等等等。。。将要执行取消操作")

    //等价于 { cancel() join() }
    cusJob.cancelAndJoin()

    println("3、程序结束")
}
```

运行结果：

```
1、执行打印---0
1、执行打印---1
1、执行打印---2
2、等等等。。。将要执行取消操作
协程被取消了。。。。
3、程序结束
```

#### (6)、超时

实际应用中，通常是因为协程的执行超时了才去取消它。在 Kotlin 中我们不需要手动的去计算协程是否执行超时，可以直接通过 `withTimeout(){}` 实现超时处理, 它会抛出 CancellationException 并主动取消协程。

```kotlin
fun main() = runBlocking<Unit> {
    withTimeout(1300) {
        repeat(1000) { i ->
            println("1、执行打印---$i")
            delay(500)
        }
    }
}
```

运行结果：

```
1、执行打印---0
1、执行打印---1
1、执行打印---2
Exception in thread "main" kotlinx.coroutines.TimeoutCancellationException: Timed out waiting for 1300 ms
```

如果我们需要在超时之后做一些额外的处理，则使用 try{} catch{} 将上述代码包裹，并在 catch{} 中做处理即可。

如果我们不想让代码抛出上面的错误，则可以直接使用 `withTimeoutOrNull(){}`

```kotlin
fun main() = runBlocking<Unit> {
    val result = withTimeoutOrNull(1300) {
        repeat(1000) { i ->
            println("1、执行打印---$i")
            delay(500)
        }
    }

    // withTimeoutOrNull(){} 会返回一个 null , 而不是抛出错误
    println(result)
}
```

运行结果：

```
1、执行打印---0
1、执行打印---1
1、执行打印---2
null
```
### 3、通道(实验性)

> 通道目前是实验性质的，后期可能会有变更

[通道](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-channel/index.html) 是数据发送者（SenderChannel）和数据接收者（ReceiveChannel）之间的一种非阻塞的通信方式。

从概念上来说 通道 有些类似于 [BlockingQueue](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/BlockingQueue.html), 但 通道 是非阻塞的并且是可以关闭的。

#### (1)、通道基础

通道中分别使用 send 和 receive 替代了 BlockingQueue 中的 put 和 take

```kotlin
fun main() = runBlocking<Unit> {
	 // 尖括号中的数据类型标识通道所传递的数据类型
    val cusChan = Channel<Int>()

    launch {
        for (x in 1..5) {
            cusChan.send(x)
        }
    }

    repeat(5) {
        println("第 ${cusChan.receive()} 次接收内容")
    }

    println("执行完毕")
}
```

运行结果：

```
第 1 次接收内容
第 2 次接收内容
第 3 次接收内容
第 4 次接收内容
第 5 次接收内容
执行完毕
```

#### (2)、关闭与迭代通道

* 可以通过 close() 关闭通道
* 可以通过 for..in 遍历通道接收到的数据 （CnPeng 这个遍历方式同 Go）

```kotlin
fun main() = runBlocking<Unit> {
    // 泛型的类型为通道中传输数据的类型
    val cusChan = Channel<Int>()

    launch {
        for (x in 1..5) {
            cusChan.send(x)

            //关闭通道
            if (4 == x) cusChan.close()
        }
    }

    //遍历通道接收到的数据
    for (y in cusChan)
        println("通道中的接收到的数据为：$y")

    println("执行完毕")
}
```

运行结果：

```
通道中的接收到的数据为：1
通道中的接收到的数据为：2
通道中的接收到的数据为：3
通道中的接收到的数据为：4
执行完毕
```

#### (3)、构建通道生产者

```kotlin
fun main() = runBlocking<Unit> {
    val squares = produceSquares()

    squares.consumeEach { println(it) }

    println("DONE")
}

// 通过 CoroutineScope 的 produce{} 为 CoroutineScope 扩展一个能够产生 "带有通道的协程" 的函数，并组织通道数据
fun CoroutineScope.produceSquares(): ReceiveChannel<Int> = produce {
    for (x in 1..5) send(x)
}
```

运行结果：

```
1
2
3
4
5
DONE
```

* **CoroutineScope.produce() 的说明信息如下：**

Launches new coroutine to produce a stream of values by sending them to a channel and returns a reference to the coroutine as a [ReceiveChannel]. 

This resulting object can be used to [receive][ReceiveChannel.receive] elements produced by this coroutine.

上述代码内容体现了 生产者--消费者 的模式。

#### (4)、管道

管道是一种能够让协程产生无限数据流的模式。（ A pipeline is a pattern where one coroutine is producing, possibly in􏰂nite, stream of values）。

其他的一个或多个协程去消费这些数据流——根据这些数据流做一些操作或者得到其他的结果。(And another coroutine or coroutines are consuming that stream, doing some processing, and producing some other results)

```kotlin
fun main() = runBlocking<Unit> {
    val numChan = produceNums()
    val squareChan = produceSquares(numChan)

    for (x in 1..5) println("squareChan: ${squareChan.receive()}")

    println("Done")

    // 取消当前协程所在上下文中的全部子协程。因为使用了管道——在协程中无限构建数据流，所以必须显式取消全部子协程
    coroutineContext.cancelChildren()
}


fun CoroutineScope.produceNums() = produce<Int> {
    var x = 1
    // 获取无限数据
    while (true) send(x++)
}

// 通过 CoroutineScope 的 produce{} 为 CoroutineScope 扩展一个能够产生 "带有通道的协程" 的函数，并组织通道数据
fun CoroutineScope.produceSquares(reciceChan: ReceiveChannel<Int>): ReceiveChannel<Int> = produce {
    for (x in reciceChan) send(x * x)
}
```

运行结果：

```
squareChan: 1
squareChan: 4
squareChan: 9
squareChan: 16
squareChan: 25
Done
```

#### (5)、使用管道获取素数

```kotlin
fun main() = runBlocking {
    var chan = getNums(2)

    for (x in 1..10) {
        val primeNum = chan.receive()

        println("$primeNum")

        // 为管道重新赋值
        chan = getPrimeNums(chan, primeNum)
    }

    coroutineContext.cancelChildren()
}

// 管道发送数据
fun CoroutineScope.getNums(start: Int) = produce {
    var i = start
    while (true) {
        send(i++)
    }
}

// 过滤素数——只能被自身除的数
fun CoroutineScope.getPrimeNums(chan: ReceiveChannel<Int>, baseNum: Int) = produce {
    for (x in chan) if (x % baseNum != 0) send(x)
}
```

运行结果：

```
2
3
5
7
11
13
17
19
23
29
```

#### (6)、扇出

扇出 表示一个模块调用其他的多个模块

![](https://images.gitee.com/uploads/images/2019/0305/085648_18b4685a_930142.png "屏幕截图.png")

```kotlin
fun main() = runBlocking {
    // 扇出——1个调多个
    val numChan = produceNums2()
    repeat(5) {
        // 构建五个新的协程
        launchCoroutine(it, numChan)
    }

    delay(1000)

    // 停止发送数据
    numChan.cancel()
}

fun CoroutineScope.produceNums2() = produce {
    var x = 1

    while (true) {
        // 每 100ms 向通道发送一次数据
        send(x++)
        delay(100)
    }
}

fun CoroutineScope.launchCoroutine(id: Int, chan: ReceiveChannel<Int>) = launch {
    for (msg in chan) println("Coroutine 的 id 为：$id, 内容为：$msg")
}
```

运行结果：

```
Coroutine 的 id 为：0, 内容为：1
Coroutine 的 id 为：0, 内容为：2
Coroutine 的 id 为：1, 内容为：3
Coroutine 的 id 为：2, 内容为：4
Coroutine 的 id 为：3, 内容为：5
Coroutine 的 id 为：4, 内容为：6
Coroutine 的 id 为：0, 内容为：7
Coroutine 的 id 为：1, 内容为：8
Coroutine 的 id 为：2, 内容为：9
Coroutine 的 id 为：3, 内容为：10
```

#### (7)、扇入

扇入 表示一个模块被多个模块所调用。扇入高表示复用度高。

> CnPeng 单纯的记扇出扇入的概念很绕，所以，只要记住扇入体现了复用机制就容易多了。

![](https://images.gitee.com/uploads/images/2019/0305/085400_3271203f_930142.png "屏幕截图.png")

```kotlin
fun main() = runBlocking {
    val chan = Channel<String>()

    // 扇入--多个调用一个，体现的是复用机制
    launch { sendStrToChan(chan, "AAAA", 300) }
    launch { sendStrToChan(chan, "BBBB", 500L) }

    repeat(6) {
        println("消息内容：${chan.receive()}--时间：${System.currentTimeMillis()}")
    }

    //关闭全部协程
    coroutineContext.cancelChildren()
}

// 定义挂起函数，延时向指定的通道中传递消息
suspend fun sendStrToChan(chan: SendChannel<String>, msg: String, time: Long) {
    while (true) {
        delay(time)
        chan.send(msg)
    }
}
```

运行结果：

```
消息内容：AAAA--时间：1551750795456
消息内容：BBBB--时间：1551750795654
消息内容：AAAA--时间：1551750795759
消息内容：AAAA--时间：1551750796059
消息内容：BBBB--时间：1551750796156
消息内容：AAAA--时间：1551750796359
```

#### (8)、带缓冲的通道

无缓冲的通道会阻塞读写。（也就是说在使用无缓冲通道时必须有发送方和接收方，只发不收会阻塞，只收不发也会阻塞）

有缓冲的通道只有当缓冲区被写满之后才会进入阻塞状态。

```kotlin
fun main() = runBlocking {
    // 定义容量为 5 数据类型为 Int 的通道
    val chan = Channel<Int>(5)

    repeat(10) {
    	 chan.send(it)
        println(it)
    }
    
    println("程序执行完毕")
}
```

运行结果：

```
0
1
2
3
4
```

因为上述示例中通道没有接收者，所以，当通道中的数据达到容量上限 5 时，就不再执行发送操作，一直处于阻塞状态，程序不会结束。

#### (9)、通道是公平的

当使用多个协程来接收通道中的数据时，通道会按照调用顺序把数据交替的传递给这些协程——这体现了通道的公平性。

Send and receive operations to channels are fair with respect to the order of their invocation from multiple coroutines. They are served in 􏰂first-in 􏰂first-out order, e.g. the 􏰂first coroutine to invoke receive gets the element. In the following example two coroutines "ping" and "pong" are receiving the "ball" object from the shared "table" channel.

```kotlin
data class Ball(var hints: Int)

fun main() = runBlocking {

    val tableChan = Channel<Ball>()

    launch { player(tableChan, "ping") }
    launch { player(tableChan, "pong") }

    //初始发送--发球
    tableChan.send(Ball(0))

    delay(2000)
    coroutineContext.cancelChildren()
}

suspend fun player(tableChan: Channel<Ball>, name: String) {
	 // 这里的遍历操作其实就是接收通道中的数据	
    for (ball in tableChan) {
        println("$name —— $ball")
        ball.hints++

        delay(300)
        tableChan.send(ball)
    }
}
```

运行结果：

```
ping —— Ball(hints=0)
pong —— Ball(hints=1)
ping —— Ball(hints=2)
pong —— Ball(hints=3)
ping —— Ball(hints=4)
pong —— Ball(hints=5)
ping —— Ball(hints=6)
```

上述示例中，名称为 ping 的协程首先启动，所以它会先接收到 ball 。虽然接收到之后直接在 for 循环时触发了 receive() 操作——也就是释放了通道数据，但是由于 pong 已经处于等待接收状态，所以，第二个 ball 会被 pong 接收到。


#### (10)、计时器通道

Ticker channel is a special rendezvous channel that produces Unit every time given delay passes since last consumption from this channel. 

Though it may seem to be useless standalone, it is a useful building block to create complex time-based produce pipelines and operators that do windowing and other time-dependent processing. 

Ticker channel can be used in select to perform "on tick" action.

To create such channel use a factory method `ticker`. To indicate that no further elements are needed use `ReceiveChannel.cancel` method on it.

```kotlin
fun main() = runBlocking<Unit> {

    val tickerChannel = ticker(delayMillis = 100, initialDelayMillis = 0)

    var startTime = System.currentTimeMillis()

    // ticker 会构建一个通道，然后定时发送一个 Kotlin.Unit； 如果 receive() 为null，表示新的数据还没有被发送
    var nextElement = withTimeoutOrNull(1) { tickerChannel.receive() }
    println("${System.currentTimeMillis() - startTime}_ticker 中的数据: $nextElement")


    nextElement = withTimeoutOrNull(50) { tickerChannel.receive() }
    println("${System.currentTimeMillis() - startTime}_ticker 中的数据: $nextElement")

    nextElement = withTimeoutOrNull(60) { tickerChannel.receive() }
    println("${System.currentTimeMillis() - startTime}_ticker 中的数据: $nextElement")

    tickerChannel.cancel()
}
```

运行结果：

```
16_ticker 中的数据: kotlin.Unit
73_ticker 中的数据: null
96_ticker 中的数据: kotlin.Unit
```

Note that ticker is aware of possible consumer pauses and, by default, adjusts next produced element delay if a pause occurs, trying to maintain a 􏰂xed rate of produced elements.

Optionally, a mode parameter equal to TickerMode.FIXED_DELAY can be speci􏰂ed to maintain a 􏰂xed delay between elements.

### 4、组合挂起函数

#### (1)、默认顺序调整
#### (2)、使用 async 并发
#### (3)、惰性启动的 async
#### (4)、async 风格的函数
#### (5)、使用 async 的结构化并发


### 5、协程上下文与调度

#### (1)、
#### (2)、
#### (3)、
#### (4)、
#### (5)、
#### (6)、
#### (7)、
#### (8)、
#### (9)、
#### (10)、


### 6、异常处理
#### (1)、
#### (2)、
#### (3)、
#### (4)、
#### (5)、
#### (6)、
#### (7)、
#### (8)、
#### (9)、
#### (10)、

### 7、监督
#### (1)、
#### (2)、
#### (3)、
#### (4)、
#### (5)、
#### (6)、
#### (7)、
#### (8)、
#### (9)、
#### (10)、

### 8、select 表达式(实验性的)
#### (1)、
#### (2)、
#### (3)、
#### (4)、
#### (5)、
#### (6)、
#### (7)、
#### (8)、
#### (9)、
#### (10)、

### 9、共享的可变状态与并发

#### (1)、
#### (2)、
#### (3)、
#### (4)、
#### (5)、
#### (6)、
#### (7)、
#### (8)、
#### (9)、
#### (10)、
