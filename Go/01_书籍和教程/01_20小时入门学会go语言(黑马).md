该内容基于 [20小时入门学会go语言](http://yun.itheima.com/course/302.html) 整理。

[Go语言官方网站（含文档和安装教程）](https://golang.org/doc/install)

## 1. Day01 

### 1.1.  Go的基本介绍

#### 1.1.1. 基本特性

* 一个编程语言要么是运行效率高，但是编写复杂开发效率低，如C语言（静态语言）；
要么就是运行效率稍低，但是编写简单开发效率高,如Python（解释性动态语言）；
而 Go 语言，介于 C 和 Python之间。Go属于静态语言，但是有动态语言的特性

* Go语言本身支持并发
* 有GC机制（动态语言普遍具有GC机制）

### 1.2.  开发环境搭建

#### 1.2.1.  Go语言环境搭建

环境的具体安装请参考下面官网链接中的介绍：含 MAC、Linux、Windows

[Go语言官方网站（含文档和安装教程）https://golang.org/doc/install](https://golang.org/doc/install)


#### 1.2.2.  环境验证

验证Go环境是否安装成功

* 新建文本命名为 hello.go
* 将文本的编码格式改为 UTF-8 （**Go语言的编码必须是UTF-8**）
* 在文本中输入如下代码：


```go
package main
import "fmt"
func main(){
	 fmt.Printf("hello, world\n")
}
```
* 在终端工具中切换到 hello.go 的存放路径
* 在终端中输入：`go run hello.go` 运行该文件。效果如下：

![](https://gitee.com/uploads/images/2018/0320/091354_03105516_930142.png "屏幕截图.png")

* 如上图，终端中输出了我们在 hello.go 中期望输出的 hello.world ，这样就表示Go环境安装成功。

#### 1.2.3.  集成开发环境 LiteIDE 的安装

* [LiteIDEz中文网站](http://liteide.org/cn/)

* [官网安装说明](http://liteide.org/cn/doc/install/)

![](https://gitee.com/uploads/images/2018/0320/092228_5734068b_930142.png "屏幕截图.png")

#### 1.2.4.  常用命令

命令|含义
---|---
build | 编译指定的代码包或者 go 语言源码文件及其依赖包。并生成一个 `源码文件名.exe` 文件
clean | 清除执行其他 go 
doc | 执行 `go doc` 命令打印指定的代码包
env | 打印 go 语言环境信息
fix | 执行 `go tool fix` 命令可以修正给定代码包中源码文件所包含的过时语法和代码调用
fmt | 执行 `go fmt` 命令可以格式化给定代码包中的源码文件
get | 用于下载和安装指定代码包及其依赖包（需提前安装 git 或 hg）
list | 显示给定代码包的信息
run | 编译并运行给定的源码文件
install | 编译包文件并编译整个程序
test | 测试给定的代码包
tool | 运行 go 语言的小工具
version | 显示当前安装的 go 语言的版本信息

### 1.3.  Go 文档

[Go语言官网 https://golang.org](https://golang.org)

[Go中文社区 https://studygolang.com](https://studygolang.com)

[Go中文在线文档 https://studygolang.com/pkgdoc](https://studygolang.com/pkgdoc)

### 1.4.  第一个Go程序

#### 1.4.1.  Go的特点

* Go有且只有一个入口函数——main函数
* Go的编码格式为 UTF-8
* 语句末尾不需要分号
* 大括号必须和函数名在同一行，不能换行，否则会报错。
* 调用某个函数时，基本都需要导入相应的包
* Go语言以包作为管理单位，每个文件必须先声明包（同java）
* 程序必须有一个 main 包，即 package main
* 支持单行注释和多行注释

![](https://gitee.com/uploads/images/2018/0321/083400_b89fbafe_930142.png "屏幕截图.png")

### 1.5.  命令行运行程序

* liteIde 中，一个工程（即一个文件夹）中只能有一个 main 函数

如下图，如果两个Go文件都在同一个目录下，且都有main函数，编译时会报错；

![](https://gitee.com/uploads/images/2018/0321/085519_71fdc180_930142.png "屏幕截图.png")

如果将两个分别包含main函数的Go文件，分别放置在不同的文件夹中，编译时则不会报错

![](https://gitee.com/uploads/images/2018/0321/085406_13c54626_930142.png "屏幕截图.png")


命令语句：`go run xxx.go`

![](https://gitee.com/uploads/images/2018/0321/090220_9498966c_930142.png "屏幕截图.png")

### 1.6.  数据类型和命名规范

命名规范：

* 字母/数字/下滑线组成
* 不能以数字开头
* 区分大小写
* 不能使用系统关键字

### 1.7.  变量的声明

导入的包必须要使用，声明的变量必须要使用，否则，会报错！！

```go
// var 变量名 类型
var a int   

//同时声明多个类型相同的变量
var a,b,c int  
```

### 1.8.  变量初始化和类型推导-v9

#### 1.8.1.  初始化

即声明变量的同时进行赋值

```go
var a int=10
```

#### 1.8.2.  类型推导

声明变量的时候不用指明类型，会根据值自动推导

```go
//方式1：只是省略 类型
var a = 10 

//方式2：使用 := 短声明符号，不需要var ,不需要类型，但只适用于局部变量 
a := 10
```
#### 1.8.3.  `%T`打印变量所属的类型

```go
package main
import "fmt"

func main()  {
	a:=10
	// %T 是一个格式化字符，Printf 中可以使用这种格式化字符，Println 中不可以使用
	fmt.Printf("a的类型为：%T\n", a)
}
```

运行结果：

```
cnpeng$ go run Day1.go 
a的类型为：int
```
### 1.9.  自动类型推导和赋值的区别-v10

* 自动类型推导的方式中，必须要初始化，推导时会根据初始化的值进行推导。
* 赋值是根据声明的变量类型进行填值

### 1.10.  Printf 和 Println 区别-v11

* Printf 表示格式化输出，可以使用占位符; 本身不具有换行效果
* Println 普通输出，不可以使用占位符; 本身具有换行效果
* Go 语言中的占位符是 `%d` ,示例如下：

```go
package main

import "fmt"

func main() {
	a := 10
	b := 20

	//格式化输出（可以使用占位符--%d）,\n是为了换行
	fmt.Printf("a=%d,b=%d\n", a, b)

	//普通输出(占位符%d不生效 )
	fmt.Println("a=", a, "b=", b)
}

```
### 1.11. 多重赋值和匿名变量--v12

* 多重赋值

```go
//定义并给三个变量赋值,这种就是多重赋值
a,b,c:=10,20,30 
```

* 变量值的交换

```go
package main
import "fmt"

func main()  {
	a,b:=10,20

	//交换值
	a,b=b,a
	fmt.Printf("a=%d,b=%d \n", a,b)
}
```

运行结果：

```
cnpeng$ go run Day1.go 
a=20,b=10 
```

* 匿名变量

**`_`** 就表示匿名变量，表示丢弃它的数据值不做处理，匿名变量实际配合函数返回值使用才有优势

```go
package main
import "fmt"

func main()  {
	a,b:=10,20

	// 把 b 的值赋给a, 把 a 的值赋给_ ,也就是丢弃 a 的值
	a,_=b,a
	fmt.Printf("a=%d,b=%d \n", a,b)
}
```

运行结果：

```
cnpeng$ go run Day1.go 
a=20,b=20 
```
* go　函数可以返回多个值.

* 函数与匿名变量的配合使用：

```go
package main

import "fmt"

func main() {

	//分别使用　a,b,c 来接受函数的返回值
	a, b, c := test()
	fmt.Printf("a=%d,b=%d，c=%d \n", a, b, c)

	//如果只需要中的一个值，则第一个和最后一个可以使用匿名变量来接收
	_, d, _ := test()
	fmt.Printf("d=%d \n", d)
}

//定义一个函数，返回三个int 型数值
func test() (a, b, c int) {
	return 1, 2, 3
}

```
运行结果：

```
cnpeng$ go run Day1.go 
a=1,b=2,c=3 
d=2 
```

### 1.12. 常量-v13

* 常量的值在程序运行时值不会发生改变，声明时使用关键字 `const`
* 变量的值在程序运行时会发生改变，关键字 `var`

```go
//普通常量声明方式
const a int =10 

//自动推导类型的声明方式，注意，=左边没有：
const b=10 
```

完整示例代码：

```go
package main
import "fmt"

func main()  {
	// 声明一个常量，并显示声明其类型
	const a int =10

	// 声明常量时省略类型. 注意，b 后面没有跟 冒号 : 
	const b = 10

	fmt.Printf("b的类型为 %T \n", b)

	var c int =10 
	var d = 10

	fmt.Printf("c=%d , d = %d, d 的类型为%T \n", c,d,d)
}

```

运行结果：

```
cnpeng$ go run Day1.go 
b的类型为 int 
c=10 , d = 10, d 的类型为int 
```

### 1.13. 同时定义多个变量/常量-v14

```go
package main
import "fmt"
func main(){

	//多个变量的普通声明和赋值模式
	var a int 
	var b float64 
	a,b=10,3.14
	fmt.Println(a,b)

	//声明多个变量时可以使用小括号
	var(
		c int
		d float64 
	)
	c,d=10,3.14
	fmt.Println(c,d)

	//声明多个变量时可以直接使用小括号，并在小括号中赋值
	var(
		e=10
		f=20
	)
	fmt.Println(e,f)

	//声明const 常量时使用小括号(常量的具体类型可以省略)
	const(
		g=10
		h=3.14
	)
	fmt.Println(g,h)
}

```

### 1.14. `iota` 枚举-v15

* `iota` 用来给常量赋值，值从0开始，每行的值自动累加 1
* `iota` 遇见`const` 关键字时值重置为0
* 直接通过`iota`给多行赋值时,可以只在第一行写`iota`,其他行可省略.(此时，每行只能有一个常量)
* 使用`iota`赋值时，如果多个常量在同一行，值一致。（此时，iota不能被省略）

```go
package main
import "fmt"

func main(){
	// iota 用来给常量赋值，从0开始，每行+1
	const(
		a=iota	//0
		b=iota	//1
		c=iota	//2
	)
	fmt.Printf("a=%d,b=%d,c=%d\n",a,b,c)

	// 直接使用iota给多行常量（每行只有一个）赋值时，可以只在第一行写iota
	const(
		a1=iota		//0
		b1			//1
		c1			//2
	)
	fmt.Printf("a1=%d,b1=%d,c1=%d\n",a1,b1,c1)

	// 使用iota赋值时，如果多个常量在同一行(必须写全iota)，值一致
	const(
		a2=iota			//0
		b2,c2=iota,iota //1,1
		d2=iota			//2
	)
	fmt.Printf("a2=%d,b2=%d,c2=%d,d2=%d \n",a2,b2,c2,d2)
}
```

### 1.15.  基础数据类型分类 -v16

![](https://images.gitee.com/uploads/images/2019/0214/091640_16d2f975_930142.png "屏幕截图.png")

上图中的零值就是指默认值

### 1.16.  布尔类型 -v17

(CnPeng, 从该节开始，后续代码均使用 VsCode 编辑和运行)

```go
package main
import "fmt"

func main()  {
	var a bool
	fmt.Println("a = " , a)

	a = true
	fmt.Println("a = ", a)

	var b = true
	fmt.Println("b = ",b)

	c := false
	fmt.Println("c = ",c)
}
```
运行结果：

```
cnpeng$ go run Day1.go 
a =  false
a =  true
b =  true
c =  false
```

### 1.17.  整型和浮点型 -v18

* 浮点型数据又叫 实数


### 1.18.  字符类型 -v19

* 使用单引号括起来的单个字符

```go
package main
import "fmt"

func main()  {
	var	ch byte = 97
	// %c 表示以字符的形式打印 ,%d 表示以整数的形式打印， 
	fmt.Printf("ch = %d ,ch = %c \n",ch,ch)

	ch = 'b'
	fmt.Printf("字符的形式输出 %c , 以整数的形式输出 %d \n",ch,ch)

	var ch1='b'
	var flag = ch1==98
	fmt.Println("ch1 == 98 :",flag)
	
	var ch2 = '中'
	fmt.Printf("ch2 = %d \n", ch2)
}

```
运行结果：

```
ch = 97 ,ch = a 
字符的形式输出 b , 以整数的形式输出 98 
ch1 == 98 : true
ch2 = 20013 
```

### 1.19.  字符串类型-v20

* `len(字符串)` 可以获取字符串的长度 
* `字符串[index]` 可以获取字符串指定index位置的字符


### 1.20.  字符和字符串的区别-v21

略

### 1.21. 复数类型-v22

* 复数实际上是有两个实数（浮点数）的组合，一个表示实部（real），一个表示虚部（imag）。
* 虚部需要添加 `i` 作为后缀。
* `real(复数)`可以获取实部 ，`imag(复数)` 可以获取虚部

```go
package main

import "fmt"

func main() {
	//  声明一个复数
	var v1 complex64
	// 虚部数据需要后缀 i
	v1 = 3.2 + 12i
	fmt.Println("v1=", v1)

	//  自动推导类型的复数
	v2 := 3.3 + 2.0i
	fmt.Printf("v2的类型为：%T \n", v2)
	fmt.Println("v2的值为：", v2)

	//  获取复数的实部和虚部: real(复数)，imag(复数)
	fmt.Println("v2的实部为：", real(v2), "v2的虚部为：", imag(v2))
}
```

运行结果：

```
cnpeng$ go run Day1.go 
v1= (3.2+12i)
v2的类型为：complex128 
v2的值为： (3.3+2i)
v2的实部为： 3.3 v2的虚部为： 2
```


### 1.22. 格式化输出-v23

fmt 包的 `Printf()` 格式化输出可以使用下面的格式化符号：

格式|含义
---|---
`%%`| `%` 字面量
`%b` | 二进制整数值(基数为2)，或者是(高级的)用科学计数法表示的指数为2的浮点数
`%c` | 字符型。可以把输入的数字安装 ASCII 码转换为对应的字符。
`%d` | 十进制数值(基数为10)
`%e` | 以科学计数法 e 表示的浮点数或者复数值
`%E` | 以科学计数法 E 表示的浮点数或者复数值
`%f` | 以标准计数法表示的浮点数或者复数值
`%g` | 以`%e`或者`%f`表示的浮点数或者复数，任何一个都以最为紧凑的方式输出
`%G` | 以 `%E`或者`%f`表示的浮点数或者复数，任何一个都以最为紧凑的方式输出
`%o`| 以八进制表示的数字
`%p`| 以十六进制表示的值的地址，前缀为 0x, 字母使用小小的 a-f 表示
`%s`| 字符串
`%t`| 以 true 或者 false 输出布尔值
`%T`| 获取数据类型。
`%U`| 用 Unicode 表示法表示的整型码点。默认值为四个数字字符
`%v`| 使用默认格式输出的内置或自定义类型的值。或者时使用期类型的 String() 方式输出的自定义值。
`%x`| 以十六进制表示的整型值, a-f 使用小写
`%X`| 以十六进制表示的整型值， A-F 使用大写 


### 1.23. 变量的输入-v24

使用 fmt 的 `scan()` 函数 可以接收用户输入的内容

```go
package main

import "fmt"

func main() {
	// 先定义一个用来接收输入的变量
	var a int
	fmt.Printf("请输入一个整数值：")
	//调用 Scan() 检测用户输入，并将输入值赋值给 a , 不要省略 & 符号
	// fmt.Scan("%d",&a)
	// 可以省略 ”%d“
	fmt.Scan(&a)
	fmt.Println("a的值为：", a)
}
```

运行结果：

```
cnpeng$ go run Day1.go 
请输入一个整数值：23
a的值为： 23
```

### 1.24. 1.24 .  类型转换-v25

Go 语言中不允许隐式转换，所有类型转换必须显示声明，而且转换只能发生在两种相互兼容的类型之间。

```go
package main

func main() {
	var a byte = 97
	//显示类型转换
	var b int = int(a)
	
	//隐式类型转换，报错
	// var c int = a
	
	//类型不兼容，int 不能转为 bool
	//var d bool = bool(b)
	fmt.Println(d)
}
```

### 1.25. 类型别名-v26

* 为现有的类型定义别名，方便调用。关键字 `type`

( 在 Swift 中也有这种类型别名，特别是对函数类型定义别名很有用)

```go
package main

import "fmt"

func main() {
	// 为 int64 起一个类型别名为，bigint
	type bigint int64
	var x bigint = 100

	// 同时定义多个类型别名
	type (
		myint int
		mystr string
	)

	var y myint = 11
	var z mystr = "12"

	fmt.Println(x, y, z)
	fmt.Printf("x,y,z 的类型分别为：%T , %T , %T \n ", x, y, z)
}
```

运行结果：

```
cnpeng$ go run Day1.go 
100 11 12
x,y,z 的类型分别为：main.bigint , main.myint , main.mystr 
```

### 1.26. 运算符(上)-v27

* 算术运算符：`+、-、*、/、%、++、--`。自增和自减只有后置没有前置。
* 关系运算符：`==、!=、>、<、>=、<=`
* 逻辑运算符：`! 、 && 、 ||`


### 1.27. 运算符(下)-v28

* 位运算符：`& 、 | 、 ^ 、 << 、>>`
* 赋值运算符：`= 、+= 、-= 、*= 、/= 、 %= 、<<= 、>>= 、&= 、^= 、|=`

* 其他运算符: 包括 `& 、* ` ，示例如下：

运算符|含义|示例|说明
---|---|---|---
& | 取地址运算符| fmt.Scan(&a) | 获取变量 a 的地址。
`*` | 取值运算符 | `*a` | 指针变量 a 所指向内存的值 

* 运算符的优先级如下：

优先级|运算符
---|---
7 | `^ 、！` 
6 | `* 、/ 、% 、<< 、>> 、 & 、&^ `
5 | `+ 、- 、 | 、^ `
4 | `== 、!= 、 < 、<= 、>= 、> `
3 | `<-`
2 | `&&`
1 | `||`

### 1.28. if 的使用-v29

```go
package main
import "fmt"

func main() {

	var a = 3
	if a == 3 {
		fmt.Println("a = ", a)
	}
}
```
运行结果：

```
cnpeng$ go run Day1.go 
a =  3
```

### 1.29. if支持初始化语句

```go
package main
import "fmt"

func main() {

	// if支持一个变量初始化语句，
	// 初始化和条件语句间使用分号; 间隔
	// 该变量只在该 if 及其 else 语句中有效
	if b := 3; b < 4 {
		fmt.Print("在if后面初始化并使用变量，初始化和条件语句之间使用分号间隔\n")
		fmt.Println(b + 1)
	}
}
```
运行结果：

```
cnpeng$ go run Day1.go 
在if后面初始化并使用变量，初始化和条件语句之间使用分号间隔
4
```
### 1.30. else / else if 

```go
package main
import "fmt"

func main() {

	// if支持一个变量初始化语句，
	// 初始化和条件语句间使用分号; 间隔
	// 该变量只在该if 及其 else 语句中有效
	if b := 5; b < 4 {
		fmt.Println("b小于4, 其值为：", b)
	} else if b == 4 {
		fmt.Println("b == 4")
	} else {
		fmt.Println("b大于4，其值为：", b)
	}
}
```

运行结果：

```
cnpeng$ go run Day1.go 
b大于4，其值为： 5
```
### 1.31. switch - v32

* switch 语句的每一个 case中，可以省略 break 关键字
* 使用`fallthrough` 表示穿透 

（上述两个特点 和 Swift 中的效果一致）

```go
package main

import "fmt"

func main() {

	num := 5
	switch num {
	case 1:
		fmt.Println("输入的是1")
		//末尾的break可以省略
	case 5:
		fmt.Println("输入的是5")
		//fallthrough 表示穿透
		fallthrough
	default:
		fmt.Println("输入的是：", num)
	}
}
```

运行结果：

```
cnpeng$ go run Day1.go 
输入的是5
输入的是： 5
```

### 1.32. switch补充 -v33

* switch 语句也支持初始化一个变量
* case 后面可以跟多个常量，使用 逗号 间隔
* 当 case 后面跟的是表达式时，可以省略 switch 后面的条件。


```go
package main

import "fmt"

func main() {

	//  switch 支持初始化一个变量
	switch num := 5; num {
	case 1, 2 , 3 :
		fmt.Println("输入的是1 或 2 或 3 ")
		//末尾的break可以省略
	case 5:
		fmt.Println("输入的是5")
		//fallthrough 表示穿透
		fallthrough
	default:
		fmt.Println("输入的是：", num)
	}

	//  如果 case 分支是表达式，可以在 switch 后面省略条件
	score := 99
	switch {
	case score > 90:
		fmt.Println("成绩为：", score, "，优")
	case score > 60:
		fmt.Println("成绩为：", score, ", 及格")
	default:
		fmt.Println("成绩为：", score, ", 不及格")
	}
}
```

运行结果

```
go run Day1.go 
输入的是5
输入的是： 5
成绩为： 99 ，优 
```

### 1.33. for 循环-v34

* Go 中没有 while 和 do/while

```go
package main

import "fmt"

func main() {
	sum := 0
	// 与 Java 中的 for 基本一致，但是只有后自增，没有前自增
	for i := 1; i <= 50; i++ {
		sum += i
	}
	fmt.Println("从1加到50的总和为：", sum)
}
```

运行结果：

```
cnpeng$ go run Day1.go 
从1加到50的总和为： 1275
```

### 1.34. range 的使用

* 迭代打印 索引和索引对应的元素

```go
package main

import "fmt"

func main() {
	str := "abc"

	//  遍历字符串中字符的基本写法
	for i := 0; i < len(str); i++ {
		fmt.Printf("str[%d]=%c \n", i, str[i])
	}

	//  使用 range 时，同时遍历并返回 索引 和 数据
	for i, ch := range str {
		fmt.Printf("str[%d]=%c \n", i, ch)
	}

	//  忽略 range 中的某个返回值。只使用索引，忽略数据
	for i, _ := range str {
		fmt.Printf("str[%d]=%c \n", i, str[i])
	}

	//  忽略数据的简化写法. 省略 _ 后 得到的只是索引(也叫下标)
	for i := range str {
		fmt.Printf("str[%d]=%c \n", i, str[i])
	}
}
```

运行结果：

```
cnpeng$ go run Day1.go 
str[0]=a 
str[1]=b 
str[2]=c 

str[0]=a 
str[1]=b 
str[2]=c 

str[0]=a 
str[1]=b 
str[2]=c 

str[0]=a 
str[1]=b 
str[2]=c 
```
### 1.35. break 和 continue 

* break : 结束当前循环， 可以用到 for 、switch、select 
* continue : 跳过本次循环， 仅能用于 for

示例1：

```go
package main

import "fmt"

func main() {
	str := "abc"
	for i, data := range str {

		if 1 == i {
			fmt.Println("break,结束循环")
			break
		}

		fmt.Printf("str[%d]= %c \n", i, data)
	}

	for i, _ := range str {
		if 1 == i {
			fmt.Println("continue, 跳过本次循环")
			continue
		}

		fmt.Printf("str[%d]=%c \n", i, str[i])
	}
}
```

运行结果：

```
cnpeng$ go run Day1.go 
str[0]= a 
break,结束循环

str[0]=a 
continue, 跳过本次循环
str[2]=c 

```

示例2：

```go
package main

import "fmt"
import "time"

func main() {
	i := 0

	// for 后面没有加条件，表示死循环
	for {
		i++
		//延时1秒
		time.Sleep(time.Second)

		if 2 == i {
			// 跳过本次循环
			fmt.Println("2==i , 跳过循环")
			continue
		}

		if 5 == i {
			//结束循环
			fmt.Println("5==i , 结束循环")
			break
		}

		fmt.Println("i = ", i)
	}
}
```

运行结果：

```
cnpeng$ go run Day1.go 
i =  1
2==i , 跳过循环
i =  3
i =  4
5==i , 结束循环
```

### 1.36. goto 的使用

* `goto 标签名` 跳转到指定 标签名 的代码处
* 可以应用于任何位置，循环中也可以使用

```go
package main

import "fmt"

func main() {
	fmt.Println("11111")

	// 跳转到标签名为 PrintThree 的位置，这样下面的 22222 将不会被打印
	goto PrintThree

	fmt.Println("22222")

	// 定义标签及其对应的代码，注意标签名后面有冒号
PrintThree:
	fmt.Println("33333")
}
```

运行结果：

```
cnpeng$ go run Day1.go 
11111
33333
```

---
## 2. 二、Day2

### 2.1.  无参无返回的函数-v2

#### 2.1.1.  函数的格式

```
func 函数名称(参数1 参数1类型)(返回值1 返回值1类型 , 返回值2 返回值2类型){
	// 函数体
	
	// 具体返回值的数量需要与声明中的一致
	return v1 , v2
}
```

* 函数名首字母小写表示私有——private, 首字母大写表示公开——public
* 不支持默认参数
* 可以有多个返回值。
* 声明返回值时，可以只定义返回值类型，而省略返回值的变量名
* 如果只有一个返回值并且没有声明返回值的变量名，则可以省略返回值类型外层的括号
* 如果没有返回值，直接省略最后的括号

#### 2.1.2.  无参无返回值的函数


```go
package main
import "fmt"

func main() {
	myFunc()
}

func myFunc() {
	fmt.Println("定义一个无参无返回值的函数")
}
```

### 2.2.  有参无返回值的函数-v3

* 定义函数时声明的参数为形参，调用函数时传递的参数为实参
* 多个参数之间使用 逗号 间隔

```go
package main
import "fmt"

func main() {
	myFunc(5)
}

func myFunc(a int) {
	fmt.Println("有参无返回的函数，参数为", a)
}

// 接收多个参数时使用逗号隔开
func myFunc1(a int, b int) {
	fmt.Printf("接收的参数分别为：%d , %d \n", a, b)
}

// 多个参数的类型一致时，可以只在最后一个参数后面添加类型
func myFunc2(a, b int) {
	fmt.Printf("接收的参数分别为：%d , %d \n", a, b)
}
```

### 2.3.  不定参数类型/可变参数-v4

* `...类型` 表示不定参数，可以传递不定数量（0个或多个）的 指定类型的数据
* 可变参数只能作为函数的最后一个参数

```go
package main
import "fmt"

func main() {
	// 可变参数可以传0个
	myFunc1(1)
	// 可变参数也可以传多个
	myFunc1(1, 2)
	myFunc1(1, 2, 3, 4, 5)
}

// 定义可变参数函数；多个参数时，可变参数必须作为最后一个
func myFunc1(a int, args ...int) {
	argsLen := len(args)
	fmt.Println("可变参数的长度为: ", argsLen)

	for i, data := range args {
		fmt.Printf("args[%d]=%d \n", i, data)
	}
}
```
运行结果：

```
cnpeng$ go run Day1.go 
可变参数的长度为:  0
可变参数的长度为:  1
args[0]=2 
可变参数的长度为:  4
args[0]=2 
args[1]=3 
args[2]=4 
args[3]=5 
```	


### 2.4.  不定参数的传递-v5

把可变参数传递给另一个可变参数的函数时，有两种情况：传递部分参数，传递全部参数。

```go
package main
import "fmt"

func main() {
	myFunc1(1, 2, 3, 4, 5)
}

func myFunc(args ...int) {
	argsLen := len(args)
	fmt.Println("可变参数的长度为: ", argsLen)

	for i, data := range args {
		fmt.Printf("args[%d]=%d \n", i, data)
	}
}

func myFunc1(args1 ...int) {
	//  传递全部参数，参数后面追加 三个点(...)
	myFunc(args1...)

	//  传递部分参数. args1[:2] 表示取到索引为2（但不包含2）的元素，即 args[0],args[1]
	myFunc(args1[:2]...)

	//  传递部分参数. args[2:] 表示从索引为2的元素开始，取到最后一个
	myFunc(args1[2:]...)
}
```

运行结果：

```
cnpeng$ go run Day1.go 
可变参数的长度为:  5
args[0]=1 
args[1]=2 
args[2]=3 
args[3]=4 
args[4]=5 
可变参数的长度为:  2
args[0]=1 
args[1]=2 
可变参数的长度为:  3
args[0]=3 
args[1]=4 
args[2]=5 
```

### 2.5.  有参无返回值函数的使用总结-v6

略

### 2.6.  函数只有一个返回值-v7

```go
package main

import "fmt"

func main() {
	result1 := myFunc1()
	result2 := myFunc2()
	result3 := myFunc3()

	fmt.Printf("result1 = %d, result2 = %d ,result3 = %d \n", result1, result2, result3)
}

// 推荐写法1: 声明返回变量，但没有使用
func myFunc1() (result int) {
	return 555
}

// 推荐写法2：声明返回变量并为该变量赋值，此时，return 后可以不跟内容
func myFunc2() (result int) {
	result = 666
	return
}

// 写法3：单返回值并且没有声明返回变量，省略括号
func myFunc3() int {
	return 777
}
```
运行结果：

```
cnpeng$ go run Day1.go 
result1 = 555, result2 = 666 ,result3 = 777 
```

### 2.7.  函数有多个返回值-v8

(Swift 的函数也可以有多个返回值)

```go
package main

import "fmt"

// 推荐写法1:
func myFunc1() (a int, b int, c int) {
	a, b, c = 1, 2, 3
	return
}

// 推荐写法2：
func myFunc2() (a, b, c int) {
	a, b, c = 4, 5, 6
	return
}

// 写法3：
func myFunc3() (int, int, int) {
	return 7, 8, 9
}

func main() {
	a1, b1, c1 := myFunc1()
	fmt.Printf("a1 = %d, b1 = %d ,c1 = %d \n", a1, b1, c1)

	a2, b2, c2 := myFunc2()
	fmt.Printf("a2 = %d, b2 = %d ,c2 = %d \n", a2, b2, c2)

	a3, b3, c3 := myFunc3()
	fmt.Printf("a3 = %d, b3 = %d ,c3 = %d \n", a3, b3, c3)
}
```
运行结果：

```
cnpeng$ go run Day1.go 
a1 = 1, b1 = 2 ,c1 = 3 
a2 = 4, b2 = 5 ,c2 = 6 
a3 = 7, b3 = 8 ,c3 = 9 
```


### 2.8.  函数定义格式总结-v9

略

### 2.9.  有参有返回值的函数-v10

```go
package main

import "fmt"

// 推荐写法1:
func myFunc1(a, b int) (max, min int) {
	if a >= b {
		max = a
		min = b
	} else {
		max = b
		min = a
	}
	return
}

func main() {
	max, min := myFunc1(5, 8)
	fmt.Printf("max = %d, min = %d \n", max, min)

	// 使用匿名变量 _ 接收第二个返回值——实际就表示丢弃该值
	max2, _ := myFunc1(7, 9)
	fmt.Printf("max2 = %d \n", max2)
}
```
运行结果：

```
cnpeng$ go run Day1.go 
max = 8, min = 5 
max2 = 9 
```

### 2.10.  普通函数的调用流程-v11

顺序执行

### 2.11. 递归函数的调用流程-v12

自己调用自己称递归

```go
package main

import "fmt"

// 推荐写法1:
func myFunc1(a int) {
	if a == 1 {
		fmt.Println("a==1, 调用 return，跳出当前函数")
		return
	}

	myFunc1(a - 1)
	// 当 a!=1 时，这一句一直暂存在内存中。当 a==1 时，再倒序执行，依次得到 2，3
	fmt.Println("a 的值为: ", a)
}

func main() {
	myFunc1(3)
	fmt.Println("递归函数执行完毕，调用 main 中的下一句函数")
}
```
运行结果：

```
cnpeng$ go run Day1.go 
a==1, 调用 return，跳出当前函数
a 的值为:  2
a 的值为:  3
递归函数执行完毕，调用 main 中的下一句函数
```


### 2.12. 通过递归实现累加-v13

```go
package main
import "fmt"

func myFunc1(a int) (result int) {
	if a == 1 {
		result = 1
		// 此处return表示返回值为result,其值为1
		return
	}

	// 下面这个返回也可以，但这是利用return直接退出程序
	// if a == 0 {
	// 	return
	// }
	result = a + myFunc1(a-1)
	return
}

func main() {
	result := myFunc1(3)
	fmt.Println("result结果为：", result)
}
```
运行结果：

```
cnpeng$ go run Day1.go 
result结果为： 6
```

### 2.13. 函数类型-v14

(Swift 中也有函数类型。[此处可以对照 Swift 中的内容.](08_IOS/01_Swift/Swift权威编程指南-笔记.md))

* 函数也是一种数据类型，其格式为：`func (参数1类型，参数2类型) 返回值类型` 
* 可以通过 type 关键字为函数起别名
* 为函数类型的变量赋值时，不需要后缀小括号

```go
package main

import "fmt"

func PlusFunc(a, b int) (result int) {
	result = a + b
	return
}

func minus(a int, b int) int {
	return a - b
}

// `func(int,int) int` 表示一个接受两个int值并返回一个int值的函数类型
// 为该函数类型定义别名为 MyFuncType
type MyFuncType func(int, int) int

func main() {
	var myFunc MyFuncType
	// 为函数类型变量赋值时不需要后缀小括号
	myFunc = PlusFunc
	result1 := myFunc(1, 2)

	myFunc = minus
	result2 := myFunc(6, 2)

	fmt.Printf("result1 = %d ,result2 = %d \n", result1, result2)
}
```

运行结果：

```
cnpeng$ go run Day1.go 
result1 = 3 ,result2 = 4
```

### 2.14.  回调函数-v15

* 某个函数包含一个函数类型的参数，那么这个函数就称为回调函数。

```go
package main
import "fmt"

func PlusFunc(a, b int) (result int) {
	result = a + b
	return
}

func minus(a int, b int) int {
	return a - b
}

// `func(int,int) int` 表示一个接受两个int值并返回一个int值的函数类型
// 为该函数类型定义别名为 MyFuncType
type MyFuncType func(int, int) int

// 函数的某个参数为函数类型，则该函数称为回调函数
func Calc(a, b int, callbackFucn MyFuncType) (result int) {
	result = callbackFucn(a, b)
	return
}

func main() {
	// 回调函数体现了多态的理念
	result1 := Calc(3, 4, PlusFunc)
	result2 := Calc(6, 2, minus)
	fmt.Printf("result1 = %d ,result2 = %d \n", result1, result2)
}
```

运行结果：

```
cnpeng$ go run Day1.go 
result1 = 7 ,result2 = 4 
```

### 2.15.  匿名函数基本语法-v16

* 匿名函数就是没有函数名的函数，匿名函数又称闭包
* 匿名函数通常定义在另一个函数内容
* 匿名函数必须被调用，可以先赋值给变量，然后通过变量调用；也可以定义的同时直接调用
* 有返回值的匿名函数中，不要遗漏 return 语句


```go
package main

import "fmt"

func main() {
	//  定义匿名函数并赋值给函数类型变量，然后调用该变量
	unNameFunc1 := func() {
		fmt.Println(" 无参无返回值的匿名函数")
	}
	// 调用无参匿名函数时，不要遗漏后面的小括号
	unNameFunc1()

	//  定义带参数的匿名函数
	unNameFunc2 := func(a, b int) {
		fmt.Printf(" 有参匿名函数：a = %d , b = %d \n", a, b)
	}
	unNameFunc2(2, 3)

	//  定义的同时直接调用——匿名函数尾部追加小括号
	func() {
		fmt.Println(" 匿名函数大括号尾部追加小括号，表示调用该匿名函数")
	}()

	//  定义的同时直接调用——有参数时，末尾的小括号内传参
	func(a, b int) {
		fmt.Printf(" 定义的同时调用有参匿名函数，末尾的小括号内传参。a + b= %d \n", a+b)
	}(3, 4)

	//  有返回值的匿名函数
	max, min := func(a, b int) (max, min int) {
		if a > b {
			max = a
			min = b
		} else {
			max = b
			min = a
		}

		// 有返回值的匿名函数不要遗漏了末尾的return语句
		return
	}(5, 8)
	fmt.Printf(" 调用有返回值的匿名函数。max = %d ,min = %d \n", max, min)

	//  不常用的写法
	type CusFunc func()
	var unNameFunc3 = func() {
		fmt.Println(" 不常用写法，先声明函数类型别名，然后定义函数类型变量，然后调用，这种不常用！")
	}
	unNameFunc3()
}
```

运行结果：

```
cnpeng$ go run Day1.go 
 无参无返回值的匿名函数
 有参匿名函数：a = 2 , b = 3 
 匿名函数大括号尾部追加小括号，表示调用该匿名函数
 定义的同时调用有参匿名函数，末尾的小括号内传参。a + b= 7 
 调用有返回值的匿名函数。max = 8 ,min = 5 
 不常用写法，先声明函数类型别名，然后定义函数类型变量，然后调用，这种不常用！
```

### 2.16.  闭包捕获外部变量特点-v17

* 匿名函数(闭包) 调用外部变量时，持有的是该变量的引用。

```go
package main

import "fmt"

func main() {
	a := 5
	str1 := "张三"

	//  匿名函数内引用外部的变量时，会持有该变量的内存地址。所以，内部对变量的改变会同步到外部。
	func() {
		// 为局部变量重新赋值
		a = 666
		str1 = "李四"
		fmt.Printf("匿名函数内：a = %d , str1 = %s \n", a, str1)
	}()
	fmt.Printf("匿名函数外：a = %d , str1 = %s \n\n", a, str1)

	//  下面这种持有的是两个新变量(num, strArg)的引用, 新变量的改变不会影响外部变量
	func(num int, strArg string) {
		num += 111
		strArg += "哈哈哈哈哈"
		fmt.Printf("匿名函数内：num = %d , strArg = %s \n", num, strArg)
		fmt.Printf("匿名函数内：a = %d , str1 = %s \n", a, str1)
	}(a, str1)
	fmt.Printf("匿名函数外：a = %d , str1 = %s \n", a, str1)
}
```

运行结果：

```
cnpeng$ go run Day1.go 
匿名函数内：a = 666 , str1 = 李四 
匿名函数外：a = 666 , str1 = 李四 

匿名函数内：num = 777 , strArg = 李四哈哈哈哈哈 
匿名函数内：a = 666 , str1 = 李四 
匿名函数外：a = 666 , str1 = 李四 
```

### 2.17.  闭包的特点-v18

还是说的闭包对外部变量引用的特点——持有的是变量的引用，闭包内部对变量的改变会同步到外部。

下面的这个例子中，不一样的地方是：定义了一个返回值为函数类型的函数。

```go
package main

import "fmt"

// 定义一个无参函数，其返回值类型为： func() int
func Calc() func() int {
	// 没有为x赋值，此时默认值为0
	var x int
	return func() int {
		x++
		return x * x
	}
}

func main() {

	// 此处表示调用 Calc() 函数，将值赋给 f , f 的类型为 func() int
	f1 := Calc()
	fmt.Printf("%T \n", f1)
	// f 持有了 x 的引用，因此每调用一次 f ，就会触发一次 x++
	fmt.Printf("result1 = %d \n", f1())
	fmt.Printf("result1 = %d \n", f1())
	fmt.Printf("result1 = %d \n\n", f1())

	// 新声明了一个变量，f1 中持有的 x 引用不会影响 f2 对 x 的引用
	f2 := Calc()

	fmt.Printf("result2 = %d \n", f2())
	fmt.Printf("result2 = %d \n", f2())
	fmt.Printf("result2 = %d \n\n", f2())
}

```

运行结果：

```
cnpeng$ go run Day1.go 
func() int 
result1 = 1 
result1 = 4 
result1 = 9 

result2 = 1 
result2 = 4 
result2 = 9 
```


### 2.18.  defer的使用-v19

* 被 `defer` 修饰的内容，定义在函数内，并且只会在函数将要结束时调用（也就是：先调用没有 defer 的语句，最后调用被 defer 修饰的语句）

```go
package main

import "fmt"

func main() {
	defer fmt.Println("aaaaaaaa")
	fmt.Println("bbbbbb")
}
```

运行结果：

```
cnpeng$ go run Day1.go 
bbbbbb
aaaaaaaa
```

### 2.19.  多个defer的执行顺序-v20

* 先进后出。

函数运行过程中遇见 defer 修饰的内容之后，会把这些语句暂存到内存中，等其他非 defer 语句执行完毕之后，再按照 先进后出 的顺序依次执行（这其实就是一个进栈和出栈的操作）。


#### 2.19.1.  示例1：

```go
package main

import "fmt"

func main() {
	defer fmt.Println("aaaaaaaa")
	defer fmt.Println("bbbbbb")
	defer fmt.Println("cccccc")

	fmt.Println("没有被defer修饰的普通语句")
}
```

运行结果：

```
cnpeng$ go run Day1.go 
没有被defer修饰的普通语句
cccccc
bbbbbb
aaaaaaaa
```

#### 2.19.2.  示例2：

如果程序中的某处可能会出现异常，那么定义异常前面的 defer 会被调用。

定义在异常后面的不会被调用，因为定义在异常后面的内容还没有进栈操作，所以不会出栈。

下面的示例代码中，执行 main 函数时，读取到前两个 defer 时会先暂存到栈中，遇到 calc(2,0) 时出现异常，此时 main 函数将要结束，就会按照出栈顺序执行暂存在内存中的 defer。打印错误日志的操作是在函数结束之后。而第三个 defer 没有入栈，所以函数将要结束时并不会调用它。

```go
package main
import "fmt"

func main() {
	defer fmt.Println("aaaaaaaa")
	defer fmt.Println("bbbbbb")
	calc(2, 0)
	defer fmt.Println("cccccc")
}

func calc(a, b int) {
	fmt.Println(a / b)
}
```

运行结果：

```
cnpeng$ go run Day1.go 
bbbbbb
aaaaaaaa
panic: runtime error: integer divide by zero

goroutine 1 [running]:
main.calc(0x2, 0x0)
        /Users/cnpeng/CnPeng/04_Demos/096_Go/ItCast/Day1.go:13 +0xac
main.main()
        /Users/cnpeng/CnPeng/04_Demos/096_Go/ItCast/Day1.go:8 +0xef
exit status 2
```
### 2.20.  defer和匿名函数结合使用-v21

```go
package main

import "fmt"

func main() {
	a := 10

	// 读取到这里时 a 的值为10，然后传递给了arg 。 a=20 将不会影响到这里
	defer func(arg int) {
		// 外部传入的 a 赋值给 arg.
		fmt.Println("A: arg = ", arg)
	}(a)

	// 读取到这里时，只是暂存函数到内存，还没开始引用 a 。只有执行时才会去引用 a
	defer func() {
		// 直接引用外部的 a
		fmt.Println("B: a = ", a)
	}()

	a = 20
	fmt.Println("C: a = ", a)
}
```

运行结果：

```
cnpeng$ go run Day1.go 
C: a =  20
B: a =  20
A: arg =  10
```
### 2.21. 2.21 .  获取命令行参数-v22

* 终端中命令行的参数都是以字符串的形式传递的
* 获取参数时需要导入 os 包，并使用 os.Args 属性，os.Args 返回的是一个 `[]string`

```go
package main

import "fmt"
import "os"

func main() {
	argList := os.Args

	fmt.Printf("共有 %d 个参数\n", len(argList))

	for i, arg := range argList {
		fmt.Printf("argList[%d] = %s \n", i, arg)
	}
}
```

我们在终端中分别运行 `go run Day01.go` 和 `go run Day01.go a b` 时得到的结果如下：

```
cnpeng$ go run Day1.go 
共有 1 个参数
argList[0] = /var/folders/nh/6x0x58vx4rzfqf9x67__prrr0000gn/T/go-build330626485/b001/exe/Day1 

cnpeng$ go run Day1.go a b
共有 3 个参数
argList[0] = /var/folders/nh/6x0x58vx4rzfqf9x67__prrr0000gn/T/go-build217932374/b001/exe/Day1 
argList[1] = a 
argList[2] = b 
```

上述示例中，`go run` 是命令，后面用空格间隔的内容是参数。 

### 2.22. 2.22 .  局部变量特点-v23

* 作用域就是变量生效的范围
* 定义在 `{ }` 内部的变量为局部变量, 只在该 `{ }` 内有效

### 2.23. 2.23 .  全局变量-v24

* 定义在函数外部的变量称为全局变量
* 全局变量不能使用 `a := 10` 这种短声明方式

### 2.24. 2.24 .  不同作用域的同名变量-v25

* 调用时遵从就近原则

### 2.25. 2.25 .  工作区介绍-v26

工作区就是一个特定的目录。它包含三个子目录：
* src 目录：存放 .go 的源文件
* pkg 目录：存放经由 `go install` 命令安装的代码包（包括 Go 库源码文件）的 .a 归档文件
* bin 目录：存放 .go 生成的可执行程序

src 必须有，后两个可以省略

### 2.26. 导入包的使用-v27

* 使用 `package 包名` 在 .go 文件的第一行声明该文件的包名
* 使用 `import ”包名“` 导入其他包，导入某个包之后必须使用，否则不能编译
* 导入多个包时，可以使用下列方式：

```
import(
	"fmt"
	"os"
)
```

* 导包时可以给包起别名，然后就可以通过别名调用其中的成员。格式：`import 别名 "包名"`

* 还可以忽略包，格式：`import _ "包名"` ，表示只单纯的调用该包的 `init()` 函数，不调用其他内容。(后面会介绍 init() 函数)

* 导入包时也可以使用 `import . "fmt"` 的形式，然后引用 `Printf()` 时就不用写前缀 `fmt.` ,  但不推荐使用这种方式，容易导致混乱


### 2.27. 工程管理-同级目录-v28

* 同一个目录下的 .go 文件必须声明相同的包名
* 同目录下的 .go 文件可以互相调用内部的成员（包括属性和函数）

![](https://images.gitee.com/uploads/images/2019/0215/142155_a0f6ac1c_930142.png "屏幕截图.png")

上图中，我们先创建了一个 ItCast 文件夹，然后在其中创建了 main.go 和 Day2.go 两个文件。main.go 中定义了入口函数 main(), 该入口函数中直接引用定义在 Day2.go 中的函数和变量。

运行时我们直接输入 `go run .` 或 `go run main.go Day2.go` ，这两个命令能正确运行并得到我们想要的结果。

如果直接输入 `go run main.go` 只是单纯的构建并运行 main.go 文件，但是其中调用的函数和变量在 Day2.go 中，Day2.go 并没有编译和运行，所以会报错。

### 2.28. 工程管理-不同目录-v29

* 引用其他目录下 .go 文件中的内容时，需要先导入对应文件的包

#### 2.28.1.  引用不同包中的内容

在展示示例代码前，先在终端中运行 `go env` 查看一下 go 相关的环境配置。重点看其中是否配置了 `GOPATH`,如下图：

![](https://s2.ax1x.com/2019/02/15/kr9w2q.png)

如果没有配置 GOPATH , 需要先配置一个目录。(具体如何配置后续补充)

配置完之后，在该 GOPATH 目录下创建一个 src 目录，该目录下包含 带有入口函数的 main.go 和其他子目录，然后再按照下图中的目录结构编写代码内容：

![](https://images.gitee.com/uploads/images/2019/0215/154338_947264d8_930142.png "屏幕截图.png")

#### 2.28.2.  配置 GOPATH

##### 2.28.2.1. A: MAC 下配置 GOPATH 

*  先在终端中通过 `vim .bash_profile` 打开 vim 编辑器
*  然后输入如下内容

```
# GOPATH 后面换成自己需要的目录
export GOPATH=/usr/local/Cellar/go/1.7.6
export GOBIN=$GOPATH/bin
export PATH=$PATH:$GOBIN
```
* 然后保存退出，并在终端中执行 `source .bash_profile`命令

最后再运行 `go env` 命令，确认是否修改成功。

##### 2.28.2.2. B: Windows 环境下配置 GOPATH 的方法

![](https://images.gitee.com/uploads/images/2019/0215/154858_6dca06ee_930142.png "屏幕截图.png")

### 2.29. 2.29 .  init函数介绍-v30

Go 中有两个保留函数：init(）、main()

* 这两个函数会被系统主动调用，我们不需要手动去调
* 这两个函数都不能有任何的参数和返回值

#### 2.29.1.  init()

* 所有的包都可以有 init(）函数，并且是可选的
* 每个包中都可以定义任意多个 init()，
* 在程序开始执行时会先走 init()，也就是说 init() 先于 main() 执行。
* 通常用来 设置包、初始化变量 或者 做其他需要再程序运行前优先完成的一些工作

#### 2.29.2.  main()

* main(）: 作为程序的主入口，只能放在 `package main` 中

#### 2.29.3.  Go程序执行时导包和init()、main()的执行顺序

程序的初始化和执行都是从  package main 包。

如果 main 包中引用了其他的包，那么就会在编译时依次将它们导入。

如果某个包被其他的多个包引用，在程序运行时它只会被导入一次。也就是说，导入之后就存在内存中了，其他引用方直接用就可以了。

当一个包被导入时，如果该包中还引用了其他的包，那么会先将其他的包导入，然后再对这些包中的包级常量 和 变量进行初始化，接着执行 init(），依次类推。

所有需要引用的包都导入完毕后，就开始对 main 包中的包级常量和变量进行初始化，然后执行 main 包中的 init() 函数，最后执行 main(）函数。

关于上面描述的程序执行过程中导包和执行的过程，可参考下图：

 ![](https://images.gitee.com/uploads/images/2019/0215/225841_f7a05a22_930142.png "屏幕截图.png")

### 2.30. 30、go_install命令-v31

使用 go install 前需要先配置 GOBIN 目录，配置步骤参考 GOPATH 配置

略

---
## 3. 三、Day3

### 3.1.  Day2内容回顾

略

### 3.2.  变量的内存和变量的地址

复合类型的分类：

类型|名称|默认值|说明
---|---|---|---
pointer | 指针 | nil|
array | 数组 | 0 |
slice | 切片 | nil | 引用类型
map | 字典 | nil | 引用类型
struct | 结构体|||


**指针** 是一个内存地址的值。这个内存地址通常是内存中存储的另一个变量的值的起始位置。

```go
package main

import "fmt"

func main() {
	var a int = 10
	
	// 获取 a 的值
	fmt.Printf("a = %d \n", a)
	// 获取 a 在内存中的地址值——也就是指针
	fmt.Printf("&a = %v \n", &a)
}
```
运行结果：

```
cnpeng$ go run day3.go 
a = 10 
&a = 0xc000014078 
```

### 3.3.  指针变量的基本使用

使用指针类型 来 保存某个变量的内存地址（指针）。

- `* int ` 表示 int 的内存地址
- `** int ` 表示 ` *int ` 的内存地址

```go
package main

import "fmt"

func main() {
	var a = 10

	// 声明 int指针类型的变量 p, 其值为 &a ，也就是 a 的内存地址
	var p *int
	p = &a
	fmt.Printf(" p = %v , &a = %v \n\n", p, &a)

	//修改的是 p 对应的指针指向的变量——a。
	*p = 666
	fmt.Printf(" *p = %v , a = %v \n", *p, a)
}
```
运行结果：

```
cnpeng$ go run day3.go 
 p = 0xc000014078 , &a = 0xc000014078 
 
 *p = 666 , a = 666
```

### 3.4.  不要操作没有合法指向的指针

#### 3.4.1.  Go 中指针的特点

Go 语言虽然保留了指针，但是与其他编程语言不同的是：

- 默认值为  nil , 没有 NULL 常量
- `& 变量名` 表示 取指定变量的内存地址，`* 变量名` 表示 通过指针访问目标对象
- 直接用 `.` 访问目标成员，不支持指针运算，不支持 `->` 运算   

#### 3.4.2.  不要操作没有合法指向的指针

没有合法指向就是指 指针变量 对应的值为 nil.

如果指针变量为 nil , 那么，调用 `* 变量` 时会报错：非法内存地址或空引用

```go
package main

import "fmt"

func main() {
	var p *int
	fmt.Printf(" p = %v \n", p)

	// 报错：invalid memory address or nil pointer dereference
	// *p = 666
	// fmt.Printf(" *p = %v \n", *p)

	var a int
	// 为指针变量 p 赋值
	p = &a
	fmt.Printf(" p = %v \n", p)

	// 指针变量p 不为nil，此时可以使用 *p 指向其对应的变量
	*p = 666
	fmt.Printf(" *p = %v , a = %v \n", *p, a)
}
```

### 3.5.  new 函数的使用

`new(T)` 表示创建一个 T 类型的匿名变量，并为该匿名变量分配一块内存空间，然后将这块内存空间的地址作为结果返回，也就是返回该匿名变量的指针，返回的指针类型为 `*T`. 这本质上就是 动态分配内存空间。简单来说，就是创建一个 T 类型的指针变量


```go
package main

import "fmt"

func main() {
    var p *int
    var a int
    // 为指针变量 p 赋值
    p = &a
    fmt.Printf(" p = %v \n", p)
    *p = 666
    fmt.Printf(" *p = %v , a = %v \n\n", *p, a)

    p = new(int)
    fmt.Printf(" p = %v \n", p)
    *p = 777
    fmt.Printf(" *p = %v , a = %v \n\n", *p, a)

    // 指针变量的短声明模式，包含了类型推导
    q := new(int)
    *q = 888
    fmt.Printf(" *q = %v \n", *q)
}
```
运行结果：

```
cnpeng$ go run day3.go 
 p = 0xc000098000 
 *p = 666 , a = 666 

 p = 0xc000098020 
 *p = 777 , a = 666 

 *q = 888 
```


### 3.6.  值传递

普通变量作为函数参数，传递的是指——值传递

```go
package main

import "fmt"

func swap(arg1, arg2 int) {
	arg1, arg2 = arg2, arg1
	fmt.Printf("arg1 = %d, arg2 = %d \n", arg1, arg2)
}
func main() {
	a, b := 10, 20
	swap(a, b)
	fmt.Printf("a = %d, b = %d \n", a, b)
}
```

### 3.7.  地址传递

```go
package main

import "fmt"

func swap(p1, p2 *int) {
	// 将地址值对应的变量进行交换
	*p1, *p2 = *p2, *p1
}
func main() {
	a, b := 10, 20
	// 传递地址值作为参数
	swap(&a, &b)
	fmt.Printf("a = %d, b = %d \n", a, b)
}
```

### 3.8.  为什么需要数组

```go
package main

import "fmt"

func main() {
	//定义一个最大能包含 20 个 int 数据的数组
	var ids [20]int
	for i := 0; i < 10; i++ {
		ids[i] = i + 1
		fmt.Printf("ids[%d] = %d \n", i, ids[i])
	}
}
```

运行结果：

```
cnpeng$ go run day3.go 
ids[0] = 1 
ids[1] = 2 
ids[2] = 3 
ids[3] = 4 
ids[4] = 5 
ids[5] = 6 
ids[6] = 7 
ids[7] = 8 
ids[8] = 9 
ids[9] = 10 
```

### 3.9.  数组的基本操作

定义数组时，数组元素个数必须为常量。

对于数组变量来说，它的类型为 `[x]元素类型`

```go
package main

import "fmt"

func main() {
	//定义一个最大能包含 20 个 int 数据的数组
	var ids [20]int
	fmt.Printf("ids的长度为：%d \n", len(ids))

	// a := 10
	// 报错 no constant array bound
	// var ids2 [a]int

	// 赋值
	for i := 0; i < len(ids); i++ {
		ids[i] = i + 1
	}

	// 遍历
	for i, data := range ids {
		fmt.Printf(" ids[%d] = %d \n", i, data)
	}
}
```


### 3.10.  数组初始化

```go
package main

import "fmt"

func main() {

	//  声明数组的同时初始化
	var ids [5]int = [5]int{1, 2, 3, 4, 5}
	// 1- 创建的同时初始化, [] 中也可以使用  ...
	// ids := [...]int{1, 2, 3, 4}

	//  短声明
	ids2 := [5]int{1, 2, 3, 4, 5}
	//  部分声明，未声明的取元素类型默认值
	ids3 := [5]int{1, 2, 3}
	//  指定初始某个元素。冒号前为索引，后为元素值
	ids4 := [5]int{2: 1, 3: 2}

	for i, data := range ids {
		fmt.Printf(" ids[%d] = %d \n", i, data)
	}

	fmt.Println()
	for i, data := range ids2 {
		fmt.Printf(" ids2[%d] = %d \n", i, data)
	}
	fmt.Println()
	for i, data := range ids3 {
		fmt.Printf(" ids3[%d] = %d \n", i, data)
	}
	fmt.Println()
	for i, data := range ids4 {
		fmt.Printf(" ids4[%d] = %d \n", i, data)
	}
}
```

运行结果：

```
cnpeng$ go run day3.go 
 ids[0] = 1 
 ids[1] = 2 
 ids[2] = 3 
 ids[3] = 4 
 ids[4] = 5 

 ids2[0] = 1 
 ids2[1] = 2 
 ids2[2] = 3 
 ids2[3] = 4 
 ids2[4] = 5 

 ids3[0] = 1 
 ids3[1] = 2 
 ids3[2] = 3 
 ids3[3] = 0 
 ids3[4] = 0 

 ids4[0] = 0 
 ids4[1] = 0 
 ids4[2] = 1 
 ids4[3] = 2 
 ids4[4] = 0 
```
### 3.11.  二维数组的介绍

#### 3.11.1.  二维数组基本格式
```go
package main

import "fmt"

func main() {
	var ids [3][2]int
	k := 0

	for i := 0; i < 3; i++ {
		for j := 0; j < 2; j++ {
			k++
			ids[i][j] = k
			fmt.Printf(" ids[%d][%d] = %d \n", i, j, k)
		}
		fmt.Println()
	}
}
```

运行结果：

```
cnpeng$ go run day3.go 
 ids[0][0] = 1 
 ids[0][1] = 2 

 ids[1][0] = 3 
 ids[1][1] = 4 

 ids[2][0] = 5 
 ids[2][1] = 6 
```
#### 3.11.2.  二维数组格式化

```go
package main

func main() {
	//  声明的同时初始化
	ids := [3][2]int{{1, 2}, {3, 4}, {5, 6}}

	//  部分初始化. 第三个一维数组中的元素全都为默认值
	ids2 := [3][2]int{{1, 2}, {3, 4}}

	//  部分初始化2。第二个一维数组第二个元素，以及第三个一维数组元素值均为默认值
	ids3 := [3][2]int{{1, 2}, {3}}

	//  指定初始化。指定初始化索引为1的元素，其他元素全都使用默认值
	ids4 := [3][2]int{1: {3, 4}}
	
	// 其他内容省略
}
```

### 3.12. 3.12 .  数组比较和赋值

同类型并且长度相同的数组可以通过 `==`、`!=` 进行比较

```go
 package main

import (
	"fmt"
)

func main() {
	ids := [3]int{1, 2, 3}
	ids1 := [3]int{1, 2, 3}
	ids2 := [3]int{1, 2}

	fmt.Println(ids == ids1, ids1 == ids2)

	ids3 := ids2
	fmt.Println(ids3)
}
```

### 3.13. 3.13 .  随机数的使用

```go
package main

import (
	"fmt"
	"math/rand"
	"time"
)

func main() {
	// Seed() 函数的参数是常量时，多次次运行 main() 后得到的随机数据一致
	rand.Seed(665)
	for i := 0; i < 5; i++ {
		// 调用 rand.Int() 时会得到较大的随机值
		fmt.Println(rand.Int())
	}

	// Seed() 参数每次都不一样时，多次运行 main() 才能得到不同的数据
	rand.Seed(time.Now().UnixNano())
	for j := 0; j < 5; j++ {
		// rand.Intn(xx) 限定数值在 xx 以内
		fmt.Println(rand.Intn(100))
	}
}
```

### 3.14.  冒泡排序原理

每挨着的两个数进行比较，将大值放到后面。

假设有一个四个元素的数组，那么：

- 第一轮比较时：会比较三次，分别是 0/1 , 1/2 , 2/3 得出最大值
- 第二轮比较时，会比较2次，分别是：0/1 , 1/2 得出第二个大值
- 第三轮比较时，会比较一次，为：0/1 得出最小值和第二小值

综上，对于有 n 个元素的数组来说，它需要比较 n-1 轮，每一轮内部需要比较的次数+轮数 = n


### 3.15.  冒泡排序代码实现

```go
package main

import (
	"fmt"
	"math/rand"
	"time"
)

func main() {
	intNums := [5]int{}
	rand.Seed(time.Now().UnixNano())

	for a := 0; a < 5; a++ {
		intNums[a] = rand.Intn(100)
	}

	fmt.Println("排序前：", intNums)

	// 需要比较 len(intNums)-1 轮
	for i := 0; i < len(intNums)-1; i++ {
		// 第 i 轮需要比较 len(intNums)-1-i 次
		for j := 0; j < len(intNums)-1-i; j++ {
			if intNums[j] > intNums[j+1] {
				intNums[j], intNums[j+1] = intNums[j+1], intNums[j]
			}
		}
	}

	fmt.Println("排序后：", intNums)
}
```

运行结果：

```
cnpeng$ go run day3.go 
排序前： [66 32 37 10 26]
排序后： [10 26 32 37 66]
cnpeng$ go run day3.go 
排序前： [75 93 97 10 89]
排序后： [10 75 89 93 97]
cnpeng$ go run day3.go 
排序前： [90 51 46 22 71]
排序后： [22 46 51 71 90]
```
### 3.16.  数组做函数参数是值传递

```go
package main

import (
	"fmt"
)

func changeEle(arr [5]int) {
	arr[0] = 666
	fmt.Printf(" arr[0] = %d\n", arr[0])
}

func main() {
	intNums := [5]int{1, 2, 3}
	fmt.Printf(" intNums 的类型为：%T \n", intNums)

	changeEle(intNums)
	fmt.Printf(" intNums[0] = %d\n", intNums[0])
}
```

运行结果：

```
cnpeng$ go run day3.go 
 intNums 的类型为：[5]int 
 arr[0] = 666
 intNums[0] = 1
```
### 3.17.  数组指针做函数参数

```go
package main

import (
	"fmt"
)

func changeEle(arr *[5]int) {
	// 注意此处使用小括号包裹内容： （*arr）
	(*arr)[0] = 666
	fmt.Printf(" *arr[0] = %d\n", (*arr)[0])
}

func main() {
	intNums := [5]int{1, 2, 3}
	fmt.Printf(" intNums 的类型为：%T \n", intNums)

	changeEle((&intNums))
	fmt.Printf(" intNums[0] = %d\n", intNums[0])
}
```

### 3.18.  切片介绍——slice

由于数组大小固定，所以引入切片

切片通过内部指针和相关属性引用数组片段，以实现边长

在写法上来看：切片不需要在 `[ ]`中指定长度，数组则需要在其中指定长度

```go
package main

import (
	"fmt"
)

func main() {
	intNums := [5]int{1, 2, 3, 4, 5}
	fmt.Printf(" intNums 的类型为：%T \n", intNums)

	// 从现有数组中获取切片：[0:3:5] 从原数组0索引开始取，取到 3 索引（不含3），该切片的容量为 5（不能超过原数组长度）
	intSlice := intNums[0:3:5]
	fmt.Printf(" intSlice 的类型为：%T \n", intSlice)
	fmt.Println(" intSlice = ", intSlice)
	// 获取长度和容量
	fmt.Printf(" len(intSlice) = %d, cap(intSlice) = %d \n", len(intSlice), cap(intSlice))
}
```
运行结果：

```
cnpeng$ go run day3.go 
 intNums 的类型为：[5]int 
 intSlice 的类型为：[]int 
 intSlice =  [1 2 3]
 len(intSlice) = 3, cap(intSlice) = 5 
```


`arr[low : high : max]` 这个格式表示获取指定数组的切片，其中

- arr 表示目标数组，low 表示目标数组中取切片的起始索引，high 为终止索引——但不包含该索引，max 为切片容量——不能大于目标数组的容量。 
- `high - low` 可以获取切片的长度，等效于  `len(slice)` ,
- `max - low` 可以获取切片的容量，等小于 `cap(slice)`

### 3.19.  数组和切片区别

- 数组长度固定，容量固定，不能追加元素
- 切片长度和容量可变，可以通过 append( , ) 追加内容

```go
package main

import (
	"fmt"
)

func main() {
	// 声明一个空数组
	intNums := [5]int{}
	fmt.Printf(" len(intNums) = %d, cap(intNums) = %d \n", len(intNums), cap(intNums))

	// 声明一个空切片
	intSlice := []int{}
	fmt.Printf(" len(intSlice) = %d, cap(intSlice) = %d \n", len(intSlice), cap(intSlice))
	// 在切片末尾追加一个元素
	intSlice = append(intSlice, 66)
	fmt.Printf(" len(intSlice) = %d, cap(intSlice) = %d \n", len(intSlice), cap(intSlice))
}
```
运行结果：

```
cnpeng$ go run day3.go 
 len(intNums) = 5, cap(intNums) = 5 
 len(intSlice) = 0, cap(intSlice) = 0 
 len(intSlice) = 1, cap(intSlice) = 1 
```

### 3.20.  切片的创建

```go
package main

func main() {
	//  创建的同时初始化, [] 中为空
	slice1 := []int{1, 2, 3, 4}

	//  使用 make(切片类型, 长度, 容量) 创建切片
	slice2 := make([]int, 5, 10)

	//  使用 make 不指定容量时，长度==容量
	slice3 := make([]int, 5)

	// ...
}
```

### 3.21.  切片截取

操作|含义
---|---
s[n] | 获取指定索引位置的数据
s[:] | 获取全部元素
s[low:] | 获取 low 到末尾的数据
s[:high] | 获取 0 索引到 high 的数据, 前闭后开
s[low:high] | 获取 low 到 high 之间的数据，前闭后开
s[low:high:max] | 获取 low 到 high 之间的数据，前闭后开，并指定容量为 max
len(s) | 获取长度
cap(s) | 获取容量



### 3.22.  切片和底层数组关系

切片持有数组的引用

```go
package main

import "fmt"

func main() {
	arr := [6]int{1, 2, 3, 4, 5, 6}

	//  获取切片并修改切片中的元素值
	slice1 := arr[0:2]
	slice1[1] = 222
	fmt.Println("arr = ", arr)

	slice2 := arr[0:3]
	slice2[1] = 2222
	fmt.Println("arr = ", arr)
	fmt.Println("slice1 = ", slice1)
}
```

运行结果

```
cnpeng$ go run day3.go 
arr =  [1 222 3 4 5 6]
arr =  [1 2222 3 4 5 6]
slice1 =  [1 2222]
```

### 3.23. append函数的使用

```go
package main

import "fmt"

func main() {
	slice1 := []int{}
	fmt.Println("slice1 = ", slice1, "长度：", len(slice1), "容量：", cap(slice1))

	slice1 = append(slice1, 1)
	fmt.Println("slice1 = ", slice1, "长度：", len(slice1), "容量：", cap(slice1))
	slice1 = append(slice1, 2)
	fmt.Println("slice1 = ", slice1, "长度：", len(slice1), "容量：", cap(slice1))
	slice1 = append(slice1, 3)
	fmt.Println("slice1 = ", slice1, "长度：", len(slice1), "容量：", cap(slice1))
	slice1 = append(slice1, 4)
	fmt.Println("slice1 = ", slice1, "长度：", len(slice1), "容量：", cap(slice1))

	fmt.Println()

	slice2 := []int{1, 2, 3}
	fmt.Println("slice2 = ", slice2, "长度：", len(slice2), "容量：", cap(slice2))
	slice2 = append(slice2, 4)
	fmt.Println("slice2 = ", slice2, "长度：", len(slice2), "容量：", cap(slice2))
	slice2 = append(slice2, 5)
	fmt.Println("slice2 = ", slice2, "长度：", len(slice2), "容量：", cap(slice2))
}
```

运行结果:

```
cnpeng$ go run day3.go 
slice1 =  [] 长度： 0 容量： 0
slice1 =  [1] 长度： 1 容量： 1
slice1 =  [1 2] 长度： 2 容量： 2
slice1 =  [1 2 3] 长度： 3 容量： 4
slice1 =  [1 2 3 4] 长度： 4 容量： 4

slice2 =  [1 2 3] 长度： 3 容量： 3
slice2 =  [1 2 3 4] 长度： 4 容量： 6
slice2 =  [1 2 3 4 5] 长度： 5 容量： 6
```

### 3.24. append扩容特点

通过 append() 函数追加切片内容时，如果，超过了切片原有的容量，那么追加后切片的新容量会是原有容量的 2 倍。

```go
package main

import "fmt"

func main() {
	slice1 := make([]int, 0, 1)

	oldcap := cap(slice1)

	for i := 0; i < 10; i++ {
		slice1 = append(slice1, i)
		if newcap := cap(slice1); newcap > oldcap {
			fmt.Printf("oldcap = %d, newcap = %d \n", oldcap, newcap)
			oldcap = newcap
		}
	}
}
```

运行结果：

```
cnpeng$ go run day3.go 
oldcap = 1, newcap = 2 
oldcap = 2, newcap = 4 
oldcap = 4, newcap = 8 
oldcap = 8, newcap = 16 
```

### 3.25. copy的使用

```go
package main

import "fmt"

func main() {
	srcSlice := []int{1, 2}
	dstSlice := []int{6, 6, 6, 6, 6}

	// 拷贝切片。第一个参数为目标，第二个参数为源，把源拷贝到目标中
	copy(dstSlice, srcSlice)
	fmt.Println("dstSlice = ", dstSlice)
}
```

运行结果：

```
cnpeng$ go run day3.go 
dstSlice =  [1 2 6 6 6]
```

### 3.26. 切片做函数参数

数组是值传递，切片是引用传递

```go
package main

import (
	"fmt"
	"math/rand"
	"time"
)

func initSlice(s []int) {
	// 创建随机种子，以时间为种子，保证多次运行该函数时能获取不同数据
	rand.Seed(time.Now().UnixNano())

	for i := 0; i < len(s); i++ {
		// 获取100以内的随机值
		s[i] = rand.Intn(100)
	}
}

func sortEle(s []int){
	// 总共遍历的轮数
	for i := 0; i < len(s)-1; i++ {
		// 每一轮遍历的次数
		for j := 0; j < len(s)-1-i; j++ {
			if s[j] > s[j+1] {
				s[j], s[j+1] = s[j+1], s[j]
			}
		}
	}
}

func main() {
	n := 10
	slice1 := make([]int, n)
	initSlice(slice1)

	fmt.Println("排序前：slice1 = ", slice1)

	sortEle(slice1)

	fmt.Println("排序后：slice1 = ", slice1)
}
```

运行结果：

```
cnpeng$ go run day3.go 
排序前：slice1 =  [78 51 1 72 30 45 9 72 19 40]
排序后：slice1 =  [1 9 19 30 40 45 51 72 72 78]
```

### 3.27. 猜数字：产生一个随机的4位数

```go
package main

import (
	"fmt"
	"math/rand"
	"time"
)

func initRandNum(p *int) {
	rand.Seed(time.Now().UnixNano())
	var num int
	for {
		num = rand.Intn(10000)
		if num >= 1000 {
			break
		}
	}
	*p = num
}
func main() {
	var randNum int
	initRandNum(&randNum)
	fmt.Println("randNum = ", randNum)
}
```

### 3.28. 猜数字：取出每一位数

```go
package main

import (
	"fmt"
	"math/rand"
	"time"
)

func initRandNum(p *int) {
	rand.Seed(time.Now().UnixNano())
	var num int
	for {
		num = rand.Intn(10000)
		if num >= 1000 {
			break
		}
	}
	*p = num
}

// num 为一个4位数, slice 为一个长度为4的切片
func initNumSlice(num int, slice []int) {
	// 取千位
	slice[0] = num / 1000
	// 取百位
	slice[1] = num % 1000 / 100
	// 取10位
	slice[2] = num % 100 / 10
	// 取个位
	slice[3] = num % 10
}

func main() {
	var randNum int
	initRandNum(&randNum)
	fmt.Println("randNum = ", randNum)

	numSlice := make([]int, 4)
	initNumSlice(randNum, numSlice)
	fmt.Println("numSlice = ", numSlice)
}
```
运行结果：

```
cnpeng$ go run day3.go 
randNum =  7161
numSlice =  [7 1 6 1]
```

### 3.29. 猜数字：输入一个4位数并取出每一位

```go
package main

import (
	"fmt"
	"math/rand"
	"time"
)

func initRandNum(p *int) {
	rand.Seed(time.Now().UnixNano())
	var num int
	for {
		num = rand.Intn(10000)
		if num >= 1000 {
			break
		}
	}
	*p = num
}

// num 为一个4位数, slice 为一个长度为4的切片
func initNumSlice(num int, slice []int) {
	// 取千位
	slice[0] = num / 1000
	// 取百位
	slice[1] = num % 1000 / 100
	// 取10位
	slice[2] = num % 100 / 10
	// 取个位
	slice[3] = num % 10
}

func OnPlaying(slice []int) {
	var num int

	for {
		fmt.Println("请输入一个4位数：")
		fmt.Scan(&num)

		if 999 < num && num < 10000 {
			break
		}
	}

	fmt.Println("num = ", num)
	initNumSlice(num, slice)
}

func main() {
	var randNum int
	initRandNum(&randNum)
	fmt.Println("randNum = ", randNum)

	numSlice := make([]int, 4)
	initNumSlice(randNum, numSlice)
	fmt.Println("numSlice = ", numSlice)

	inputSlice := make([]int, 4)
	OnPlaying(inputSlice)
}
```

### 3.30. 猜数字：逻辑处理

核心内容

```go
func OnPlaying(randSlice []int) {
	//  获取用户输入并转成切片
	var num int
	inputSlice := make([]int, 4)

	for {

		for {
			fmt.Println("请输入一个4位数：")
			fmt.Scan(&num)

			if 999 < num && num < 10000 {
				break
			}
		}

		fmt.Println("num = ", num)
		initNumSlice(num, inputSlice)

		//  比较并统计
		n := 0

		for i := 0; i < len(inputSlice); i++ {
			if inputSlice[i] > randSlice[i] {
				fmt.Printf("第 %d 位大了\n", i)
			} else if inputSlice[i] < randSlice[i] {
				fmt.Printf("第 %d 位小了\n", i)
			} else {
				fmt.Printf("第 %d 猜对了\n", i)
				n++
			}
		}
		if n == 4 {
			fmt.Println("全猜对了")
			break
		}
	}
}
```

完整代码：

```go
package main

import (
	"fmt"
	"math/rand"
	"time"
)

func initRandNum(p *int) {
	rand.Seed(time.Now().UnixNano())
	var num int
	for {
		num = rand.Intn(10000)
		if num >= 1000 {
			break
		}
	}
	*p = num
}

// num 为一个4位数, slice 为一个长度为4的切片
func initNumSlice(num int, slice []int) {
	// 取千位
	slice[0] = num / 1000
	// 取百位
	slice[1] = num % 1000 / 100
	// 取10位
	slice[2] = num % 100 / 10
	// 取个位
	slice[3] = num % 10
}

func OnPlaying(randSlice []int) {
	//  获取用户输入并转成切片
	var num int
	inputSlice := make([]int, 4)

	for {

		for {
			fmt.Println("请输入一个4位数：")
			fmt.Scan(&num)

			if 999 < num && num < 10000 {
				break
			}
		}

		fmt.Println("num = ", num)
		initNumSlice(num, inputSlice)

		//  比较并统计
		n := 0

		for i := 0; i < len(inputSlice); i++ {
			if inputSlice[i] > randSlice[i] {
				fmt.Printf("第 %d 位大了\n", i)
			} else if inputSlice[i] < randSlice[i] {
				fmt.Printf("第 %d 位小了\n", i)
			} else {
				fmt.Printf("第 %d 猜对了\n", i)
				n++
			}
		}
		if n == 4 {
			fmt.Println("全猜对了")
			break
		}
	}
}

func main() {
	var randNum int
	initRandNum(&randNum)
	fmt.Println("randNum = ", randNum)

	numSlice := make([]int, 4)
	initNumSlice(randNum, numSlice)
	fmt.Println("numSlice = ", numSlice)

	OnPlaying(numSlice)
}

```

运行结果：

```
cnpeng$ go run day3.go 
randNum =  5364
numSlice =  [5 3 6 4]
请输入一个4位数：
1253
num =  1253
第 0 位小了
第 1 位小了
第 2 位小了
第 3 位小了
请输入一个4位数：
5364
num =  5364
第 0 猜对了
第 1 猜对了
第 2 猜对了
第 3 猜对了
全猜对了
```


### 3.31. map介绍

可翻译为 字典、映射

map 无序。 

map 的键不能是切片或者函数
 

### 3.32. map的基本操作

`cap（）` 函数不适用于 map, map 只能取 len()


```go
package main

import "fmt"

func main() {
	//  基本声明格式
	var map1 map[int]string
	fmt.Println("map1 = ", map1, "map1的长度为：", len(map1))

	//  使用make
	map2 := make(map[int]string)
	fmt.Println("map2 = ", map2, "map2的长度为：", len(map2))

	//  指定长度——该长度只是用来创建map的时候预置内存空间，len() 取的是实际元素数量
	map3 := make(map[int]string, 10)
	fmt.Println("map3 = ", map3, "map3的长度为：", len(map3))
	map3[1] = "张三"
	fmt.Println("map3 = ", map3, "map3的长度为：", len(map3))
}
```

运行结果：

```
cnpeng$ go run day3.go 
map1 =  map[] map1的长度为： 0
map2 =  map[] map2的长度为： 0
map3 =  map[] map3的长度为： 0
map3 =  map[1:张三] map3的长度为： 1
```
### 3.33. map赋值

```go
package main

import "fmt"

func main() {

	map1 := map[int]string{1: "张三", 2: "李四"}
	fmt.Println("map1 = ", map1)

	// 修改键 1 对应的值
	map1[1] = "王五"
	fmt.Println("map1 = ", map1)

	// 为 map1 追加一个键为3，值为 ”王二麻子“的键值对
	map1[3] = "王二麻子"
	fmt.Println("map1 = ", map1)
}
```

运行结果：

```
cnpeng$ go run day3.go 
map1 =  map[1:张三 2:李四]
map1 =  map[1:王五 2:李四]
map1 =  map[3:王二麻子 1:王五 2:李四]
```

### 3.34. map遍历

```go
package main

import "fmt"

func main() {

	map1 := map[int]string{1: "张三", 2: "李四", 3: "王二麻子"}

	// 遍历
	for key, value := range map1 {
		fmt.Println(key, "|", value)
	}

	// 判断是否存在某个键。
	// value 表示如果存在时对应的值，isExist 表示是否存在——存在 true，不存在 false
	value, isExist := map1[1]
	if isExist {
		fmt.Println("map1 中存在键 1, 对应的值为： ", value)
	} else {
		fmt.Println("map1 中不存在键 1")
	}
}
```

运行结果：

```
cnpeng$ go run day3.go 
1 | 张三
2 | 李四
3 | 王二麻子
map1 中存在键 1, 对应的值为：  张三
```

### 3.35. map删除

```go
package main

import "fmt"

func main() {

	map1 := map[int]string{1: "张三", 2: "李四", 3: "王二麻子"}
	fmt.Println(map1)

	// 调用 delete 函数删除 map 中的元素
	// 第一个参数为被操作的 map,第二个参数为 map 中的键
	delete(map1, 2)
	fmt.Println(map1)
}
```

运行结果：

```
cnpeng$ go run day3.go 
map[2:李四 3:王二麻子 1:张三]
map[3:王二麻子 1:张三]
```
### 3.36. map做函数参数

map 做函数参数时 是 引用传递

```go
package main

import "fmt"

func test(m map[int]string) {
	// 调用 delete 函数删除 map 中的元素
	// 第一个参数为被操作的 map,第二个参数为 map 中的键
	delete(m, 2)
}

func main() {

	map1 := map[int]string{1: "张三", 2: "李四", 3: "王二麻子"}
	fmt.Println(map1)

	test(map1)
	fmt.Println(map1)
}
```

运行结果：

```
cnpeng$ go run day3.go 
map[1:张三 2:李四 3:王二麻子]
map[1:张三 3:王二麻子]
```

### 3.37. 结构体普通变量初始化

```go
package main

import (
	"fmt"
)

type Student struct {
	id   int
	name string
	// 字符类型
	sex  byte
	age  int
	addr string
}

func main() {

	//  顺序初始化，所有成员必须有值
	var student1 = Student{999, "张三", 'm', 19, "山东济南"}
	fmt.Println(student1)

	//  具名初始化——未初始化的成员使用默认值
	student2 := Student{id: 777, name: "李四"}
	fmt.Println(student2)
}
```

运行结果：

```
cnpeng$ go run day3.go 
{999 张三 109 19 山东济南}
{777  0 0 }
```

### 3.38. 结构体指针变量初始化

```go
package main

import (
	"fmt"
)

type Student struct {
	id   int
	name string
	// 字符类型
	sex  byte
	age  int
	addr string
}

func main() {

	var student1 *Student = &Student{999, "张三", 'm', 19, "山东济南"}
	fmt.Println(student1)

	student2 := &Student{id: 777, name: "李四"}
	fmt.Println(student2)
	fmt.Printf("student2 的类型是 %T\n", student2)
}
```

运行结果：

```
cnpeng$ go run day3.go 
&{999 张三 109 19 山东济南}
&{777 李四 0 0 }
student2 的类型是 *main.Student
```


### 3.39. 结构体成员的使用：普通变量

使用 `.` 运算符

```go
package main

import "fmt"

type Student struct {
	id   int
	name string
	// 字符类型
	sex  byte
	age  int
	addr string
}

func main() {

	// 声明一个结构体类型的变量
	var student1 Student

	// 为结构体成员赋值
	student1.id = 666
	student1.name = "张三"
	student1.sex = 'F'
	student1.age = 22
	student1.addr = "山东威海"

	fmt.Println(student1)
}
```

运行结果：

```
cnpeng$ go run day3.go 
{666 张三 70 22 山东威海}
```
### 3.40. 结构体成员的使用：指针变量

指针有合法指向后才可以操作对应的成员.

// 通过指针为结构体成员赋值时，有两种方式 指针.成员 或 (*指针).成员

```go
package main

import "fmt"

type Student struct {
	id   int
	name string
	// 字符类型
	sex  byte
	age  int
	addr string
}

func main() {
	var student1 Student
	// 声明指针类型的变量
	var p1 *Student
	p1 = &student1

	// 通过指针为结构体成员赋值时，有两种方式 指针.成员 或 (*指针).成员
	p1.id = 666
	(*p1).name = "张三"

	fmt.Println(student1)
	fmt.Println(p1)

	// 声明指针变量的方式2
	p2 := new(Student)
	p2.name = "李四"
	(*p2).id = 999
	fmt.Println(p2)
}
```

运行结果：

```
cnpeng$ go run day3.go 
{666 张三 0 0 }
&{666 张三 0 0 }
&{999 李四 0 0 }
```


### 3.41. 结构体比较和赋值

如果结构体的全部成员都是可以比较的，那么结构体也是可以比较的。

可以使用 `==` 和 `!=` ，但不能使用 `< 、>`

```go
package main

import "fmt"

type Student struct {
	id   int
	name string
	// 字符类型
	sex  byte
	age  int
	addr string
}

func main() {
	student1 := Student{666, "张三", 'M', 22, "济南"}
	student2 := Student{666, "张三", 'M', 22, "济南"}
	student3 := Student{id: 666, name: "李四"}

	// 结构体比较
	fmt.Println("student1==student2 ", student1 == student2)
	fmt.Println("student1==student3", student1 == student3)

	// 同类型结构体赋值
	student2 = student3
	fmt.Println(student2)
}
```

运行结果：

```
cnpeng$ go run day3.go 
student1==student2  true
student1==student3 false
{666 李四 0 0 }
```

### 3.42. 结构体做函数参数：值传递

```go
package main

import "fmt"

type Student struct {
	id   int
	name string
	// 字符类型
	sex  byte
	age  int
	addr string
}

func changeStuInfo(stu Student) {
	stu.name = "李四"
}

func main() {
	student1 := Student{666, "张三", 'M', 22, "济南"}

	changeStuInfo(student1)

	fmt.Println("student1 =  ", student1)
}
```

运行结果：

```
cnpeng$ go run day3.go 
student1 =   {666 张三 77 22 济南}
```

### 3.43. 结构体做函数参数：地址传递

```go
package main

import "fmt"

type Student struct {
	id   int
	name string
	// 字符类型
	sex  byte
	age  int
	addr string
}

func changeStuInfo(stu *Student) {
	stu.name = "李四"
}

func main() {
	student1 := Student{666, "张三", 'M', 22, "济南"}

	changeStuInfo(&student1)

	fmt.Println("student1 =  ", student1)
}
```

运行结果：

```
cnpeng$ go run day3.go 
student1 =   {666 李四 77 22 济南}
```

### 3.44. go语言可见性规则验证

Go 中没有 private 、protected、public 这些关键字

要使某个符号对其他包（package）可见，需要将该符号定义为大写字母开头；如果小写的话，只能在当前包内使用





---
## 4. 四、Day4

### 4.1.  昨日回顾

略

### 4.2.  面向对象编程

Go 中没有封装、继承、多态的概念，但是，通过别的形式可以达到同等效果

- 方法——封装
- 匿名字段——继承
- 接口——多态
 
### 4.3.  匿名字段作用

匿名字段 也叫 匿名组合、嵌入字段。

在 Student 结构体中，我们定义了匿名字段 Person , 这样，Student 就包含了 Person 的全部成员

```go

type Person struct {
	name string
	sex  byte
	age  int
}

type Student struct {
	// 只有类型，没有字段——这里的 Person 就是匿名字段，体现了继承的特点
	Person

	id   int
	addr string
}
``` 


### 4.4.  匿名字段初始化

```go

package main

import "fmt"

type Person struct {
	name string
	sex  byte
	age  int
}

type Student struct {
	// 只有类型，没有字段——这里的 Person 就是匿名字段，体现了继承的特点
	Person

	id   int
	addr string
}

func main() {
	//  顺序初始化
	student1 := Student{Person{"张三", 'm', 22}, 999, "济南"}
	fmt.Println("student1 = ", student1)
	// %+v 用来显示详细信息
	fmt.Printf("student1 = %+v \n\n ", student1)

	// 2- 具名初始化
	student2 := Student{id: 999, addr: "济南"}
	fmt.Println("student2 = ", student2)
	fmt.Printf("student2 = %+v \n\n ", student2)

	// 2- 具名初始化
	student3 := Student{Person: Person{name: "李四"}, addr: "济南"}
	fmt.Println("student3 = ", student3)
	fmt.Printf("student3 = %+v \n\n ", student3)
}
```

运行结果:

```
cnpeng$ go run day3.go 
student1 =  {{张三 109 22} 999 济南}
student1 = {Person:{name:张三 sex:109 age:22} id:999 addr:济南} 

 student2 =  {{ 0 0} 999 济南}
student2 = {Person:{name: sex:0 age:0} id:999 addr:济南} 

 student3 =  {{李四 0 0} 0 济南}
student3 = {Person:{name:李四 sex:0 age:0} id:0 addr:济南} 
```


### 4.5.  成员操作

```go
package main

import "fmt"

type Person struct {
	name string
	sex  byte
	age  int
}

type Student struct {
	// 只有类型，没有字段——这里的 Person 就是匿名字段，体现了继承的特点
	Person

	id   int
	addr string
}

func main() {
	student1 := Student{Person{"张三", 'm', 22}, 999, "济南"}

	student1.Person = Person{"李四", 'f', 25}
	fmt.Println("student1 = ", student1)

	student1.name = "王五"

	fmt.Println("student1 = ", student1)
}
```

运行结果：

```
 cnpeng$ go run day3.go 
student1 =  {{王五 102 25} 999 济南}
student1 = {Person:{name:王五 sex:102 age:25} id:999 addr:济南} 
```

### 4.6.  同名字段

```go
package main

import "fmt"

type Person struct {
	name string
	sex  byte
	age  int
}

type Student struct {
	Person

	id   int
	addr string
	// 同名字段
	name string
}

func main() {
	student1 := Student{Person{"张三", 'm', 22}, 999, "济南", "张小三"}

	// 结构体和其内部的匿名字段具有相同字段时，优先使用当前结构体中的字段
	student1.name = "李小四"
	fmt.Println("student1 = ", student1)

	// 具有同名字段时，需要显示调用匿名字段中的同名字段
	student1.Person.name = "李四"
	fmt.Println("student1 = ", student1)
}
```

运行结果：

```
cnpeng$ go run day3.go 
student1 =  {{张三 109 22} 999 济南 李小四}
student1 =  {{李四 109 22} 999 济南 李小四}
```

### 4.7.  非结构体类型的匿名字段

```go
package main

import "fmt"

type myStr string

type Person struct {
	name string
	sex  byte
	age  int
}

type Student struct {
	// 匿名字段为结构体
	Person
	// 匿名字段为基本数据类型
	int
	// 匿名字段为带有别名的类型
	myStr
}

func main() {
	student1 := Student{Person{"张三", 'm', 22}, 999, "济南"}

	student1.int = 777
	student1.myStr = "泰安"

	fmt.Printf("student1 = %+v \n", student1)
}
```

运行结果：

```
cnpeng$ go run day3.go 
student1 = {Person:{name:张三 sex:109 age:22} int:777 myStr:泰安} 
```

### 4.8.  结构体指针类型匿名字段

```go
package main

import "fmt"

type myStr string

type Person struct {
	name string
	sex  byte
	age  int
}

type Student struct {
	*Person
	int
	myStr
}

func main() {
	student1 := Student{&Person{"张三", 'm', 22}, 999, "济南"}
	fmt.Printf("student1 = %+v \n", student1)
	fmt.Printf("student1.name = %s ,student1.age = %d \n\n", student1.name, student1.age)

	var student2 Student
	student2.Person = new(Person)
	student2.name = "李四"
	student2.age = 24
	fmt.Printf("student2 = %+v \n", student2)
	fmt.Printf("student2.name = %s ,student2.age = %d \n", student2.name, student2.age)
}
````

运行结果：

```
cnpeng$ go run day3.go 
student1 = {Person:0xc000096020 int:999 myStr:济南} 
student1.name = 张三 ,student1.age = 22 

student2 = {Person:0xc000096060 int:0 myStr:} 
student2.name = 李四 ,student2.age = 24 
```

###  方法介绍

方法是函数的一种。

方法总是绑定对象实例，并隐式的将实例作为第一个实参，其格式为:

```go
func (receiver ReceiverType) funcName(parameters)(results)

```

- 参数 receiver 可以任意命名，如果方法中没有使用，可以省略参数名
- 参数 receiver 类型可以是 T 或者 *T 。 基类型 T 不能是接口或指针
- 不支持重载方法，也就是说，不能定义名字相同但参数不同的方法



### 4.9.  面向过程和面向对象函数区别

```go
package main

import "fmt"

// 面向过程的普通函数
func add1(a, b int) int {
	return a + b
}

// cannot define new methods on non-local type int
// func (obj int) add2(b int) int {
// 	return obj + b
// }

type myInt int

// 面向对象的方法——与某个类的实例绑定
func (obj myInt) add2(b myInt) myInt {
	return obj + b
}

func main() {
	result1 := add1(1, 3)
	fmt.Println("result1 = ", result1)

	var a myInt = 10
	// 调用方法时，使用类的实例进行调用
	result2 := a.add2(4)
	fmt.Println("result2 = ", result2)
}
```

运行结果:

```
cnpeng$ go run day3.go 
result1 =  4
result2 =  14
```

### 4.10. 结构体类型添加方法

```go
package main

import "fmt"

type Person struct {
	name string
	sex  byte
	age  int
}

func (person Person) PrintInfo() {
	fmt.Println(person)
}

func (pointer *Person) SetInfo(name string, sex byte, age int) {
	pointer.name = name
	pointer.age = age
	pointer.sex = sex
}

func main() {
	person1 := Person{"张三", 'm', 23}
	person1.PrintInfo()

	personPointer := new(Person)
	personPointer.SetInfo("李四", 'm', 24)
	personPointer.PrintInfo()

	var person2 Person
	(&person2).SetInfo("王五", 'f', 25)
	person2.PrintInfo()
}
```

运行结果：

```
 cnpeng$ go run day3.go 
{张三 109 23}
{李四 109 24}
{王五 102 25}
```

### 4.11. 方法使用总结

Go 语言中，可以为任意 **自定义类型** (包括内置类型，但不包括指针类型) 添加相应的方法。

函数与方法的区别在于：方法会有实例绑定，需要通过 `实例.方法名(xx)` 的形式调用；函数则没有与任意实例绑定，直接调用即可。 

```go
package main

import "fmt"

type myInt int

type intPointer *myInt

// 接收者的类型不能是指针类型的别称，但可以是 *T 类型
// invalid receiver type intPointer (intPointer is a pointer type)
// func (p intPointer) printValue1() {
// 	fmt.Println(p)
// }

// 同一个类型实例中，不能绑定同名方法
// printValue2 redeclared in this block
// func (p *myInt) printValue2(b int) {
// 	fmt.Println(p, b)
// }

func (p *myInt) printValue2() {
	fmt.Println(p)
}

func main() {
	var a myInt = 10
	a.printValue2()
}
```

### 4.12. 值语义和引用语义

```go
package main

import (
	"fmt"
)

type Person struct {
	name string
	sex  byte
	age  int
}

// 接收者为普通变量——值语义/值传递
func (person Person) SetInfo() {
	person.name = "李四"
	person.age = 24
	person.sex = 'f'
}

// 接收者为指针——引用语义/引用传递
func (pointer *Person) SetInfo2() {
	pointer.name = "王五"
	pointer.age = 25
	pointer.sex = 'm'
}

func main() {
	person1 := Person{"张三", 'm', 23}
	person1.SetInfo()
	fmt.Printf("person1 = %+v \n", person1)

	person2 := Person{"张三", 'm', 23}
	(&person2).SetInfo2()
	fmt.Printf("person2 = %+v \n", person2)
}
```

运行结果：

```
cnpeng$ go run day3.go 
person1 = {name:张三 sex:109 age:23} 
person2 = {name:王五 sex:109 age:25} 
```

### 4.13.  指针类型和普通类型的方法集

某个类型的实例能够调用的方法构成方法集。

前一节示例代码中的 SetInfo()、SetInfo2() 共同构成了 Person 的方法集


### 4.14.  方法的继承

```go
package main

import (
	"fmt"
)

type Person struct {
	name string
	sex  byte
	age  int
}

func (pointer *Person) PrintInfo() {
	fmt.Printf("name = %s , sex = %c , age = %d \n ", pointer.name, pointer.sex, pointer.age)
}

type Student struct {
	// 匿名字段表示继承
	Person

	id   int
	addr string
}

func main() {
	student1 := Student{Person{"张三", 'F', 24}, 666, "济南"}
	// 直接调用匿名字段中的方法——体现了方法的继承
	student1.PrintInfo()
}
```

运行结果：

```
cnpeng$ go run day3.go 
name = 张三 , sex = F , age = 24 
```

### 4.15.  方法的重写

调用时采用就近原则

```go
package main

import (
	"fmt"
)

type Person struct {
	name string
	sex  byte
	age  int
}

func (pointer *Person) PrintInfo() {
	fmt.Printf("name = %s , sex = %c , age = %d \n ", pointer.name, pointer.sex, pointer.age)
}

type Student struct {
	// 匿名字段表示继承
	Person

	id   int
	addr string
}

func (student Student) PrintInfo() {
	fmt.Println("学生", student)
}
func main() {
	student1 := Student{Person{"张三", 'F', 24}, 666, "济南"}

	// 方法重写
	student1.PrintInfo()

	// 显示调用匿名字段的方法
	student1.Person.PrintInfo()
}
```

运行结果：

```
cnpeng$ go run day3.go 
学生 {{张三 70 24} 666 济南}
name = 张三 , sex = F , age = 24 
```

### 4.16.  方法值

```go
package main

import (
	"fmt"
)

type Person struct {
	name string
	sex  byte
	age  int
}

func (pointer *Person) PrintInfo() {
	fmt.Printf("name = %s , sex = %c , age = %d \n ", pointer.name, pointer.sex, pointer.age)
}

func main() {
	person := Person{"张三", 'F', 24}
	person.PrintInfo()

	// 方法值—（CnPeng 函数类型的变量),调用时不需要传递接收者，隐藏了接收者
	pFunc := person.PrintInfo
	pFunc()
}
```

运行结果：

```
cnpeng$ go run day3.go 
name = 张三 , sex = F , age = 24 
name = 张三 , sex = F , age = 24 
```

### 4.17.  方法表达式

```go 
package main

import (
	"fmt"
)

type Person struct {
	name string
	sex  byte
	age  int
}

func (pointer *Person) PrintInfo() {
	fmt.Printf("name = %s , sex = %c , age = %d \n ", pointer.name, pointer.sex, pointer.age)
}

func (person Person) PrintInfo1() {
	fmt.Printf("name = %s , sex = %c , age = %d \n ", person.name, person.sex, person.age)
}

func main() {
	person := Person{"张三", 'F', 24}
	person.PrintInfo()

	// 方法表达式1, 调用时传递接收者
	pExp1 := (*Person).PrintInfo
	pExp1(&person)

	// 方法表达式2，调用时传递接收者
	PExp2 := (Person).PrintInfo1
	PExp2(person)
}
```

运行结果：

```
cnpeng$ go run day3.go 
name = 张三 , sex = F , age = 24 
 name = 张三 , sex = F , age = 24 
 name = 张三 , sex = F , age = 24 
```

### 4.18.  接口类型介绍

```go
type 接口名称 interface{
	函数名()
} 
```

- 接口名通常以 er 结尾
- 接口中声明的方法不需要实现
- 接口可以匿名嵌入到其他接口，或嵌入到结构中 
- 如果某个结构体拥有和某个接口的全部相同（名字相同，且参数相同）的方法，则认为该结构体实现了该接口


### 4.19.  接口的定义和实现


```go

package main

import "fmt"

type Humaner interface {
	//定义接口
	sayHi()
}

type Student struct {
	name string
	age  int
}

type Teacher struct {
	name string
	age  int
}

type MyString string

//实现接口中的方法
func (stu Student) sayHi() {
	fmt.Println("Student 调用 方法")
}

func (tch *Teacher) sayHi() {
	fmt.Println("Teacher 调用 方法")
}

func (str MyString) sayHi() {
	fmt.Println("MyString 调用 方法")
}

func main() {
	// 定义接口类型的变量
	var i Humaner

	// 如果某个类型实现了接口中的方法， 那么，该类型的实例（方法的接收者）就可以赋值给该接口类型的变量
	i = Student{"张三", 23}
	i.sayHi()

	i = &Teacher{"李四老师", 24}
	i.sayHi()

	var str MyString = "哈哈哈"
	str.sayHi()
}
```

运行结果：

```
cnpeng$ go run day3.go 
Student 调用 方法
Teacher 调用 方法
MyString 调用 方法
```

### 4.20. 多态的表现

```go
package main

import "fmt"

type Humaner interface {
	sayHi()
}

type Student struct {
	name string
	age  int
}

type Teacher struct {
	name string
	age  int
}

type MyString string

func (stu Student) sayHi() {
	fmt.Println("Student 调用 方法")
}

func (tch *Teacher) sayHi() {
	fmt.Println("Teacher 调用 方法")
}

func (str MyString) sayHi() {
	fmt.Println("MyString 调用 方法")
}

// 定义普通函数，参数为接口——体现了多态
func WhoSayHi(i Humaner) {
	i.sayHi()
}

func main() {

	stu := Student{"张三", 23}
	WhoSayHi(stu)

	tch := &Teacher{"李四老师", 24}
	WhoSayHi(tch)

	var str MyString = "哈哈哈"
	WhoSayHi(str)
	
	// 再回顾一下切片的知识
	slice1 := make([]Humaner, 3)
	slice1[0] = stu
	slice1[1] = tch
	slice1[2] = str
	for _, interf := range slice1 {
		interf.sayHi()
	}
}
```

运行结果：

```
 cnpeng$ go run day3.go 
Student 调用 方法
Teacher 调用 方法
MyString 调用 方法
Student 调用 方法
Teacher 调用 方法
MyString 调用 方法

``` 

### 4.21. 接口继承

```go
package main

import "fmt"

type Animal interface {
	sayHi()
}

type Humaner interface {
	Animal
	sing(songName string)
}

type Student struct {
	name string
	age  int
}

func (stu Student) sayHi() {
	fmt.Println(stu.name, "正在对你说：sayHi ")
}

func (stu *Student) sing(songName string) {
	fmt.Println(stu.name, "正在唱：", songName)
}

func main() {
	stu := Student{"张三", 23}
	stu.sayHi()
	stu.sing("两只老虎")
}
```

运行结果：

```
cnpeng$ go run day3.go 
张三 正在对你说：sayHi 
张三 正在唱： 两只老虎
```


### 4.22. 接口转换

对于接口来说，内容多的叫超集，内容少的叫子集；

超集可以转换为子集，但是反之不行。

```go
package main

import "fmt"

type Animal interface {
	sayHi()
}

type Humaner interface {
	Animal
	sing(songName string)
}

type Student struct {
	name string
	age  int
}

func (stu Student) sayHi() {
	fmt.Println(stu.name, "正在对你说：sayHi ")
}

func (stu *Student) sing(songName string) {
	fmt.Println(stu.name, "正在唱：", songName)
}

func main() {

	stu := Student{"张三", 23}

	var animalInterf Animal
	animalInterf = stu

	var humaner Humaner
	humaner = &stu

	animalInterf = humaner

	// cannot use animalInterf (type Animal) as type Humaner in assignment:
	// Animal does not implement Humaner (missing sing method)
	// humaner = animalInterf
	
	animalInterf.sayHi()
}
```

### 4.23. 空接口

`interface {}` 空接口 不包含任何方法，所有的类型都实现了空接口。

所以，空接口可以存储任意类型的数值，（类似于 C 语言中的 void*  ） 

```go
var v1 interface{} = 1
	var v2 interface{} = "abc"
	var v3 interface{} = &v2
	var v4 interface{} = struct{ X int }{1}
	var v5 interface{} = &struct{ X int }{1}
```

如果函数的某个参数可以接收任意类型的对象实例，那么我们就将该参数声明为 `interface{}`

比如，fmt 标准库中的 PrintXX() 函数

```
func Println(a ...interface{}) (n int, err error) {
	return Fprintln(os.Stdout, a...)
}
```

### 4.24. 通过if实现类型断言

类型断言也叫类型查询

核心是 `value , ok := 实例.(类型)`，如果 ok==true 则表示类型匹配, value 为实例的值

```go
package main

import (
	"fmt"
)

type Student struct {
	name string
	age  int
}

func main() {
	slice1 := make([]interface{}, 3)
	slice1[0] = 1
	slice1[1] = "abc"
	slice1[2] = Student{"张三", 23}

	for _, data := range slice1 {
		if value, ok := data.(int); ok == true {
			fmt.Printf(" %d 的类型为 int ,值为：%d \n", data, value)
		} else if value, ok := data.(string); ok == true {
			fmt.Printf(" %s 为字符串类型，值为：%s \n", data, value)
		} else if value, ok := data.(Student); ok == true {
			fmt.Printf("类型为Student, name = %s , age = %d \n", value.name, value.age)
		}
	}
}
```

运行结果：

```
cnpeng$ go run day3.go 
 1 的类型为 int ,值为：1 
 abc 为字符串类型，值为：abc 
类型为Student, name = 张三 , age = 23 
```

### 4.25. 通过switch实现类型断言

核心在于 `value := 实例.(type)` value 为实例的值，type 是个关键字，此处必须这么用

```go
package main

import (
	"fmt"
)

type Student struct {
	name string
	age  int
}

func main() {
	slice1 := make([]interface{}, 3)
	slice1[0] = 1
	slice1[1] = "abc"
	slice1[2] = Student{"张三", 23}

	for _, data := range slice1 {

		switch value := data.(type) {
		case int:
			fmt.Printf(" %d 的类型为 int ,值为：%d \n", data, data)
		case string:
			fmt.Printf(" %s 为字符串类型，值为：%s \n", data, data)
		case Student:
			fmt.Printf("类型为Student, name = %s , age = %d \n", value.name, value.age)
		}
	}
}
```

运行结果：

```
cnpeng$ go run day3.go 
 1 的类型为 int ,值为：1 
 abc 为字符串类型，值为：abc 
类型为Student, name = 张三 , age = 23 
```

---
## 5. 五、Day5

### 5.1.  昨日回顾

略

### 5.2.  error 接口的使用1

Go 语言引入了一个关于错误处理的标准模式，即 error 接口，它是 Go 语言内建的接口类型，该接口的定义如下：

```go
type error interface{
	Error() string
}
```

Go 语言的标准库代码包 errors 为用户提供如下方法：

```go
package errors 

type errorString struct{
	text string
}

func New (text string) error {
	return &errorString(text)
}

func (e *errorString) Error() string{
	return e.text
}
```

另一个可以生成 error 类型值的方法是调用 fmt 包中的 Errorf 函数：

```go
package fmt

func Errorf (format string, args ...interface{}) error {
	return errors.New (Sprintf(format , args))
}
```

示例代码:

```go
package main

import (
	"errors"
	"fmt"
)

func main() {
	error1 := fmt.Errorf("%s", "使用 fmt 包中的 Errorf 创建错误")
	fmt.Println(error1)

	error2 := errors.New("使用 errors 包中的函数创建错误")
	fmt.Println(error2)
}
```

运行结果：

```
cnpeng$ go run day5.go 
使用 fmt 包中的 Errorf 创建错误
使用 errors 包中的函数创建错误
```

### 5.3.  error 接口的使用2

```go
package main

import (
	"errors"
	"fmt"
)

func myDiv(a, b int) (result int, err error) {
	err = nil
	if b == 0 {
		// a/b a称为被除数，b 称为除数
		err = errors.New("ERROR：除数不能为0")
	} else {
		result = a / b
	}
	return
}

func main() {
	result, error := myDiv(3, 0)

	if nil != error {
		fmt.Println(error)
	} else {
		fmt.Println(result)
	}
}
```

运行结果：

```
cnpeng$ go run day5.go 
ERROR：除数不能为0
```

### 5.4.  显式调用 panic 函数

通常情况下，我们可以通过返回一个 error 类型的实例把错误信息暴露出来。

但是，如果遇到不可恢复的错误（比如：数组越界、空指针等）时，就会引发 panic 异常，此时，我们就应该使用 panic 把异常信息暴露出去。

当 panic 异常发生时，程序通常会中断运行，并立即执行在该 goroutine (可以理解成线程) 中被延迟的函数（ 被 defer 修饰的内容 ）。随后，程序崩溃并输出日志信息。日志信息包括 panic value 和 函数调用的堆栈跟踪信息。

不是所有的 panic 异常都来自于运行时，直接调用内置的 panic 函数也会引发 panic 异常， panic 函数接收任意类型数据作为参数：

```go
func panic(v interface{})
```

示例代码：

```go
package main

import (
	"fmt"
)

func test1() {
	fmt.Println("aaaaaa")
}

func test2() {
	panic("人为触发 panic ")
}
func test3() {
	fmt.Println("cccccc")
}
func main() {
	test1()
	test2()
	test3()
}
```

运行结果：

```
cnpeng$ go run day5.go 
aaaaaa
panic: 人为触发 panic 

goroutine 1 [running]:
main.test2(...)
        /Users/cnpeng/go/src/day5/day5.go:12
main.main()
        /Users/cnpeng/go/src/day5/day5.go:19 +0x3e
exit status 2
```


### 5.5.  数组越界导致 panic

```go
package main

import (
	"fmt"
)

func test1() {
	fmt.Println("aaaaaa")
}

func test2(x int) {
	// 定义一个长度为10的int数组
	var arr [10]int
	arr[x] = 666
}
func test3() {
	fmt.Println("cccccc")
}
func main() {
	test1()
	test2(20)
	test3()
}
```

运行结果：

```
cnpeng$ go run day5.go 
aaaaaa
panic: runtime error: index out of range

goroutine 1 [running]:
main.test2(...)
        /Users/cnpeng/go/src/day5/day5.go:14
main.main()
        /Users/cnpeng/go/src/day5/day5.go:21 +0x25
exit status 2
```

### 5.6.  recover 的使用

运行时 panic 异常一旦被引发就会导致程序崩溃。而 recover 函数 则可以使当前程序从 panic 的状态中恢复并重新获取流程控制权。

**注意：recover 只在 defer 调用的函数中有效**

如果  defer 函数 中调用了内置函数 recover , 当该 defer 函数发生 panic 异常时，recover 会使程序从 panic 中恢复而不是直接崩溃，并且 recover 函数会返回 panic value —— 也就是异常信息，如果没有发生 panic ，那么 recover 函数将返回 nil


```go
package main

import (
	"fmt"
)

func test1() {
	fmt.Println("aaaaaa")
}

func test2(x int) {
	defer func() {
		// 只有 panic 发生时，err 才不为 nil ,才执行后面的打印
		if err := recover(); nil != err {
			fmt.Println(err)
		}
	}()

	// 定义一个长度为10的int数组
	var arr [10]int
	arr[x] = 666
}
func test3() {
	fmt.Println("cccccc")
}
func main() {
	test1()
	test2(20)
	test3()
}
```

运行结果：

```
cnpeng$ go run day5.go 
aaaaaa
runtime error: index out of range
cccccc
```

### 5.7.  字符串操作的常用函数

下面这些函数都在 strings 包中，调用时使用 `strings.函数名(xxx)` 的格式

```go
//字符串s 中是否包含 substr , 包含返回true,否则false
func Contains (s , substr string) bool

// 把 a 切片中的内容使用 sep 链接起来，构成一个新的字符串
func Join (a []string, sep string) string

// 在字符串 s 中查找 sep 出现的索引位置，如果不存在返回-1
func Index (s , sep string) int

// 重复 s 字符串 count 次，并返回重复后的字符串  
func Repeat (s string, count int) string

// 在字符串 s 中使用 new 替换 old ; n 表示替换次数，小于0表示全部替换
func Replace (s , old , new string , n int) string

// 把字符串 s 按照 sep 切分，返回一个字符串数组
func Split (s , sep string) []string

// 在 s 字符串的头部和尾部去除指定的 cutset 字符串
func Trim (s string, cutset string) string

// 去除 s 字符串的空格符，并且按照空格分割返回 slice
func Fields (s string) []string

```

### 5.8.  字符串操作的代码

使用的时候不要忘记 导入 strings 包

示例代码:

```go
// 结果为： ["Achtung"]
fmt.Printf("[%q]" , strings.Trim (" !!! Achtung !!! ", "! "))

// 结果为：Fields are : ["foo" "bar" "baz"]
fmt.Printf("Fields are : %q" , strings.Fields("  foo  bar  baz  ") )

```



### 5.9.  字符串转换

下列转换函数都是在 strconv 包中的

#### 5.9.1.  Appendxxx 函数

Append 系列函数将整数等转换为字符串后，添加到现有的 **字节数组** 中。

```go
package main

import (
	"fmt"
	"strconv"
)

func main() {
	byteSlice := make([]byte, 0, 100)
	// 将整数 4567 以 10 进制的形式追加到 byteSlice 中
	byteSlice = strconv.AppendInt(byteSlice, 4567, 10)
	// 追加布尔类型
	byteSlice = strconv.AppendBool(byteSlice, false)
	// 追加带着双引号的字符串内容
	byteSlice = strconv.AppendQuote(byteSlice, "带着双引号")
	// 追加带着单引号的字符类型
	byteSlice = strconv.AppendQuoteRune(byteSlice, '单')

	// 把切片转为字符串并打印
	fmt.Println(string(byteSlice))
}
```

运行结果：

```
cnpeng$ go run day5.go 
4567false"带着双引号"'单'
```

#### 5.9.2.  Formatxxx 函数

Format 系列函数把其他类型数据转换为字符串

```go
package main

import (
	"fmt"
	"strconv"
)

func main() {
	str1 := strconv.FormatInt(1234, 10)
	str2 := strconv.FormatUint(12345, 10)
	str3 := strconv.FormatBool(false)
	str4 := strconv.Itoa(1023)

	fmt.Printf("str1 = %s , 类型为：%T \n", str1, str1)
	fmt.Printf("str2 = %s , 类型为：%T \n", str2, str2)
	fmt.Printf("str3 = %s , 类型为：%T \n", str3, str3)
	fmt.Printf("str4 = %s , 类型为：%T \n", str4, str4)
}
```

运行结果：

```
cnpeng$ go run day5.go 
str1 = 1234 , 类型为：string 
str2 = 12345 , 类型为：string 
str3 = false , 类型为：string 
str4 = 1023 , 类型为：string 
```

#### 5.9.3.  Parsexxx函数

Parse 系列函数表示 把字符串转换成其他类型

```go
package main

import (
	"fmt"
	"strconv"
)

func main() {
	flag, err := strconv.ParseBool("false")
	if nil != err {
		fmt.Println(err)
	} else {
		fmt.Println("字符串解析为bool : ", flag)
	}
	
	// Atoi 是对 ParseInt 的包装
	a, err := strconv.Atoi("4567")
	if nil != err {
		fmt.Println(err)
	} else {
		fmt.Println("字符串转为整数 : ", a)
	}
}
```

运行结果：

```
cnpeng$ go run day5.go 
字符串解析为bool :  false
字符串转为整数 :  4567
```

### 5.10.  正则表达式1

Go 语言中使用正则表达式时需要导入 regexp 包。

被反引号 \` \` 包裹的内容称为原生字符串（原样字符串，同 Kotlin 中的 """ """），

![](https://s2.ax1x.com/2019/02/22/kW4jNn.png)
![](https://images.gitee.com/uploads/images/2019/0222/110125_69ca8044_930142.png "屏幕截图.png")
![](https://images.gitee.com/uploads/images/2019/0222/114116_787ca9de_930142.png "屏幕截图.png")

```go
package main

import (
	"fmt"
	"regexp"
)

func main() {

	str := "abc acc a5c bbb456avc"

	// 构建正则解析器。小括号中参数为需要匹配的正则表达式，使用 反引号包裹——就是键盘左上角的那个 ~ 键盘
	regexObj := regexp.MustCompile(`a.c`)
	// 第一个参数表示源字符串，第二个参数表示查询几个，-1 表示查询全部. 返回切片
	regexResult := regexObj.FindAllStringSubmatch(str, -1)
	fmt.Println(regexResult)

	// 获取 a c 之间为一个数字的切片 a[0-9]c 等价于 a\dc
	// regexObj2 := regexp.MustCompile(`a[0-9]c`)
	regexObj2 := regexp.MustCompile(`a\dc`)
	// 第二个参数为正数，表示只获取一个
	regexResult2 := regexObj2.FindAllStringSubmatch(str, 1)
	fmt.Println(regexResult2)
}
```

运行结果:

```
cnpeng$ go run day5.go 
[[abc] [acc] [a5c] [avc]]
[[a5c]]
```



### 5.11. 正则表达式2

提取有效的小数

```go
package main

import (
	"fmt"
	"regexp"
)

func main() {
	str := "3.1 3.14 456 asvf 13.14 13.1 7. 8..9 "

	regexObj := regexp.MustCompile(`\d+\.\d+`)

	regexResult := regexObj.FindAllString(str, -1)
	fmt.Println(regexResult)
}
```

运行结果：

```
cnpeng$ go run day5.go 
[3.1 3.14 13.14 13.1]
```

### 5.12. 正则表达式3

匹配网页中的有效字段

```go
package main

import (
	"fmt"
	"regexp"
)

func main() {
	htmlStr := `
<!doctype html>
<html>
  <body>
	<div> 
		  静夜思
		李白 * 唐 
	</div>
    <div> 床前明月光</div>
   	<div> 疑是地上霜</div>
	<div> 举头望明月</div>
	<div> 低头思故乡</div>
  </body>
</html>
`
	// 下面这种写法会返回 []。其中的. 表示任意字符
	// regexObj := regexp.MustCompile(`<div>.</div>`)
	// 为了方便阅读，通常会在正则中使用小括号，<div>(.)</div>
	// regexObj := regexp.MustCompile(`<div>(.)</div>`)

	// 返回 [[<div> 床前明月光</div>] [<div> 疑是地上霜</div>] [<div> 举头望明月</div>] [<div> 低头思故乡</div>]]
	// regexObj := regexp.MustCompile(`<div>(.*)</div>`)

	// 新增的 ?s: 表示 让 . 把换行符也匹配上。详细可查阅 https://studygolang.com/pkgdoc 中的 i m s u 的介绍
	// regexObj := regexp.MustCompile(`<div>(?s:(.*))</div>`)

	// .*? 表示匹配 .* 0次或1次
	regexObj := regexp.MustCompile(`<div>(?s:(.*?))</div>`)

	regexResult := regexObj.FindAllStringSubmatch(htmlStr, -1)
	// fmt.Println(regexResult)

	for index, data := range regexResult {
		//data 都是这种格式的： [<div> 床前明月光</div>  床前明月光]
		fmt.Println(index, data)
		// data[0] 为 <div>xx</div> ，data[1] 为 div 标签中的内容
		fmt.Printf("data[0] = %s , data[1] = %s \n\n", data[0], data[1])
	}
}

```

运行结果：

```
cnpeng$ go run day5.go 
0 [<div> 
                  静夜思
                李白 * 唐 
        </div>  
                  静夜思
                李白 * 唐 
        ]
data[0] = <div> 
                  静夜思
                李白 * 唐 
        </div> , data[1] =  
                  静夜思
                李白 * 唐 
         

1 [<div> 床前明月光</div>  床前明月光]
data[0] = <div> 床前明月光</div> , data[1] =  床前明月光 

2 [<div> 疑是地上霜</div>  疑是地上霜]
data[0] = <div> 疑是地上霜</div> , data[1] =  疑是地上霜 

3 [<div> 举头望明月</div>  举头望明月]
data[0] = <div> 举头望明月</div> , data[1] =  举头望明月 

4 [<div> 低头思故乡</div>  低头思故乡]
data[0] = <div> 低头思故乡</div> , data[1] =  低头思故乡 
``` 

### 5.13. json 介绍

Go 语言中使用 json 时，需要导入 encoding/json 库

JSON 格式化检查网址：[https://www.json.cn/](https://www.json.cn/)


### 5.14.  通过结构体生成 json

#### 5.14.1.  基本格式

```go
package main

import (
	"encoding/json"
	"fmt"
)

type MyStruct struct {
	// 如果要序列化，成员首字母必须大写
	Company  string
	Subjects []string
	Isok     bool
	Price    float64

	// 成员首字母小写不能实现序列化
	// company  string
	// subjects []string
	// isok     bool
	// price    float64
}

func main() {
	myStruct := MyStruct{"山东蚁动", []string{"Java", "Android", "Go"}, true, 999.66}
	// 序列化成功后得到的是 []byte ，如果要打印出来，需要转换成 string
	// resultSlice, err := json.Marshal(myStruct)
	
	// MarshalIndent 表示带有格式的序列化。第二个参数为前缀，最后一个参数为缩进
	resultSlice, err := json.MarshalIndent(myStruct, "", "  ")

	if nil != err {
		fmt.Println("错误：", err)
	} else {
		fmt.Println("结果：", string(resultSlice))
	}
}
```

运行结果：

```
CnPeng:day5 cnpeng$ go run day5.go 
结果： {
  "Company": "山东蚁动",
  "Subjects": [
    "Java",
    "Android",
    "Go"
  ],
  "Isok": true,
  "Price": 999.66
}
```

如果使用的是 json.Marshal( ) 函数，将得到如下结果：

```
cnpeng$ go run day5.go 
结果： {"Company":"山东蚁动","Subjects":["Java","Android","Go"],"Isok":true,"Price":999.66}
```

### 5.15.  struct_tag 的使用

使用 struct_tag 控制序列化后的键名

```go
package main

import (
	"encoding/json"
	"fmt"
)

type MyStruct struct {
	//如果想要在序列化后得到首字母小写的键名，则在后面追加原样字符串
	Company string `json:"company"`
	// 使用中划线 - ，表示序列化结果不显示在界面中
	Subjects []string `json:"-"`
	// `json:",string"` 表示把值转换为字符串
	Isok  bool    `json:",string"`
	Price float64 `json:",string"`
}

func main() {
	myStruct := MyStruct{"山东蚁动", []string{"Java", "Android", "Go"}, true, 999.66}

	// MarshalIndent 表示带有格式的序列化。第二个参数为前缀，最后一个参数为缩进
	resultSlice, err := json.MarshalIndent(myStruct, "", "  ")

	if nil != err {
		fmt.Println("错误：", err)
	} else {
		fmt.Println("结果：", string(resultSlice))
	}
}
```

运行结果：

```
cnpeng$ go run day5.go 
结果： {
  "company": "山东蚁动",
  "Isok": "true",
  "Price": "999.66"
}
```

### 5.16.  通过 map 生成 json

```go
package main

import (
	"encoding/json"
	"fmt"
)

func main() {
	myMap := make(map[string]interface{}, 4)
	myMap["company"] = "CnPeng"
	myMap["subjects"] = []string{"Java", "Android", "Go"}
	myMap["price"] = 66.666
	myMap["isOk"] = true

	resultSlice, err := json.MarshalIndent(myMap, "", "  ")

	if nil != err {
		fmt.Println("错误：", err)
	} else {
		fmt.Println("结果：", string(resultSlice))
	}
}
```

运行结果：

```
cnpeng$ go run day5.go 
结果： {
  "company": "CnPeng",
  "isOk": true,
  "price": 66.666,
  "subjects": [
    "Java",
    "Android",
    "Go"
  ]
}
```

### 5.17.  json 解析到结构体

```go
package main

import (
	"encoding/json"
	"fmt"
)

type MyStruct struct {
	// 如果要序列化，成员首字母必须大写
	Company  string
	Subjects []string
	Isok     bool
	Price    float64
}

func main() {
	jsonStr := ` {
  "company": "CnPeng",
  "isOk": true,
  "price": 66.666,
  "subjects": [
    "Java",
    "Android",
    "Go"
  ]
}`
	// 解析并获取全部内容
	var myStruct MyStruct
	// 第一个参数是 []byte 切片，第二个参数必须是 指针
	err := json.Unmarshal([]byte(jsonStr), &myStruct)

	if nil != err {
		fmt.Println("错误：", err)
		return
	}

	fmt.Println("myStruct =", myStruct)
	fmt.Printf("myStruct = %+v\n\n", myStruct)

	// 解析获取部分内容——只获取 subject 字段
	type Subjects struct {
		Subjects []string `json:"subjects"`
	}

	var mySubjects Subjects
	err2 := json.Unmarshal([]byte(jsonStr), &mySubjects)
	if nil != err2 {
		fmt.Println("错误：", err2)
		return
	}

	fmt.Println("mySubjects =", mySubjects)
	fmt.Printf("mySubjects = %+v\n", mySubjects)
}
```

运行结果：

```
cnpeng$ go run day5.go 
myStruct = {CnPeng [Java Android Go] true 66.666}
myStruct = {Company:CnPeng Subjects:[Java Android Go] Isok:true Price:66.666}

mySubjects = {[Java Android Go]}
mySubjects = {Subjects:[Java Android Go]}
```


### 5.18.  json 解析到 map

```go
package main

import (
	"encoding/json"
	"fmt"
)

func main() {
	jsonStr := ` {
  "company": "CnPeng",
  "isOk": true,
  "price": 66.666,
  "subjects": [
    "Java",
    "Android",
    "Go"
  ]
}`
	//  将数据解析到 map
	resultMap := make(map[string]interface{}, 4)
	err := json.Unmarshal([]byte(jsonStr), &resultMap)

	if nil != err {
		fmt.Println("错误：", err)
		return
	}

	fmt.Printf("resultMap = %+v\n\n", resultMap)

	//  借助类型断言获取 map 中的具体数据并打印
	for key, data := range resultMap {
		// fmt.Printf("key = %+v, 类型为：%T，data = %+v ,类型为：%T\n", key, key, data, data)

		switch value := data.(type) {
		case string:
			fmt.Printf("map[%s] 的值为 %+v ,该值类型为 string \n", key, value)
		case bool:
			fmt.Printf("map[%s] 的值为 %+v ,该值类型为 bool \n", key, value)
		case float64:
			fmt.Printf("map[%s] 的值为 %+v ,该值类型为 float64 \n", key, value)
		case []interface{}:
			// 获取到该切片之后，如果想取出其中的内容，还需要再次使用类型断言
			fmt.Printf("map[%s] 的值为 %+v ,该值类型为 []interface{} \n", key, value)
		}
	}
}
```

运行结果：

```
cnpeng$ go run day5.go 
resultMap = map[company:CnPeng isOk:true price:66.666 subjects:[Java Android Go]]

map[company] 的值为 CnPeng ,该值类型为 string 
map[isOk] 的值为 true ,该值类型为 bool 
map[price] 的值为 66.666 ,该值类型为 float64 
map[subjects] 的值为 [Java Android Go] ,该值类型为 []interface{} 
```

根据上面的代码可知，其实还是解析到 结构体 中比较简单。

### 5.19.  文件分类和为什么需要文件

![](https://images.gitee.com/uploads/images/2019/0222/152325_5b76bbf4_930142.png "屏幕截图.png")

为什么需要文件？——存储数据啊


### 5.20.  文件常用操作接口

下面这些函数都在 os 库中

#### 5.20.1.  新建文件

```go
// 根据提供的文件名创建新的文件，返回一个文件对象，默认权限为：0666——可读写。如果文件存在会清空已有
func Create (name string) (file *File , err Error)

// 根据文件描述符 创建相应的文件，返回文件对象
func NewFile (fd uintptr , name string) *File

```

#### 5.20.2.  打开文件

```go
// 以只读的形式打开名称为 name 的文件，内部实现其实调用了 OpenFile
func Open (name string) (file *File , err Error)

// 打开名称为 name 的文件；flag 是打开方式，如只读、读写等；perm 是权限
func OpenFile (name string ,flag int , perm uint32)(file *File , err Error)

```

#### 5.20.3.  写文件

```go
// 写入 byte 类型的信息到文件
func (file *File) Write (b []byte) (n int, err Error)

// 在指定位置开始写入 byte 类型的信息
func (file *File) WriteAt (b []byte , off int64) (n int, err Error)

// 写入 string 信息到文件
func (file *File) WriteString (s string) (res int , err Error)

```

#### 5.20.4.  读文件

```go
// 读取数据到 b 中
func (file *File) Read (b []byte) (n int, err Error)

// 从 off位置 开始读取数据到 b 中
func (file *File) ReadAt (b []byte, off int64) (n int , err Error)

```

#### 5.20.5.  删除文件

```go
// 删除名为 name 的文件
func Remove (name string) Error

```

### 5.21. 标准设备文件的使用

```go
package main

import (
	"fmt"
	"os"
)

func main() {
	// 向标准输出设备（屏幕）写内容
	fmt.Println(" are u ok?——标准输出设备默认打开")

	// // 关闭标准输出设备，关闭后，fmt.Printxxx() 函数将不会在屏幕上显示内容
	// os.Stdout.Close()
	// fmt.Println(" 前面关闭了，此处不会打印")

	// 关闭标准输入设备后，将不能在屏幕上输入内容
	os.Stdin.Close()
	var a int
	fmt.Println("请输入内容：")
	fmt.Scan(&a)
	fmt.Println("a = ", a)
}
```


### 5.22. 把内容写入到文件

```go
package main

import (
	"fmt"
	"os"
)

func main() {
	path := "./test.text"
	WriteToFile(path)
}

func WriteToFile(path string) {
	//  先打开或创建文件
	fileObj, err := os.Create(path)
	if nil != err {
		fmt.Println("出错了,", err)
		return
	}

	//  写完之后要关闭文件
	defer fileObj.Close()

	//  写出到文件
	var bufferStr string
	for i := 0; i < 10; i++ {
		// 把指定格式的内容暂存到变量中
		bufferStr = fmt.Sprintf(" i = %d \n ", i)

		// 写出到文件
		_, err := fileObj.WriteString(bufferStr)
		if nil != err {
			fmt.Println("写出到文件出错了：", err)
			return
		}
	}
}
```

执行完上述程序之后，会在当前目录下创建一个名为 test.text 的文件，如下图：

![](https://images.gitee.com/uploads/images/2019/0222/170648_e131d27e_930142.png "屏幕截图.png")

### 5.23. 读取文件内容

```go
package main

import (
	"fmt"
	"os"
	"io"
)

func main() {
	path := "./test.text"
	// WriteToFile(path)
	ReadFile(path)
}

func ReadFile(path string) {
	//  打开文件
	fileObj, err := os.Open(path)
	if nil != err {
		fmt.Println("打开文件出错：", err)
		return
	}

	//  关闭文件
	defer fileObj.Close()

	//  读取文件
	//下面这个切片一定要记得初始化
	var textByte = make([]byte, 1024*2)
	_, err2 := fileObj.Read(textByte)
	// io.EOF 表示没有更多内容可读取时的报错信息
	if nil != err && err != io.EOF {
		fmt.Println("读取内容出错：", err2)
		return
	}

	//fmt.Println("读取到的内容为：", string(textByte))
	// string(textByte[:n] 表示只把有效的 n 个内容转换为字符串
	fmt.Println("读取到的内容为：", string(textByte[:n]))
}
```

运行结果：

```
cnpeng$ go run day5.go 
读取到的内容为：  i = 0 
  i = 1 
  i = 2 
  i = 3 
  i = 4 
  i = 5 
  i = 6 
  i = 7 
  i = 8 
  i = 9 
```


### 5.24. 借助 bufio 实现按行读取内容

```go
package main

import (
	"bufio"
	"fmt"
	"io"
	"os"
)

func main() {
	path := "./test.text"
	// WriteToFile(path)
	ReadFile(path)
}

func ReadFile(path string) {
	//  打开文件
	fileObj, err := os.Open(path)
	if nil != err {
		fmt.Println("打开文件出错：", err)
		return
	}

	//  关闭文件
	defer fileObj.Close()

	//  读取文件
	// 把内容先读取到缓冲区内部
	fileReader := bufio.NewReader(fileObj)

	for {
		// 碰到 \n 符号就作为一次读取的结束。但在读取到的数据中也会额外包含一个 \n
		byteSlice, err := fileReader.ReadBytes('\n')
		if nil != err {
			if io.EOF == err {
				fmt.Println("文件读取完毕")
				break
			}
			fmt.Println("按行读取出错：", err)
		}
		fmt.Println("读取到的内容为：", string(byteSlice))
	}
}
```

运行结果：

```
 cnpeng$ go run day5.go 
读取到的内容为：  i = 0 

读取到的内容为：   i = 1 

读取到的内容为：   i = 2 

读取到的内容为：   i = 3 

读取到的内容为：   i = 4 

读取到的内容为：   i = 5 

读取到的内容为：   i = 6 

读取到的内容为：   i = 7 

读取到的内容为：   i = 8 

读取到的内容为：   i = 9 

文件读取完毕
```


### 5.25. 文件案例：拷贝文件

* day5.go

```go
package main

import (
	"fmt"
	"io"
	"os"
)

func main() {
	WriteToFile()
}

// 写出内容到文件
func WriteToFile() {

	//  检查用户输入的参数数量
	args := os.Args
	if 3 != len(args) {
		fmt.Println("参数数量不对 ")
		return
	}

	//  检查用户输入的源文件和目标文件是否重复
	if args[1] == args[2] {
		fmt.Println("源文件和目标文件不能一致")
		return
	}

	srcPath := args[1]
	dstPath := args[2]

	//  创建目标文件对象
	dstFileObj, err1 := os.Create(dstPath)
	if nil != err1 {
		fmt.Println("os.Create.ERR:", err1)
		return
	}

	//  打开文件
	srcFileObj, err2 := os.Open(srcPath)
	if nil != err2 {
		fmt.Println("os.Open.ERR:", err2)
		return
	}

	//  记得关闭
	defer srcFileObj.Close()
	defer dstFileObj.Close()

	//  拷贝文件
	srcBuf := make([]byte, 1024*2)
	for {
		// 6- 从源文件读取
		n, err3 := srcFileObj.Read(srcBuf)

		if nil != err3 {
			if io.EOF == err3 {
				fmt.Println("文件读取完毕")
				break
			}
			fmt.Println("srcFileObj.Read.ERR:", err3)
		}

		// 6- 写出文件到目标——拷贝
		_, err4 := dstFileObj.Write(srcBuf[:n])
		if nil != err4 {
			if io.EOF == err4 {
				fmt.Println("文件复制完毕")
				break
			}
			fmt.Println("dstFileObj.Write.ERR:", err4)
		}
	}
}
```

编写完上述代码之后，在终端中执行 `go build day5.go`，此时，会在同目录下生成一个名称为 `day5` 的可执行程序。

我们先把要复制的内容 test.text 放置到 day5.go 的同目录下, 然后在终端中执行 `day5 test.text test副本1.txt`, 执行完成之后该目录下就会新增一个复制出来的名为 test副本1.txt 的文件。

---

## 6. 六、Day6

### 6.1.  昨日回顾

略

### 6.2.  并行和并发的区别

![](https://images.gitee.com/uploads/images/2019/0226/080734_e249516b_930142.png "屏幕截图.png")  


### 6.3.  go语言并发优势

Go 从语言层面就支持了并发。

虽然并发程序的内存管理比较复杂，但 Go 语言提供了自动垃圾回收机制。

Go 语言为并发编程而内置的上层 API 基于 CSP（communicating sequential processes，顺序通信继承）模型。也就是说，不用显示的添加锁对象。


### 6.4.  创建 goroutine

goroutine 是 Go 并行设计的核心。

goroutine 说到底其实就是协程，它比线程更小，十几个 goroutine 可能体现在底层就是五六个线程，Go 语言内部替我们实现饿了这些 goroutine 之间的内容共享。

`func main(){ }` 通常被称为主协程，我们自己新建的协程被称为 子协程 或者 工作协程。

在调用函数时，在前面添加 go 关键字即可创建一个子协程。系统调度器会自动的将其安排到合适的系统线程上执行。


```go
package main

import (
	"fmt"
	"time"
)

func ChildCoroutine() {
	for {
		fmt.Println("这是子协程——Child Coroutine")
		time.Sleep(time.Second)
	}
}

func main() {

	// 创建子协程——在被调用的函数前面添加 go 关键字即可
	go ChildCoroutine()

	for {
		// 主协程中定义死循环不停的打印
		fmt.Println("这是主协程")
		time.Sleep(time.Second)
	}
}
```

运行结果：

```
cnpeng$ go run day6.go
这是主协程
这是子协程——Child Coroutine
这是子协程——Child Coroutine
这是主协程
这是主协程
这是子协程——Child Coroutine
这是主协程
这是子协程——Child Coroutine
这是子协程——Child Coroutine
这是主协程
这是主协程
这是子协程——Child Coroutine
这是子协程——Child Coroutine
这是主协程
```

注意：

- 因为是使用了死循环，所以，后面还会不停的打印。如果想在终端中退出这个死循环，可以同时 按下 ctrl+z
- 在上述代码中，子协程的调用放置在主协程的死循环前面。因为，如果放置在主协程后面，将得不到执行——函数内部顺讯执行，只有执行完一个之后才会执行下一个，主线程死循环了，将永远不会继续往下执行。
- 因为系统对协程进行自动调度，所以，上述运行结果中，主协程和子协程的打印顺序并不固定。


### 6.5.  主协程先退出

主协程退出之后，子协程也会退出。

```go
package main

import (
	"fmt"
	"time"
)

func main() {

	// 创建子协程——在被调用的函数前面添加 go 关键字即可
	go func() {
		i := 0
		for {
			i++
			// 主协程中定义死循环不停的打印
			fmt.Println("这是子协程——Child Coroutine")
			time.Sleep(time.Second)
		}
		// 匿名函数末尾不要忘了小括号（）调用
	}()

	i := 0
	for {
		i++
		// 主协程中定义死循环不停的打印
		fmt.Println("这是主协程")
		time.Sleep(time.Second)

		if 2 == i {
			break
		}
	}
}
```

运行结果：

```
cnpeng$ go run day6.go
这是主协程
这是子协程——Child Coroutine
这是主协程
这是子协程——Child Coroutine
这是子协程——Child Coroutine
```

### 6.6.  主协程先退出导致子协程未执行

```go

package main

import (
	"fmt"
	"time"
)

func main() {

	// 创建子协程——在被调用的函数前面添加 go 关键字即可
	go func() {
		i := 0
		for {
			i++
			// 主协程中定义死循环不停的打印
			fmt.Println("这是子协程——Child Coroutine")
			time.Sleep(time.Second)
		}
		// 匿名函数末尾不要忘了小括号（）调用
	}()

	// 主协程中不添加内容，调用 main() 之后直接结束，此时，子协程中的内容还没来得及执行就退出了
	// 此处主协程中不添加内容主要是为了演示效果，实际应用中，可能会存在其他诸多执行较快的内容导致主协程先结束而子协程没来得及执行。
}
```

### 6.7.  runtime.Gosched 的使用

`runtime.Gosched()` 用于让出 CPU ，也就是让出当前协程的执行权限，先让其他协程执行。由系统调度器决定何时在执行当前协程。

```go
package main

import (
	"fmt"
	"runtime"
)

func main() {
	go func(str string) {
		fmt.Println(str)
	}("world")

	// 让出执行权限，先让其他协程执行。
	runtime.Gosched()
	fmt.Println("hello")
}
```

运行结果：

```
cnpeng$ go run day6.go
world
hello
```

上述示例中，如果注释掉 `runtime.Gosched()` 那么就会先执行主协程，打印 hello , 然后主协程结束. 此时，子协程还没来得及执行，所以，不会再打印 world .


### 6.8.  runtime.Goexit 的使用

`runtime.Goexit` 表示 退出当前协程

先来看一个普通示例：

```go
package main

import (
	"fmt"
)

func tempFunc() {
	defer fmt.Println("cccccccccccccc")
	fmt.Println("dddddddddddddd")
}

func main() {
	go func() {
		fmt.Println("aaaaaaaaaaaaaa")
		tempFunc()
		fmt.Println("bbbbbbbbbbbbbb")
	}()

	for {
		// 定义一个死循环,防止主协程退出
	}
}
```

运行结果：

```
cnpeng$ go run day6.go
aaaaaaaaaaaaaa
dddddddddddddd
cccccccccccccc
bbbbbbbbbbbbbb
```

在 tempFunc() 中添加 retrun 语句后的示例：

```go
package main

import (
	"fmt"
)

func tempFunc() {
	defer fmt.Println("cccccccccccccc")
	return
	fmt.Println("dddddddddddddd")
}

func main() {
	go func() {
		fmt.Println("aaaaaaaaaaaaaa")
		tempFunc()
		fmt.Println("bbbbbbbbbbbbbb")
	}()

	for {
		// 定义一个死循环,防止主协程退出
	}
}
```

运行结果：

```
cnpeng$ go run day6.go
aaaaaaaaaaaaaa
cccccccccccccc
bbbbbbbbbbbbbb
```

使用 runtime.Goexit() 退出当前协程：

```go
package main

import (
	"fmt"
	"runtime"
)

func tempFunc() {
	defer fmt.Println("cccccccccccccc")
	// 退出当前协程
	runtime.Goexit()
	fmt.Println("dddddddddddddd")
}

func main() {
	go func() {
		fmt.Println("aaaaaaaaaaaaaa")
		tempFunc()
		fmt.Println("bbbbbbbbbbbbbb")
	}()

	for {
		// 定义一个死循环,防止主协程退出
	}
}
```

运行结果：

```
cnpeng$ go run day6.go
aaaaaaaaaaaaaa
cccccccccccccc
```

在上述第三个示例中，tempFunc() 运行在 子协程中，当执行到该 runtime.Goexit() 之后，该子协程退出，将不会执行打印 dddd... 和 bbbb... 的语句



### 6.9.  runtime.GOMAXPROCS 的使用

`runtime.GOMAXPROCS()` 用来设置可以参与计算的CPU最大核数，并返回之前的值。

```go
package main

import (
	"fmt"
	"runtime"
)

func main() {
	// n := runtime.GOMAXPROCS(1)
	n := runtime.GOMAXPROCS(4)
	// 根据计算机配置的不同，此处返回的 n 不同
	fmt.Println("默认的参与运算的CPU核数为：", n)

	for {
		fmt.Print("0")
		go fmt.Print("1")
	}
}
```

上述示例代码中，

当 `runtime.GOMAXPROCS(1)` 时，最多同时只能有一个 goroutine 被执行，所以，会先打印很多 0 ，然后过一段时间后，Go 调度器将主协程休眠，然后唤醒子协程 打印很多 1 ，过一段时间后在让子协程休眠，唤醒主协程，这样循环往复。

如下：

```
cnpeng$ go run day6.go
默认的参与运算的CPU核数为： 8
0000000000000000000000000000000000000000000000000000000000000000000000
000000000000000011111111111111111111111111111111111111111111111111111
111111111111111111111111111111111111111111111111110000000000000000000
000000000000000000000000000000000000000000000000000000000000000000
```

当 `runtime.GOMAXPROCS(4)` 时，最多同时能有 4 个 goroutine 被执行，此时，主协程和子协程之间休眠和唤醒的频率会快很多。

如下：

```
cnpeng$ go run day6.go
默认的参与运算的CPU核数为： 8
000000000001011111110111110001100000000010111111000000001111000000111
111110001111100000000011000001111111000011011111111110000000000110011
```

### 6.10.  多任务资源竞争问题

单协程的正常示例：

```go
package main

import (
	"fmt"
	"time"
)

func Printer(str string) {
	for _, c := range str {
		fmt.Printf("%c", c)
	}
	fmt.Println()
}

func main() {
	Printer("Hello")
	Printer("World")
}
```
运行结果：

```
cnpeng$ go run day6.go 
Hello
World
```

多协程导致资源竞争：

```go
package main

import (
	"fmt"
	"time"
)

func Printer(str string) {
	for _, c := range str {
		fmt.Printf("%c", c)
		time.Sleep(time.Second)
	}
	fmt.Println()
}

func main() {
	go Printer("Hello")
	go Printer("World")

	for {
	}
}
```

运行结果：

```
cnpeng$ go run day6.go clear
WHeolrlldo
```

在上面的多协程示例中，打印出来的内容乱了。这就是因为多协程之间的资源竞争导致的。

### 6.11. channel 介绍

channel 用于多个 goroutine 通讯（共享数据），内部实现了同步，确保并发安全

和 map 类似，channel 也是一个对 make() 创建的底层数据结构的引用.

当我们赋值一个 channel 或用于函数参数传递时，我们只是拷贝了一个 channel 的引用，也就是说，channel 是引用传递，channel 的默认值为 nil。


#### 6.11.1.  定义 channel
使用 make() 定义 channel 时，也需要定义发送到 channel 的值的类型。

```go
// 无缓冲的 channel
make(chan Type)

// 指定缓冲区大小的 channel 
make(chan Type , capacity)
```

当 channel 的 capacity==0 时，表示一个无缓冲的 channel。

无缓冲 channel 会阻塞读写。

有缓冲 channel 只有当缓冲区写满之后才会阻塞写入。


#### 6.11.2.  channel 发送和接收数据

```go
// 发送 value 到 channel
channel <- value

// 接收到 channel 中的数据后将其丢弃
<- channel 

// 从 channel 中接收数据并将其赋值给 x 
x := <- channel 

// 接收 channel 中的数据赋值给 x ,并检查通道是否已经关闭或者是否为空.true 表示没有关闭，false 表示已关闭
x , ok := <- channel 

```

默认情况下，channel 的发送和接收数据的操作都是阻塞的，除非另一端已经准备好。


### 6.12. 通过 channel 实现同步


```go
package main

import (
	"fmt"
	"time"
)

//  定义全局变量——通道
var cusChan = make(chan int)

func Printer(str string) {
	for _, c := range str {
		fmt.Printf("%c", c)
		time.Sleep(time.Second)
	}
	fmt.Println()
}

func Person1() {
	Printer("Hello")
	//  打印完之后为通道赋值
	cusChan <- 1
}

func Person2() {
	//  读取通道中的数据，如果没有数据，阻塞不继续执行。什么时候有数据什么时候开始继续执行
	<-cusChan
	Printer("Go")
}

func main() {
	go Person1()
	go Person2()

	for {
	}
}
```

运行结果：

```
cnpeng$ go run day6.go clear
Hello
Go
```

### 6.13. 通过 channel 实现同步和数据交互

先看一个普通示例：

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	go func() {
		defer fmt.Println("子协程执行完毕了")

		for i := 0; i < 2; i++ {
			fmt.Println("子协程中的循环：", i)
			time.Sleep(time.Second)
		}
	}()
}
```

上述示例代码中，由于主协程退出的时候子协程还没有来得及执行，所以，子协程中的打印语句不会被执行。

此时，我们可以通过 channel 控制先执行 子协程。子协程执行完成之后再去执行 主协程 中的内容。示例如下：


```go
package main

import (
	"fmt"
	"time"
)

func main() {

	cusChan := make(chan string)
	defer fmt.Println("主协程执行完毕了")

	go func() {
		defer fmt.Println("子协程执行完毕了")

		for i := 0; i < 2; i++ {
			fmt.Println("子协程中的循环：", i)
			time.Sleep(time.Second)
		}

		cusChan <- "666"
	}()

	str := <-cusChan
	fmt.Println("主协程中接收到管道中的数据：", str)
}
```

运行结果：

```
cnpeng$ go run day6.go clear
子协程中的循环： 0
子协程中的循环： 1
子协程执行完毕了
主协程中接收到管道中的数据： 666
主协程执行完毕了
```


### 6.14.  无缓冲 channel

```go
// 无缓冲 channel 
make(chan Type)

// 等价于 
make(chan Type , 0)

```

`len (chan)` 缓冲区剩余数据个数

`cap (chan)` 缓冲区容量大小
 

### 6.15.  有缓冲 channel

有缓冲的通道当数据存满了会阻塞，当通道空了也会阻塞

### 6.16.  关闭 channel

`close(chan)` 可以关闭通道 channel 


```go
package main

import (
	"fmt"
)

func main() {

	cusChan := make(chan int)

	go func() {

		for i := 0; i < 5; i++ {
			// 向通道中写数据
			cusChan <- i
		}

		// 关闭通道
		close(cusChan)
	}()

	for {
		// 接收通道传递的值，并检测通道是否开启，开启为true，关闭为false
		value, isChanOpen := <-cusChan

		if isChanOpen {
			fmt.Println("通道中传递的数据为：", value)
		} else {
			fmt.Println("通道被关闭了")
			break
		}
	}
}
```

运行结果：

```
cnpeng$ go run day6.go clear
通道中传递的数据为： 0
通道中传递的数据为： 1
通道中传递的数据为： 2
通道中传递的数据为： 3
通道中传递的数据为： 4
通道被关闭了
```


### 6.17.  通过 range 遍历 channel 传递的数据

```go
package main

import (
	"fmt"
)

func main() {

	cusChan := make(chan int)

	go func() {

		for i := 0; i < 5; i++ {
			// 向通道中写数据
			cusChan <- i
		}

		// 关闭通道
		close(cusChan)
	}()

	for num := range cusChan {
		fmt.Println("通道中传递的数据：", num)
	}
}
```

运行结果：

```
cnpeng$ go run day6.go clear
通道中传递的数据： 0
通道中传递的数据： 1
通道中传递的数据： 2
通道中传递的数据： 3
通道中传递的数据： 4
```

### 6.18.  单向 channel 特点

默认情况下， channel 通道是双向的，既可以接收数据也可以发送数据。单向通道就是指 仅能接收或者发送的通道。

```go
// 普通双向通道
var chan1 chan int 

// 只能接收数据的单向通道
var chan2 chan <- int

// 只能发送数据的单向通道
var chan3 <-chan int

```

双向通道可以隐式转换为单向通道，但单向通道不能转为双向通道。

```go
package main

func main() {

	doubleChan := make(chan int)

	// 隐式转换双向通道为 只能写入数据的单向通道--sendOnly
	var recChan chan<- int = doubleChan

	// invalid operation: <-recChan ,receive from sendOnly type chan<-int
	// num := <-recChan

	// 隐式转换双向通道为 只能写出数据的的单向通道——receiveOnly
	var sendChan <-chan int = doubleChan
	// invalid operation: sendChan<-666 , send to receive only type <-chan int
	// sendChan <- 666
	
	//...其他内容省略
}

```


### 6.19.  单向 channle 的应用

```go
package main

import "fmt"

func main() {
	cusChan := make(chan int)
	// 通道的传递是值引用
	go Writer(cusChan)
	Reader(cusChan)
}

// 隐式转换为单向只能写入的通道
func Writer(writeChan chan<- int) {
	for i := 0; i < 5; i++ {
		writeChan <- i
	}
	close(writeChan)
}

// 隐式转换为单向只能读取的通道
func Reader(readChan <-chan int) {
	for num := range readChan {
		fmt.Println("通道中的数据为：", num)
	}
}
```

运行结果：

```
cnpeng$ go run day6.go clear
通道中的数据为： 0
通道中的数据为： 1
通道中的数据为： 2
通道中的数据为： 3
通道中的数据为： 4
```

### 6.20.  Timer 的使用

Timer 定时器，表示未来的一个单一事件。Timer 内部提供了一个 channel

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	// 创建定时器，定时两秒，到达预定时间后向其内置通道传递当前时间, 并且只写一次
	timer := time.NewTimer(2 * time.Second)
	fmt.Println("当前时间：", time.Now())

	// Timer 内置一个通道 C，通道中的数据为当前时间
	newTime := <-timer.C
	fmt.Println("新的时间：", newTime)
}
```

运行结果：

```
cnpeng$ go run day6.go clear
当前时间： 2019-02-26 11:39:09.333366 +0800 CST m=+0.000467581
新的时间： 2019-02-26 11:39:11.336903 +0800 CST m=+2.004067627
```

### 6.21. Timer 实现延时功能

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	delayWork1()
	delayWork2()
	delayWork3()
}

func delayWork1() {
	timer := time.NewTimer(2 * time.Second)
	<-timer.C

	fmt.Println("延时两秒后才打印这一句话——1")
}
func delayWork2() {
	// 返回一个通道
	<-time.After(2 * time.Second)

	fmt.Println("延时两秒后才打印这一句话——2")
}
func delayWork3() {
	// 直接睡两秒
	time.Sleep(2 * time.Second)
	fmt.Println("延时两秒后才打印这一句话——3")
}
```

运行结果：

```
cnpeng$ go run day6.go clear
延时两秒后才打印这一句话——1
延时两秒后才打印这一句话——2
延时两秒后才打印这一句话——3
``` 


### 6.22. 定时器停止

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	timer := time.NewTimer(2 * time.Second)
	go func() {
		<-timer.C
		fmt.Println("延时两秒后才打印这一句话——1")
	}()

	// 关闭定时器
	timer.Stop()
	fmt.Println("定时器被关闭了")

	for {
		// 加死循环避免没没触发子协程就退出
	}
}
``` 

上述代码中，

由于在主协程中关闭了 timer 所以，子协程中的 timer.C 一直没有数据，处于阻塞状态，所以后面的打印语句不会执行。



### 6.23. 定时器重置

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	// 构建定时器时设置延时时间为 5秒
	timer := time.NewTimer(5 * time.Second)
	// 重置定时器延时时间为1秒
	timer.Reset(1)
	<-timer.C
	fmt.Println("延时打印这一句话——1")
}
```

运行结果：

```
cnpeng$ go run day6.go clear
延时两秒后才打印这一句话——1
```

### 6.24. Ticker 的使用

Ticker 是一个定时触发的计时器，它会以一个时间间隔（interval）不停的向内置的 channel 发送当前时间。

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	// 时间间隔为2秒
	ticker := time.NewTicker(2 * time.Second)

	// 计数使用
	i := 0
	go func() {
		<-ticker.C

		// 不停的写，不停的遍历读取
		for time := range ticker.C {
			fmt.Println("管道中的时间：", time)
			i++

			if 5 == i {
				ticker.Stop()
			}
		}
	}()

	for {
	}
}
```

运行结果：

```
cnpeng$ go run day6.go clear
管道中的时间： 2019-02-26 12:10:03.995149 +0800 CST m=+4.005423896
管道中的时间： 2019-02-26 12:10:05.99507 +0800 CST m=+6.005407917
管道中的时间： 2019-02-26 12:10:07.993079 +0800 CST m=+8.003478901
管道中的时间： 2019-02-26 12:10:09.994968 +0800 CST m=+10.005431451
管道中的时间： 2019-02-26 12:10:11.994075 +0800 CST m=+12.004600660
```

### 6.25. select 的使用

select 关键字可以用来监听 channel 上的数据流动。

select 与 switch 类似，但是，**select 的分支条件必须是 IO 操作**，

```
select{
	case <- chan1:
		// 如果成功的从 chan1 读取到数据，则执行该分支
	case chan2 <- 1:
		// 如果成功的向 chan2 写入数据，执行该分支
	default:
		// 如果之前的分支都没有匹配到，执行该默认分支
}
```

如果所有的 case 分支都不满足，那么：

- 如果有 default 分支，则执行 defalut 分支
- 如果没有 default 分支，则 select 语句被阻塞，直到有一个 case 可以被执行。 

### 6.26. 通过 select 实现斐波那契数列

前两个数相加的和为第三个数，这种数就被称为 斐波那契数列。如： 1 1 2 3 5 8 ...

```go
package main

import "fmt"

func main() {
	// 用来传递数据
	dataChan := make(chan int)
	// 用来控制合适结束
	controlChan := make(chan bool)

	go func() {
		for i := 0; i < 8; i++ {
			num := <-dataChan
			fmt.Println("dataChan中的数据为：", num)
		}

		controlChan <- true
	}()

	Fibonacci(dataChan, controlChan)
}

//Fibonacci :隐式的将双向chan 转换为单向的chan
func Fibonacci(dataChan chan<- int, controlChan <-chan bool) {
	x, y := 1, 1
	for {
		select {
		case dataChan <- x:
			// 向 dataChan 传递数据
			x, y = y, x+y
		case flag := <-controlChan:
			// 该分支当前不关心 flag 的值，只要有数据就会触发这里的语句
			fmt.Println("flag 的值为：", flag)
			return
		}
	}
}
```

运行结果：

```
cnpeng$ go run day6.go clear
dataChan中的数据为： 1
dataChan中的数据为： 1
dataChan中的数据为： 2
dataChan中的数据为： 3
dataChan中的数据为： 5
dataChan中的数据为： 8
dataChan中的数据为： 13
dataChan中的数据为： 21
flag 的值为： true
```

### 6.27. 通过 select 实现斐波那契数列--画图

略

### 6.28. select 实现超时机制

类似于 在页面停留一段时间之后，退出页面 的逻辑

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	dataChan := make(chan int)
	controlChan := make(chan bool)

	go func() {
		for {
			select {
			case num := <-dataChan:
				fmt.Println("数据内容为：", num)
			case <-time.After(3 * time.Second):
				fmt.Println("3 秒 无动作，退出")
				controlChan <- false
				return
			}
		}
	}()

	<-controlChan
	fmt.Println("主协程退出")
}
```

运行结果:

```
cnpeng$ go run day6.go clear
3 秒 无动作，退出
主协程退出
```

上述示例代码中，在前3秒以内的时候，由于都不满足 select 中的分支条件，所以，前三秒两个 chan 都处于阻塞状态。3秒超时之后，满足了 select 中的第二个分支，此时，controlChan 不再 阻塞。

---

## 7. 七、Day7

### 7.1.  昨日回顾

略

### 7.2.  网络协议介绍

共同约定和遵守的规则

### 7.3.  分层模型介绍

![](https://images.gitee.com/uploads/images/2019/0226/142704_7c0d7046_930142.png "屏幕截图.png")

分层的目的是为了减少协议的复杂度。

越底层的协议越靠近硬件，越上层的协议越接近用户。

每一层利用下一层提供的服务为上一层提供服务，本层服务内容实现对上层细节的屏蔽。

### 7.4.  层和协议

![](https://images.gitee.com/uploads/images/2019/0226/143050_cf38d7c4_930142.png "屏幕截图.png")

上述这些协议通常为 TCP/IP 协议

- ARP ： 正向地址解析协议（Address Resolution Protocol）。通过已知的 IP 寻找对应主机的 MAC 地址
- RARP ：反向地址转换协议。通过 MAC 确定 IP 地址
- IP ： 因特网互联协议（Internet Protocol）
- ICMP ： Internet 控制报文协议（Internet Control Message Protocol）, 是因特网协议家族中的一个组播协议。该协议运行在主机和组播路由器之间
- TCP ：传输控制协议（Transmission Control Protocol） 是一种面向链接的、可靠的、基于字节流的传输层通信协议。
- UDP ： 用户数据报文协议（User Datagram Protocol） 是 OSI 参考模型中一种无连接的传输层协议，提供面向事物的简单不可靠信息传输服务
- HTTP ： 超文本传输协议（Hyper Text Transfer Protocol） 是互联网上应用最为广泛的网络协议
- FTP ：文件传输协议（File Transfer Protocol）

### 7.5.  链路层介绍

MAC ：网卡对应的唯一标识，就是数据包的物理发送地址和物理接收地址。


### 7.6.  网络层的作用

IP ：区分不同的计算机是否属于同一个子网络，是一个 逻辑地址

网络层协议主要包含的就是 源IP 和 目的IP

### 7.7.  传输层的作用

端口：区分是属于哪个 应用程序

传输层主要包括：源端口 和 目标端口

### 7.8.  应用层的作用

规定应用程序发送和接收的数据格式，从而实现接收到数据之后的数据解读。

### 7.9.  网络分层和协议总结

略

### 7.10.  网络通信条件

- 网卡（MAC 地址），不需要用户指定
- 逻辑地址——Ip地址，需要用户指定
- 端口，确定哪个应用接收数据——一个应用程序只能定义一个端口；不同设备中的同一应用端口不一定一致


### 7.11. 通信过程如何组包和拆包

![](https://images.gitee.com/uploads/images/2019/0226/145900_084f4969_930142.png "屏幕截图.png")

左侧自上而下为组包，东西越来越多

右侧自下而上为解包，东西越来越少

### 7.12. Socket 简单介绍

Socket 套接字编程。

Socket 起源于 Unix, Unix 的基本哲学之一就是 “一切皆文件”，都可以用 “打开Open --> 读写 Write/Read --> 关闭 close” 模式来操作。Socket 就是该模式的一个实现。

网络的 Socket 数据传输是一种特殊的 I/O，Socket 也是一种文件描述符。Socket 也具有一个类似于 打开文件的函数：Socket() , 该函数返回一个整型的 Socket 描述符，随后的连接简历、数据传输等操作都是通过该 Socket 实现的

常用的 Socket 类型两种：

- SOCK STREMA ：流式 Socket , 是一种面向连接的 Socket ，针对于面向连接的 TCP 服务应用。
- SOCK DGRAM ：数据报式 Socket , 是一种无连接的 Socket, 对应于无连接的UDP服务应用。


### 7.13. TCP 的 c/s 模型介绍

C/S : Client/Server

TCP 三次握手：你好，是小明吗？我是小明，你是谁？我是你二大爷。 至少经过上述三个步骤才能确认对方身份。

C/S 模型：

![](https://images.gitee.com/uploads/images/2019/0226/150956_35c318bc_930142.png "屏幕截图.png")



### 7.14.  TCP 服务器代码编写

严格遵守 C/S 模型即可。

127.0.0.1 表示本机地址

* TcpServer.go

```go
package main

import (
	"fmt"
	"net"
)

func main() {
	//  等待接收
	netListen, err := net.Listen("tcp", "127.0.0.1:8000")
	if nil != err {
		fmt.Println("net.Listen.ERR: ", err)
		return
	}

	defer netListen.Close()

	//  接收
	conn, err2 := netListen.Accept()
	if nil != err2 {
		fmt.Println("netListen.Accept.ERR: ", err2)
		return
	}
	defer conn.Close()

	//  读取内容
	buf := make([]byte, 1024*2)
	n, err3 := conn.Read(buf)
	if nil != err3 {
		fmt.Println("conn.Read.ERR: ", err3)
		return
	}

	fmt.Println("客户端传递过来的内容为：", string(buf[:n]))
}
```

代码编辑完成之后，在终端中运行 `go run TcpServer.go ` 启动该服务器。

然后打开 PostMan 访问 `127.0.0.1:8000`, 如下图：

![](https://images.gitee.com/uploads/images/2019/0226/153444_74829ba5_930142.png "屏幕截图.png")

点击 send 之后，终端中就会显示如下内容：

```
客户端传递过来的内容为： GET /?name=%E5%BC%A0%E4%B8%89 HTTP/1.1
cache-control: no-cache
Postman-Token: 4f817b1e-3001-4691-9029-b53cd61565b7
User-Agent: PostmanRuntime/7.1.5
Accept: */*
Host: 127.0.0.1:8000
accept-encoding: gzip, deflate
Connection: keep-alive


```

### 7.15.  netcat 工具的使用

略

此处可以使用 PostMan 替代



### 7.16.  TCP 客户端代码编写

* TcpClient.go

```go
package main

import (
	"fmt"
	"net"
)

func main() {
	conn, err := net.Dial("tcp", "127.0.0.1:8000")
	if nil != err {
		fmt.Println("net.Dial.ERR", err)
	}

	strByte := []byte("are you ok ?")
	conn.Write(strByte)
}
```

编写完上述代码之后，先运行前面编写的 TcpServer.go ，然后再新开一个终端，在新的终端中运行 TcpClient.go.

运行完成之后，在 TcpServer.go 所在的终端就会显示如下内容：

```
客户端传递过来的内容为： are you ok ?
```

### 7.17.  简单版并发服务器

客户端输入小写，服务端返回大写；客户端输入 exit ,则 终止程序。

```go
package main

import (
	"fmt"
	"net"
	"strings"
)

func main() {
	//  等待接收
	netListen, err := net.Listen("tcp", "127.0.0.1:8003")
	if nil != err {
		fmt.Println("net.Listen.ERR: ", err)
		return
	}

	defer netListen.Close()

	for {
		//  接收
		conn, err2 := netListen.Accept()
		if nil != err2 {
			fmt.Println("netListen.Accept.ERR: ", err2)
			return
		}
		defer conn.Close()

		//  读取内容
		go HandlerData(conn)
	}
}

// HandlerData 处理客户端传递过来的数据
func HandlerData(conn net.Conn) {

	// 3- 获取客户端的地址
	addr := conn.RemoteAddr().String()

	for {
		// 3- 读取客户端传递的数据
		buf := make([]byte, 1024*2)
		n, err3 := conn.Read(buf)
		if nil != err3 {
			fmt.Println("conn.Read.ERR: ", err3)
			return
		}

		fmt.Printf("[%s]传递过来的内容为:[%s],长度为：[%d] \n", addr, string(buf[:n]), len(string(buf[:n])))

		// 注意：接收到的内容可能会自带换行或者其他符号, 所以要 -1 比较
		if "exit" == string(buf[:n-1]) {
			// 如果用户输入了 exit 退出程序
			return
		}

		// 3- 修改并返回数据给客户端
		// 转换为大写
		upperStr := strings.ToUpper(string(buf[:n]))
		conn.Write([]byte(upperStr))
	}
}
```


### 7.18.  客户端既可输入也可以接收服务器的回复

```go
package main

import (
	"fmt"
	"net"
	"os"
)

func main() {
	//  链接服务器
	conn, err := net.Dial("tcp", "127.0.0.1:8003")
	if nil != err {
		fmt.Println("net.Dial.ERR", err)
	}

	defer conn.Close()

	go func() {
		//  向服务器发送数据
		strByte := make([]byte, 1024)
		for {
			//从屏幕读取内容
			n, err2 := os.Stdin.Read(strByte)
			if nil != err2 {
				fmt.Println("os.Stdin.Read: ", err2)
				return
			}
			conn.Write(strByte[:n])
		}
	}()

	//  接收服务器内容
	buf := make([]byte, 1024)
	for {
		n, err := conn.Read(buf)
		if nil != err {
			fmt.Println("conn.Read ：", err)
			return
		}

		fmt.Println("服务端返回的数据为：", string(buf[:n]))
	}

}
```

此时，先运行 TcpSercer.go 然后运行 TcpClient.go , 然后在客户端所在的终端中输入数据，服务端所在终端就会接收并返回数据给客户端。

### 7.19.  文件传输原理

![](https://images.gitee.com/uploads/images/2019/0226/165754_9ade5280_930142.png "屏幕截图.png")

先把文件名发送给对方，对方接收文件名成功后给发送方一个响应，然后发送方再发送文件内容。

### 7.20.  os.Stat 的使用

```go
package main

import (
	"fmt"
	"os"
)

func main() {

	args := os.Args

	if 2 != len(args) {
		fmt.Println("参数数量不对，必须有两个参数，且第二个参数为目标文件")
		return
	}

	fileInfo, err := os.Stat(args[1])
	if nil != err {
		fmt.Println("os.Stat", err)
	}

	fmt.Println("文件名：", fileInfo.Name())
	fmt.Println("文件大小：", fileInfo.Size())
}
```

运行结果：

```
cnpeng$ go run osstat.go /Users/cnpeng/Downloads/CnPeng_1-LearningNotes-master.zip
文件名： CnPeng_1-LearningNotes-master.zip
文件大小： 489989
```

### 7.21. 传输文件：发送方

### 7.22. 传输文件：接收方

### 7.23. 传输文件功能验证

### 7.24. 并发聊天服务器功能演示

### 7.25. 并发聊天服务器原理分析

### 7.26. 并发聊天服务器：广播上线

### 7.27. 并发聊天服务器：广播消息

### 7.28. 并发聊天服务器：查询在线用户

### 7.29. 并发聊天服务器：修改用户名

### 7.30. 并发聊天服务器：用户主动退出

### 7.31. 并发聊天服务器：超时处理



---

## 8. 八、Day8

### 8.1.  昨日回顾

略

### 8.2.  web工作流程

![](https://images.gitee.com/uploads/images/2019/0226/172744_2225d5a6_930142.png "屏幕截图.png")

### 8.3.  请求包和响应包简单介绍

![](https://images.gitee.com/uploads/images/2019/0226/173347_79e86e5e_930142.png "屏幕截图.png")

### 8.4.  http 协议和 url 介绍

![](https://images.gitee.com/uploads/images/2019/0226/174035_7dc75099_930142.png "屏幕截图.png")

### 8.5.  请求报文格式分析

![](https://images.gitee.com/uploads/images/2019/0226/173905_a654885d_930142.png "屏幕截图.png")

先编写一个服务器程序：

* HttpServer.go 

```
package main

import (
	"fmt"
	"net"
)

func main() {
	//  设置监听
	listen, err := net.Listen("tcp", "127.0.0.1:8000")
	if nil != err {
		fmt.Println("net.Listen: ", err)
		return
	}

	//  接受客户端请求
	conn, _ := listen.Accept()

	//  读取客户端的请求内容
	buf := make([]byte, 1024*3)
	n, err3 := conn.Read(buf)

	if nil != err3 {
		fmt.Println(conn.Read, err3)
	}

	fmt.Printf("客户端发送的请求内容：\n #%s# \n", string(buf[:n]))
}
```

终端中运行上述程序：`go run HttpServer.go `

打开浏览器，然后输入 : 127.0.0.1:8000  并敲击回车。

此时，终端中会显示如下内容：

```
客户端发送的请求内容：
 #GET / HTTP/1.1
Host: 127.0.0.1:8000
Connection: keep-alive
Cache-Control: max-age=0
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.109 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8
Accept-Encoding: gzip, deflate, br
Accept-Language: en,zh;q=0.9,zh-CN;q=0.8

# 
```

请求头解析：

![](https://images.gitee.com/uploads/images/2019/0226/175105_7a664d0b_930142.png "屏幕截图.png")

### 8.6.  服务器如何知道用户需要什么资源

我们重新部署上一节中的 HttpServer.go ，然后在浏览器中访问：127.0.0.1：8000/cnpeng.html , 然后终端中就会显示如下内容。其中就包含了我们想要访问的页面：cnpeng.html

```
客户端发送的请求内容：
 #GET /cnpeng.html HTTP/1.1
Host: 127.0.0.1:8000
Connection: keep-alive
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.109 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8
Accept-Encoding: gzip, deflate, br
Accept-Language: en,zh;q=0.9,zh-CN;q=0.8

# 
```

### 8.7.  响应报文测试方法

* HttpServer.go

```
package main

import (
	"fmt"
	"net/http"
)

func myHandler(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintln(w, "hello world")
}

func main() {
	http.HandleFunc("/go", myHandler)

	http.ListenAndServe("127.0.0.1:8000", nil)
}
```

上面的内容使用到了后面将要介绍的 http 编程。

启动上述服务，然后在浏览器中输入：`127.0.0.1:8000/go` 回车后，界面中将会显示 “hello world” ， 也就是 myHandler 中打印语句的内容

### 8.8.  响应报文格式分析

查看服务端响应给客户端的完整内容：

* HttpClient.go

```go
package main

import (
	"fmt"
	"net"
)

func main() {
	conn, err := net.Dial("tcp", "127.0.0.1:8000")

	if nil != err {
		fmt.Println("net.Dial: ", err)
		return
	}

	// 这一堆是之前监测到的服务器返回来的数据，然后将更改了其中的请求行
	requestStr := `GET /go HTTP/1.1
Host: 127.0.0.1:8000
Connection: keep-alive
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.109 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8
Accept-Encoding: gzip, deflate, br
Accept-Language: en,zh;q=0.9,zh-CN;q=0.8

`
	_, err2 := conn.Write([]byte(requestStr))
	if nil != err2 {
		fmt.Println("conn.Write: ", err2)
		return
	}

	buf := make([]byte, 1024*2)
	n, err3 := conn.Read(buf)
	if 0 == n {
		// 读取完毕或者出错了
		fmt.Println("conn.Read: ", err3)
		return
	}

	fmt.Printf("响应结果：\n#%s# \n", string(buf[:n]))

}
```

先运行 HttpServer.go , 然后运行 HttpClient.go 此时，在后者对应的终端中，会展示如下信息：

```
响应结果：
#HTTP/1.1 200 OK
Date: Tue, 26 Feb 2019 12:30:39 GMT
Content-Length: 12
Content-Type: text/plain; charset=utf-8

hello world
# 
```

响应结果中的状态码显示了响应成功或者失败。上述结果状态码为 200 ，表示响应成功。

#### 8.8.1.  状态码分类

状态码由三位数字组成，第一位数字表示响应的类型，常用状态码由如下 5 类：

类别|含义
---|---
1xx|表示服务器已经接收了客户端请求，客户端可继续发送请求
2xx|表示服务器已经成功接收到请求并进行处理
3xx|表示服务器要求客户端重定向
4xx|表示客户端的请求有非法内容
5xx|表示服务器未正常处理客户端的请求而出现意外错误

#### 8.8.2.  常见状态码

状态码|含义
---|---
200 OK | 客户端请求成功
400 Bad Request | 请求报文有语法错误
401 Unauthorized | 未授权
403 Forbidden | 服务器拒绝服务
500 Internal Server Error | 服务器内部错误
503 Server Unavailable | 服务器暂时不能处理客户端请求


### 8.9.  http 编程介绍

Go 语言提供 net/http 可以让我们方便的实现 Http 客户端和服务端。（比之前的 net 包下的CS实现简单，所以。。。）
 
 

### 8.10.  http 服务器编程

```go
package main

import (
	"fmt"
	"net/http"
)

// w 用来给客户端返回数据，r 用来读取客户端传递的数据
func myHandler(w http.ResponseWriter, r *http.Request) {
	//fmt.Fprintln(w, "hello world")
	w.Write([]byte("hello go"))
}

func main() {

	// 为 DefaultServeMux 注册 Hanlder
	http.HandleFunc("/", myHandler)

	// 对指定地址进行监听。第二个参数为用来处理监听结果的hanlder ,通常传 nil ,表示调用 DefaultServeMux 的 handler
	http.ListenAndServe("127.0.0.1:8000", nil)
}
```

直接在浏览器中访问 127.0.0.1:8000 ，然后浏览器中就会显示 hello go

### 8.11. http 服务器获取客户端的信息

```go

func myHandler(w http.ResponseWriter, r *http.Request) {
	// fmt.Fprintln(w, "hello world")
	w.Write([]byte("hello go"))

	fmt.Println("请求方式:", r.Method)
	fmt.Println("请求URL:", r.URL)
	fmt.Println("请求Body:", r.Body)
}

//... 其他代码内容省略
```

当我们运行上一节中的 HttpServer.go 然后在浏览器中访问 127.0.0.1:8000 的时候，终端中会得到如下内容：

```
请求方式: GET
请求URL: /
请求Body: {}

```

### 8.12. http 客户端编程

```go
package main

import (
	"fmt"
	"net/http"
)

func main() {
	// 百度已经不能爬了，所以，爬一下简书吧
	resp, err := http.Get("https://www.jianshu.com/notifications#/others")

	// resp 中的 Body 是 io ,所以需要关闭
	defer resp.Body.Close()

	if nil != err {
		fmt.Println("http.Get: ", err)
		return
	}

	fmt.Println("Status:", resp.Status)
	fmt.Println("Header:", resp.Header)

	var bodyStr string
	buf := make([]byte, 1024*2)

	for {
		// 从 io流 中读取内容
		n, err := resp.Body.Read(buf)
		if nil != err {
			fmt.Println("resp.Body.Read: ", err)
			break
		}

		bodyStr += string(buf[:n])
		fmt.Println("resp.Body:", bodyStr)
	}

	fmt.Println("resp.Body:", bodyStr)
}
```

运行结果：

```
cnpeng$ go run HttpClientV2.go 
Status: 200 OK
Header: map[Strict-Transport-Security:[max-age=31536000; includeSubDomains; preload] Content-Type
:[text/html; // 太长了，手动删掉了一部分....
resp.Body: <!DOCTYPE html>
<head>
  <meta charset="utf-8">
  	... 后面内容都是页面源码太多了，手动删除了
```


### 8.13. 百度贴吧爬虫案例

* TieBaSpider.go

```go
package main

import (
	"fmt"
	"io"
	"net/http"
	"os"
	"strconv"
)

func main() {
	var startPage, endPage int
	fmt.Println("请输入起始页：")
	fmt.Scan(&startPage)

	fmt.Println("请输入终止页: ")
	fmt.Scan(&endPage)

	SpiderData(startPage, endPage)
}

func SpiderData(start, end int) {
	for index := start; index <= end; index++ {
		var url = "http://tieba.baidu.com/f?kw=%E5%9B%BE%E6%8B%89%E4%B8%81&ie=utf-8&pn=" + strconv.Itoa((index-1)*50)

		fmt.Println("URL:", url)

		// 访问链接
		resp, err := http.Get(url)
		if nil != err {
			fmt.Println("http.Get: ", err)
			continue
		}

		defer resp.Body.Close()

		// 创建文件
		fileName := strconv.Itoa(index) + ".html"
		fileObj, err3 := os.Create(fileName)
		if nil != err3 {
			fmt.Println("os.Create: ", err3)
			continue
		}

		defer fileObj.Close()

		// 读取数据
		buf := make([]byte, 1024*2)

		for {
			n, err2 := resp.Body.Read(buf)
			if nil != err2 {
				if io.EOF == err2 {
					fmt.Println("写出完毕")
				} else {
					fmt.Println("resp.Body.Read：", err2)
				}
				break
			}

			// 写出到文件
			_, err4 := fileObj.WriteString(string(buf[:n]))

			if nil != err4 {
				if io.EOF == err4 {
					fmt.Println("写出完毕")
				} else {
					fmt.Println("fileObj.Write : ", err4)
				}
				break
			}
		}
	}
}
```

运行结果就是在当前目录下多了5个百度贴吧的页面

### 8.14.  百度贴吧爬虫案例总结

略

### 8.15.  并发版网络爬虫

使用 go 协程实现并发，使用通道避免主协程退出导致子协程未能执行(完毕)。

注意：下面的示例代码是个人实现的，与视频教程中的原理一致，只是在读取和写出的时候略有差异。


```go
package main

import (
	"fmt"
	"io"
	"net/http"
	"os"
	"strconv"
)

func main() {
	var startPage, endPage int
	fmt.Println("请输入起始页：")
	fmt.Scan(&startPage)

	fmt.Println("请输入终止页: ")
	fmt.Scan(&endPage)

	SpiderData(startPage, endPage)
}

func SpiderData(start, end int) {

	pageChan := make(chan int)

	for index := start; index <= end; index++ {
		go SpiderOnePage(index, pageChan)
	}

	<-pageChan
}

func SpiderOnePage(index int, pageChan chan<- int) {
	var url = "http://tieba.baidu.com/f?kw=%E5%9B%BE%E6%8B%89%E4%B8%81&ie=utf-8&pn=" + strconv.Itoa((index-1)*50)

	fmt.Println("URL:", url)

	// 访问链接
	resp, err := http.Get(url)
	if nil != err {
		fmt.Println("http.Get: ", err)
		return
	}

	defer resp.Body.Close()

	// 创建文件
	fileName := strconv.Itoa(index) + ".html"
	fileObj, err3 := os.Create(fileName)
	if nil != err3 {
		fmt.Println("os.Create: ", err3)
		return
	}

	defer fileObj.Close()

	// 读取数据
	buf := make([]byte, 1024*2)

	for {
		n, err2 := resp.Body.Read(buf)
		if nil != err2 {
			if io.EOF == err2 {
				fmt.Println("写出完毕")
			} else {
				fmt.Println("resp.Body.Read：", err2)
			}
			break
		}

		// 写出到文件
		_, err4 := fileObj.WriteString(string(buf[:n]))

		if nil != err4 {
			if io.EOF == err4 {
				fmt.Println("写出完毕")
			} else {
				fmt.Println("fileObj.Write : ", err4)
			}
			break
		}
	}

	// 写完一次就更改通道数据
	pageChan <- index
}
```

### 8.16.  段子爬虫：明确目标

从捧腹网爬取内容：pengfue.com

* 爬取列表页面
* 获取列表页面中每一个笑话的详情链接
* 爬取单个笑话详情页面内容
* 取出单个笑话的标题和内容
* 拼接当前列表页面下所包含全部笑话的标题和内容
* 写出当前列表页面拼接的内容
* 改为并发

### 8.17.  段子爬虫：爬主页面有用链接
略——直接看后面的代码
### 8.18.  段子爬虫：爬取段子详情页面
略——直接看后面的代码
### 8.19.  段子爬虫：把内容存储到文件
略——直接看后面的代码
### 8.20.  段子爬虫：并发爬虫

下面是自己写的代码，和教程中的略有区别。教程中封装的函数更细

```go
package main

import (
	"fmt"
	"io"
	"net/http"
	"os"
	"regexp"
	"strconv"
	"strings"
)

// 封装函数的时候，把错误信息返回给外部，由外部自己处理。自定义错误信息使用：fmt.Error(“xxx”)

// SpiderOnePage 爬取指定页面的内容并返回字符串
func SpiderOnePage(url string) (strResult string) {
	// 访问页面
	fmt.Println("URL: ", url)
	resp, err := http.Get(url)
	if nil != err {
		fmt.Println("http.Get: ", err)
		return
	}
	defer resp.Body.Close()

	// 读取内容
	contentBuf := make([]byte, 1024*4)

	for {
		n, err3 := resp.Body.Read(contentBuf)
		if nil != err3 {
			if io.EOF != err3 {
				fmt.Println("resp.Body.Read: ", err3)
			}
			break
		}
		strResult += string(contentBuf[:n])
	}
	return
}

// WriteToFile 将指定的自渡船内容写出到指定名称的文件
func WriteToFile(i int, str string) {
	// 定义文件
	fileName := "捧腹网_" + strconv.Itoa(i) + ".txt"
	fmt.Println("fileName", fileName)
	fileObj, err2 := os.Create(fileName)
	if nil != err2 {
		fmt.Println("os.Create: ", err2)
		return
	}

	defer fileObj.Close()

	// 写出内容到文件
	_, err4 := fileObj.WriteString(str)
	if nil != err4 {
		if io.EOF == err4 {
			// 写完了才去更新通道数据

		} else {
			fmt.Println("fileObj.Write: ", err4)
		}
	}
}

// SpiderData 爬取指定索引页面的内容
func SpiderData(i int, controlChan chan int) {
	url := "https://www.pengfue.com/index_" + strconv.Itoa(i) + ".html"

	// 爬取索引为 i 的列表页面内容
	strContent := SpiderOnePage(url)

	// 从内容中读取单个笑话的详情页面链接
	// <h1 class="dp-b"><a href="https://www.pengfue.com/content_1857337_1.html" target="_blank">其他选择</a>
	regex := regexp.MustCompile(`<h1 class="dp-b"><a href="(?s:(.*?))" target="`)

	if nil == regex {
		fmt.Println("regexp.MustCompile——取详情网址的正则错误")
	}
	htmls := regex.FindAllStringSubmatch(strContent, -1)

	var str2Write string

	for _, html := range htmls {
		// fmt.Println("HTML: ", html[1])
		// 读取单个笑话详情页面的内容
		detailStr := SpiderOnePage(html[1])

		// 从详情页面字符串中读取标题
		titleRegex := regexp.MustCompile(`<h1>(?s:(.*?))</h1>`)
		titles := titleRegex.FindAllStringSubmatch(detailStr, 1)

		for _, title := range titles {
			// 去除空格 换行 TAB 等
			tempTitle := title[1]
			tempTitle = strings.Replace(tempTitle, "\t", "", -1)
			tempTitle = strings.Replace(tempTitle, "\n", "", -1)
			tempTitle = strings.Replace(tempTitle, " ", "", -1)
			tempTitle = strings.Replace(tempTitle, "&nbsp;", "", -1)
			str2Write += tempTitle
			str2Write += "\n"

			// 即便后面有多个也不管了，只取第一个就够了
			break
		}

		// 从详情页面字符串中读取内容
		detailRegex := regexp.MustCompile(`<div class="content-txt pt10">(?s:(.*?))<a`)
		details := detailRegex.FindAllStringSubmatch(detailStr, 1)
		for _, title := range details {
			// 去除空格 换行 TAB 等
			tempDetail := title[1]
			tempDetail = strings.Replace(tempDetail, "\t", "", -1)
			tempDetail = strings.Replace(tempDetail, "\n", "", -1)
			tempDetail = strings.Replace(tempDetail, " ", "", -1)
			tempDetail = strings.Replace(tempDetail, "&nbsp;", "", -1)

			str2Write += tempDetail
			str2Write += "\n\n"

			break
		}
	}
	WriteToFile(i, str2Write)
	controlChan <- i
}

func main() {
	var start, end int
	fmt.Println("请输入起始页码, > 0：")
	fmt.Scan(&start)

	fmt.Println("请输入终止页码, > 起始页码：")
	fmt.Scan(&end)

	controlChan := make(chan int)

	for i := start; i <= end; i++ {
		go SpiderData(i, controlChan)
	}

	for index := start; index <= end; index++ {
		<-controlChan
	}
}
```